<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「Babel 原理之」AST</title>
      <link href="/2021/02/23/Babel%20%E5%8E%9F%E7%90%86%E4%B9%8BAST/"/>
      <url>/2021/02/23/Babel%20%E5%8E%9F%E7%90%86%E4%B9%8BAST/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Babel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「React 源码系列之」Fiber</title>
      <link href="/2021/02/10/React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BFiber/"/>
      <url>/2021/02/10/React%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BFiber/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 逻辑复用</title>
      <link href="/2021/01/23/React%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/"/>
      <url>/2021/01/23/React%E9%80%BB%E8%BE%91%E5%A4%8D%E7%94%A8/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Redux 源码系列之」中间件</title>
      <link href="/2021/01/20/Redux%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2021/01/20/Redux%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Redux 源码系列之」react-redux</title>
      <link href="/2021/01/12/Redux%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8Breact-redux/"/>
      <url>/2021/01/12/Redux%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8Breact-redux/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Webpack5 源码系列之」TreeShaking</title>
      <link href="/2020/12/14/Webpack5%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BTreeShaking/"/>
      <url>/2020/12/14/Webpack5%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BTreeShaking/</url>
      <content type="html"><![CDATA[<blockquote><p>正在更新中 …</p></blockquote><a id="more"></a><h2 id="阅读-webpack-源码系列">阅读 Webpack 源码系列</h2><p>本系列基于 <code>webpack-4</code> 分支，版本 <code>4.44.2</code> 进行阅读</p><ul><li><p>「Webpack 源码系列之」调试</p></li><li><p>「Webpack 源码系列之」工作流</p></li><li><p>「Webpack 源码系列之」HMR</p></li><li><p>「Webpack 源码系列之」TreeShaking</p></li></ul><p>正在更新中 …</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Webpack5 源码系列之」HMR</title>
      <link href="/2020/11/20/Webpack5%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BHMR/"/>
      <url>/2020/11/20/Webpack5%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8BHMR/</url>
      <content type="html"><![CDATA[<blockquote><p>正在更新中 …</p></blockquote><a id="more"></a><h2 id="阅读-webpack-源码系列">阅读 Webpack 源码系列</h2><p>本系列基于 <code>webpack-4</code> 分支，版本 <code>4.44.2</code> 进行阅读</p><ul><li><p>「Webpack 源码系列之」调试</p></li><li><p>「Webpack 源码系列之」工作流</p></li><li><p>「Webpack 源码系列之」HMR</p></li><li><p>「Webpack 源码系列之」TreeShaking</p></li></ul><p>正在更新中 …</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Webpack 源码系列之」工作流</title>
      <link href="/2020/10/12/Webpack5%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
      <url>/2020/10/12/Webpack5%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
      <content type="html"><![CDATA[<blockquote><p>正在更新中 …</p></blockquote><a id="more"></a><h2 id="阅读-webpack-源码系列">阅读 Webpack 源码系列</h2><p>本系列基于 <code>webpack-4</code> 分支，版本 <code>4.44.2</code> 进行阅读</p><ul><li><p>「Webpack 源码系列之」调试</p></li><li><p>「Webpack 源码系列之」工作流</p></li><li><p>「Webpack 源码系列之」HMR</p></li><li><p>「Webpack 源码系列之」TreeShaking</p></li></ul><p>正在更新中 …</p><h2 id="webpack-构建流程">Webpack 构建流程</h2><p>1、初始化参数：从配置文件和 <code>shell</code> 语句中读取并合并参数，得出最终的配置对象<br>配置文件也就是 <code>webpack.config.js</code>，<code>shell</code> 语句就是 <code>process.argv</code>,就是 <code>shell</code> 语句覆盖配置文件：<code>npx webpack --mode=development</code></p><p>2、上一步得到的参数初始化，生成 Compiler</p><p>我们自己实现一个 <code>Compiler</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> <span class="keyword">extends</span> <span class="title">Tapable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.options = &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.context = context; [<span class="comment">//]设置上下文路径</span></span><br><span class="line">        <span class="keyword">this</span>.hooks = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    run(callback) &#123;</span><br><span class="line">        callback(<span class="literal">null</span>, &#123;</span><br><span class="line">            toJson() &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    entries: <span class="literal">true</span>,</span><br><span class="line">                    chunks: <span class="literal">true</span>,</span><br><span class="line">                    modules: <span class="literal">true</span>,</span><br><span class="line">                    assets: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、设置文件环境，配置插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options.context = options.context || path.resolve(process.cwd());</span><br><span class="line">    <span class="comment">//创建compiler</span></span><br><span class="line">    <span class="keyword">let</span> compiler = <span class="keyword">new</span> Compiler(options.context);</span><br><span class="line">    <span class="comment">//给compiler指定options</span></span><br><span class="line">    compiler.options = <span class="built_in">Object</span>.assign(compiler.options, options);</span><br><span class="line">    <span class="comment">//插件设置读写文件的API</span></span><br><span class="line">    <span class="keyword">new</span> NodeEnvironmentPlugin().apply(compiler);</span><br><span class="line">    <span class="comment">//调用配置文件里配置的插件并依次调用</span></span><br><span class="line">    <span class="keyword">if</span> (options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">            plugin.apply(compiler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NodeEnvironmentPlugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeEnvironmentPlugin</span> </span>&#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.inputFileSystem = fs; <span class="comment">//设置读文件的模块</span></span><br><span class="line">        compiler.outputFileSystem = fs; <span class="comment">//设置写文件的模块</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、在 <code>Compiler</code> 的 hooks 中添加 compiler.hooks.entryOption hook，并监听 make 事件，然后在 <code>WebpackOptionsApply</code>中挂载 <code>EntryOptionPlugin</code> 插件, 并且触发 <code>entryOption</code> hook</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebpackOptionsApply</span> </span>&#123;</span><br><span class="line">    process(options, compiler) &#123;</span><br><span class="line">        <span class="comment">//挂载入口文件插件</span></span><br><span class="line">        <span class="keyword">new</span> EntryOptionPlugin().apply(compiler);</span><br><span class="line">        <span class="comment">//触发 entryOption 事件执行</span></span><br><span class="line">        compiler.hooks.entryOption.call(options.context, options.entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>EntryOptionPlugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryOptionPlugin</span> </span>&#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.entryOption.tap(<span class="string">"EntryOptionPlugin"</span>, (context, entry) =&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> SingleEntryPlugin(context, entry, <span class="string">"main"</span>).apply(compiler);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是单入口，<code>EntryOptionPlugin</code> 插件中会监听 <code>SingleEntryPlugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EntryOptionPlugin</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context, entry, name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.entry = entry;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.make.tapAsync(</span><br><span class="line">            <span class="string">"SingleEntryPlugin"</span>,</span><br><span class="line">            (compilation, callback) =&gt; &#123;</span><br><span class="line">                <span class="comment">//入口文件 代码块的名称 context上下文绝对路径</span></span><br><span class="line">                <span class="keyword">const</span> &#123; entry, name, context &#125; = <span class="keyword">this</span>;</span><br><span class="line">                compilation.addEntry(context, entry, name, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleEntryPlugin</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 订阅 make 事件</span></span><br><span class="line"> <span class="keyword">constructor</span>(context, entry, options) &#123;</span><br><span class="line">   <span class="keyword">this</span>.context = context; <span class="comment">// 上下文绝对路径</span></span><br><span class="line">   <span class="keyword">this</span>.entry = entry;<span class="comment">// 入口模块路径</span></span><br><span class="line">   <span class="keyword">this</span>.name = name;<span class="comment">// 入口名字</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为便于拓展，v5中的实现方式[const dep = EntryPlugin.createDependency(entry, options);](https://github.com/webpack/webpack/blob/47ef990fc93208eaaed59654ade4450465e29517/lib/EntryPlugin.js#L47)</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 异步监听 tapAsync</span></span><br><span class="line">   compiler.hooks.make.tapAsync(<span class="string">"SingleEntryPlugin"</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123; entry, name, context &#125; = <span class="keyword">this</span>;</span><br><span class="line">   <span class="comment">// 从此入口开始编译，编译入口文件和他的依赖</span></span><br><span class="line">  <span class="comment">//  开始编译一个新的入口 context 根目录 entry 入口文件的相对路径 name 名字</span></span><br><span class="line">   compilation.addEntry(context, entry, name, callback);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在webpack 5 中 EntryPlugin 代替了 SingleEntryPlugin(内部直接 require(‘EntryPlugin’))</p></blockquote><p>4、编译开始，先后经历 beforeRun，run，beforeCompile，compile</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> <span class="keyword">extends</span> <span class="title">Tapable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(context) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.options = &#123;&#125;;</span><br><span class="line">        <span class="keyword">this</span>.context = context; <span class="comment">//设置上下文路径</span></span><br><span class="line">        <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">            entryOption: <span class="keyword">new</span> SyncBailHook([<span class="string">"context"</span>, <span class="string">"entry"</span>]),</span><br><span class="line">            beforeRun: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">            run: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compiler"</span>]),</span><br><span class="line">            beforeCompile: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"params"</span>]),</span><br><span class="line">            compile: <span class="keyword">new</span> SyncHook([<span class="string">"params"</span>]),</span><br><span class="line">            make: <span class="keyword">new</span> AsyncParallelHook([<span class="string">"compilation"</span>]),</span><br><span class="line">            thisCompilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]), <span class="comment">// 开始一次新的编译</span></span><br><span class="line">           </span><br><span class="line">            compilation: <span class="keyword">new</span> SyncHook([<span class="string">"compilation"</span>, <span class="string">"params"</span>]),<span class="comment">// 创建完成一个新的 compilation</span></span><br><span class="line">            done: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"stats"</span>]) <span class="comment">// 编译完成</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    run(finalCallback) &#123;</span><br><span class="line">        <span class="comment">//编译完成后的回调</span></span><br><span class="line">        <span class="keyword">const</span> onCompiled = <span class="function">(<span class="params">err, compilation</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'onCompiled'</span>);</span><br><span class="line">            finalCallback(err, <span class="keyword">new</span> Stats(compilation));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//准备运行编译</span></span><br><span class="line">        <span class="keyword">this</span>.hooks.beforeRun.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">            <span class="comment">//运行</span></span><br><span class="line">            <span class="keyword">this</span>.hooks.run.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.compile(onCompiled); <span class="comment">//开始编译,编译完成后执行conCompiled回调</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    compile(onCompiled) &#123;</span><br><span class="line">        <span class="keyword">const</span> params = <span class="keyword">this</span>.newCompilationParams();</span><br><span class="line">        <span class="keyword">this</span>.hooks.beforeCompile.callAsync(params, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.hooks.compile.call(params);</span><br><span class="line">            <span class="keyword">const</span> compilation = <span class="keyword">this</span>.newCompilation(params);</span><br><span class="line">            <span class="keyword">this</span>.hooks.make.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'make完成'</span>);</span><br><span class="line">                onCompiled(err, compilation);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    newCompilationParams() &#123;</span><br><span class="line">        <span class="keyword">const</span> params = &#123;</span><br><span class="line">            normalModuleFactory: <span class="keyword">new</span> NormalModuleFactory()</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    newCompilation(params) &#123;</span><br><span class="line">        <span class="keyword">const</span> compilation = <span class="keyword">new</span> Compilation(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.hooks.thisCompilation.call(compilation, params);</span><br><span class="line">        <span class="keyword">this</span>.hooks.compilation.call(compilation, params);</span><br><span class="line">        <span class="keyword">return</span> compilation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、声明一个 <code>Compilation</code> 类，主要是执行编译工作。通过 <code>NormalModuleFactory</code> 新增 <code>NormalModule</code> 编译模块和依赖，然后转换成 AST 语法树，放入 ast 对象中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compilation</span> <span class="keyword">extends</span> <span class="title">Tapable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(compiler) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.compiler = compiler;</span><br><span class="line">        <span class="keyword">this</span>.options = compiler.options;</span><br><span class="line">        <span class="keyword">this</span>.context = compiler.context;</span><br><span class="line">        <span class="keyword">this</span>.inputFileSystem = compiler.inputFileSystem;</span><br><span class="line">        <span class="keyword">this</span>.outputFileSystem = compiler.outputFileSystem;</span><br><span class="line">        <span class="keyword">this</span>.entries = [];</span><br><span class="line">        <span class="keyword">this</span>.modules = [];</span><br><span class="line">        <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">            succeedModule: <span class="keyword">new</span> SyncHook([<span class="string">"module"</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//context ./src/index.js main callback(终级回调)</span></span><br><span class="line">    _addModuleChain(context,entry,name,callback)&#123;</span><br><span class="line">       <span class="keyword">this</span>.createModule(&#123;</span><br><span class="line">            name,<span class="comment">//所属的代码块的名称 main</span></span><br><span class="line">            context:<span class="keyword">this</span>.context,<span class="comment">//上下文</span></span><br><span class="line">            rawRequest:entry,<span class="comment">// ./src/index.js</span></span><br><span class="line">            resource:path.posix.join(context,entry),<span class="comment">//此模块entry的的绝对路径</span></span><br><span class="line">            parser,</span><br><span class="line">        &#125;,<span class="built_in">module</span>=&gt;&#123;<span class="keyword">this</span>.entries.push(<span class="built_in">module</span>)&#125;,callback);</span><br><span class="line">    &#125;</span><br><span class="line">    createModule(data,addEntry,callback)&#123;</span><br><span class="line">        <span class="comment">//先创建模块工厂</span></span><br><span class="line">        <span class="keyword">const</span> moduleFactory = <span class="keyword">new</span> NormalModuleFactory();</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">module</span> = moduleFactory.create(data);</span><br><span class="line">        <span class="comment">//非常非常重要 模块的ID如何生成? 模块的ID是一个相对于根目录的相对路径</span></span><br><span class="line">        <span class="comment">//index.js ./src/index.js title.js ./src/title.js</span></span><br><span class="line">        <span class="comment">//relative返回一个相对路径 从根目录出出到模块的绝地路径 得到一个相对路径</span></span><br><span class="line">        <span class="built_in">module</span>.moduleId = <span class="string">'.'</span>+path.posix.sep+path.posix.relative(<span class="keyword">this</span>.context,<span class="built_in">module</span>.resource);</span><br><span class="line">        addEntry&amp;&amp;addEntry(<span class="built_in">module</span>);</span><br><span class="line">        <span class="keyword">this</span>.modules.push(<span class="built_in">module</span>);<span class="comment">//把模块添加到完整的模块数组中</span></span><br><span class="line">        <span class="keyword">const</span> afterBuild = <span class="function">(<span class="params">err,<span class="built_in">module</span></span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">module</span>.dependencies)&#123;<span class="comment">//如果一个模块编译完成,发现它有依赖的模块,那么递归编译它的依赖模块</span></span><br><span class="line">                <span class="keyword">this</span>.processModuleDependencies(<span class="built_in">module</span>,(err)=&gt;&#123;</span><br><span class="line">                    <span class="comment">//当这个入口模块和它依赖的模块都编译完成了,才会让调用入口模块的回调</span></span><br><span class="line">                    callback(err,<span class="built_in">module</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                callback(err,<span class="built_in">module</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.buildModule(<span class="built_in">module</span>,afterBuild);</span><br><span class="line">    &#125;</span><br><span class="line">    processModuleDependencies(<span class="built_in">module</span>,callback)&#123;</span><br><span class="line">        <span class="keyword">let</span> dependencies= <span class="built_in">module</span>.dependencies;</span><br><span class="line">        <span class="comment">//因为我希望可以并行的同时开始编译依赖的模块,然后等所有依赖的模块全部编译完成后才结束</span></span><br><span class="line">        <span class="keyword">async</span>.forEach(dependencies,(dependency,done)=&gt;&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;name,context,rawRequest,resource,moduleId&#125; = dependency;</span><br><span class="line">            <span class="keyword">this</span>.createModule(&#123;</span><br><span class="line">                name,</span><br><span class="line">                context,</span><br><span class="line">                rawRequest,</span><br><span class="line">                resource,</span><br><span class="line">                moduleId,</span><br><span class="line">                parser</span><br><span class="line">            &#125;,<span class="literal">null</span>,done);</span><br><span class="line">        &#125;,callback);</span><br><span class="line">    &#125;</span><br><span class="line">    buildModule(<span class="built_in">module</span>,afterBuild)&#123;</span><br><span class="line">        <span class="built_in">module</span>.build(<span class="keyword">this</span>,(err)=&gt;&#123;</span><br><span class="line">            <span class="keyword">this</span>.hooks.succeedModule.call(<span class="built_in">module</span>)</span><br><span class="line">            afterBuild(<span class="literal">null</span>,<span class="built_in">module</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NormalModule</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalModule</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(&#123; name, context, rawRequest, resource, parser, moduleId &#125;) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.rawRequest = rawRequest;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">        <span class="keyword">this</span>.moduleId = moduleId||(<span class="string">'./'</span>+path.posix.relative(context,resource));</span><br><span class="line">        <span class="keyword">this</span>.parser = parser;</span><br><span class="line">        <span class="keyword">this</span>._source = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>._ast = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.dependencies = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解析依赖</span></span><br><span class="line">    build(compilation, callback) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doBuild(compilation, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> originalSource = <span class="keyword">this</span>.getSource(<span class="keyword">this</span>.resource, compilation);</span><br><span class="line">            <span class="comment">// 将 当前模块 的内容转换成 AST</span></span><br><span class="line">            <span class="keyword">const</span> ast = <span class="keyword">this</span>.parser.parse(originalSource);</span><br><span class="line">            traverse(ast, &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点是一个函数调用时</span></span><br><span class="line">                CallExpression: <span class="function">(<span class="params">nodePath</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> node = nodePath.node;</span><br><span class="line">                    <span class="comment">// 当前节点是 require 时</span></span><br><span class="line">                    <span class="keyword">if</span> (node.callee.name === <span class="string">'require'</span>) &#123;</span><br><span class="line">                        <span class="comment">//修改require为__webpack_require__</span></span><br><span class="line">                        node.callee.name = <span class="string">'__webpack_require__'</span>;</span><br><span class="line">                        <span class="comment">//获取要加载的模块ID</span></span><br><span class="line">                        <span class="keyword">let</span> moduleName = node.arguments[<span class="number">0</span>].value;</span><br><span class="line">                        <span class="comment">//获取扩展名</span></span><br><span class="line">                        <span class="keyword">let</span> extension = moduleName.split(path.posix.sep).pop().indexOf(<span class="string">'.'</span>) == <span class="number">-1</span> ? <span class="string">'.js'</span> : <span class="string">''</span>;</span><br><span class="line">                        <span class="comment">//获取依赖模块的绝对路径</span></span><br><span class="line">                        <span class="keyword">let</span> dependencyResource = path.posix.join(path.posix.dirname(<span class="keyword">this</span>.resource), moduleName + extension);</span><br><span class="line">                        <span class="comment">//获取依赖模块的模块ID</span></span><br><span class="line">                        <span class="keyword">let</span> dependencyModuleId = <span class="string">'.'</span> + path.posix.sep + path.posix.relative(<span class="keyword">this</span>.context, dependencyResource);</span><br><span class="line">                        <span class="comment">//添加依赖</span></span><br><span class="line">                        <span class="keyword">this</span>.dependencies.push(&#123;</span><br><span class="line">                            name: <span class="keyword">this</span>.name, <span class="attr">context</span>: <span class="keyword">this</span>.context, <span class="attr">rawRequest</span>: moduleName,</span><br><span class="line">                            moduleId: dependencyModuleId, <span class="attr">resource</span>: dependencyResource</span><br><span class="line">                        &#125;);</span><br><span class="line">                        node.arguments = [types.stringLiteral(dependencyModuleId)];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">let</span> &#123; code &#125; = generate(ast);</span><br><span class="line">            <span class="keyword">this</span>._source = code;</span><br><span class="line">            <span class="keyword">this</span>._ast = ast;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取模块的源代码</span></span><br><span class="line">    doBuild(compilation, callback) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getSource(compilation, (err, source)=&gt;&#123;</span><br><span class="line">        <span class="comment">// 把最原始的代码存放在当前模块的_source属性上 </span></span><br><span class="line">        <span class="comment">// TODO 我们的loader处理在这里</span></span><br><span class="line">        <span class="keyword">this</span>._source = source;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取真正的源代码 </span></span><br><span class="line">    getSource(compilation, callback)&#123;</span><br><span class="line">      compilation.inputFileSystem.readFile(<span class="keyword">this</span>.resource, <span class="string">'utf8'</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编译模块思路：1、从硬盘上把模块内容读出来，读成一个文本 2、可能不是一个JS模块，所以可能会要走loader的转换，最终肯定要得到一个JS模块代码，得不到就报错 3、把这个JS模块代码经过parser处理转成抽象语法树AST 4、分析AST里面的依赖，也就是找 require import 节点，分析依赖的模块 5、递归的编译依赖的模块 6、不停的一次递归执行上面 5 步，直到所有模块都编译完成为止</p></blockquote><p>6、处理编译后的文件，合并 module, chunk</p><p>在 <code>Compiler</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">+  afterCompile:<span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line">&#125;</span><br><span class="line">compile(onCompiled) &#123;</span><br><span class="line">    <span class="keyword">const</span> params = <span class="keyword">this</span>.newCompilationParams();</span><br><span class="line">    <span class="keyword">this</span>.hooks.beforeCompile.callAsync(params, err =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.hooks.compile.call(params);</span><br><span class="line">        <span class="keyword">const</span> compilation = <span class="keyword">this</span>.newCompilation(params);</span><br><span class="line">        <span class="keyword">this</span>.hooks.make.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">+              compilation.seal(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">+                   <span class="keyword">this</span>.hooks.afterCompile.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">+                      <span class="keyword">return</span> onCompiled(<span class="literal">null</span>, compilation);</span><br><span class="line">+                  &#125;);</span><br><span class="line">+              &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Compilation</code> 中，使用 seal 的 hooks 组装 module，称为 chunk</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">添加 hooks</span><br><span class="line">    <span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">        succeedModule: <span class="keyword">new</span> SyncHook([<span class="string">"module"</span>]),</span><br><span class="line">+       seal: <span class="keyword">new</span> SyncHook([]),</span><br><span class="line">+       beforeChunks: <span class="keyword">new</span> SyncHook([]),</span><br><span class="line">+       afterChunks: <span class="keyword">new</span> SyncHook([<span class="string">"chunks"</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+    seal(callback) &#123;</span><br><span class="line">+        <span class="keyword">this</span>.hooks.seal.call();</span><br><span class="line">+        <span class="keyword">this</span>.hooks.beforeChunks.call();<span class="comment">//生成代码块之前</span></span><br><span class="line">+        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">module</span> <span class="keyword">of</span> <span class="keyword">this</span>.entries) &#123;<span class="comment">//循环入口模块</span></span><br><span class="line">+            <span class="keyword">const</span> chunk = <span class="keyword">new</span> Chunk(<span class="built_in">module</span>);<span class="comment">//创建代码块</span></span><br><span class="line">+            <span class="keyword">this</span>.chunks.push(chunk);<span class="comment">//把代码块添加到代码块数组中</span></span><br><span class="line">+            <span class="comment">//把代码块的模块添加到代码块中</span></span><br><span class="line">+            chunk.modules = <span class="keyword">this</span>.modules.filter(<span class="function"><span class="params">module</span> =&gt;</span> <span class="built_in">module</span>.name == chunk.name);</span><br><span class="line">+        &#125;</span><br><span class="line">+        <span class="keyword">this</span>.hooks.afterChunks.call(<span class="keyword">this</span>.chunks);<span class="comment">//生成代码块之后</span></span><br><span class="line">+        callback();<span class="comment">//封装结束</span></span><br><span class="line">+    &#125;</span><br></pre></td></tr></table></figure><p>7、然后把每个 <code>Chunk</code> 转换成一个单独的文件加入到输出列表 assets:{} 里面</p><p><code>Compilation</code> 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+    createChunkAssets() &#123;</span><br><span class="line">+        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.chunks.length; i++) &#123;</span><br><span class="line">+            <span class="keyword">const</span> chunk = <span class="keyword">this</span>.chunks[i];</span><br><span class="line">+            chunk.files = [];</span><br><span class="line">+            <span class="keyword">const</span> file = chunk.name + <span class="string">'.js'</span>;</span><br><span class="line">+            <span class="keyword">const</span> source = mainRender(&#123; <span class="attr">entryId</span>: chunk.entryModule.moduleId, <span class="attr">modules</span>: chunk.modules &#125;);</span><br><span class="line">+            chunk.files.push(file);</span><br><span class="line">+            <span class="keyword">this</span>.emitAsset(file, source);</span><br><span class="line">+        &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+    emitAsset(file, source) &#123;</span><br><span class="line">+        <span class="keyword">this</span>.assets[file] = source;</span><br><span class="line">+        <span class="keyword">this</span>.files.push(file);</span><br><span class="line">+    &#125;</span><br></pre></td></tr></table></figure><p>在 <code>Compiler</code> 中，确定好输出的内容之后，根据配置确定输出的路径和文件名，把文件内容写入文件系统</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.hooks = &#123;</span><br><span class="line">+  emit: <span class="keyword">new</span> AsyncSeriesHook([<span class="string">"compilation"</span>]),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+    emitAssets(compilation, callback) &#123;</span><br><span class="line">+        <span class="keyword">const</span> emitFiles = <span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">+              <span class="keyword">const</span> assets = compilation.assets;</span><br><span class="line">+              <span class="keyword">let</span> outputPath = <span class="keyword">this</span>.options.output.path;<span class="comment">//dist</span></span><br><span class="line">+              <span class="keyword">for</span>(<span class="keyword">let</span> file <span class="keyword">in</span> assets)&#123;</span><br><span class="line">+                <span class="keyword">let</span> source = assets[file];<span class="comment">//得到文件名和文件内容 </span></span><br><span class="line">+                <span class="keyword">let</span> targetPath = path.posix.join(outputPath,file);<span class="comment">//得到输出的路径 targetPath</span></span><br><span class="line">+                <span class="keyword">this</span>.outputFileSystem.writeFileSync(targetPath,source,<span class="string">'utf8'</span>);<span class="comment">//NodeEnvironmentPlugin</span></span><br><span class="line">+              &#125;</span><br><span class="line">+            callback();</span><br><span class="line">+        &#125;</span><br><span class="line">+        <span class="keyword">this</span>.hooks.emit.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">+            mkdirp(<span class="keyword">this</span>.options.output.path, emitFiles);</span><br><span class="line">+        &#125;);</span><br><span class="line">+    &#125;</span><br><span class="line"></span><br><span class="line">    run(finalCallback) &#123;</span><br><span class="line">        <span class="comment">//编译完成后的回调</span></span><br><span class="line">        <span class="keyword">const</span> onCompiled = <span class="function">(<span class="params">err, compilation</span>) =&gt;</span> &#123;</span><br><span class="line">+            <span class="keyword">this</span>.emitAssets(compilation,err=&gt;&#123;</span><br><span class="line">+                 <span class="keyword">let</span> stats = <span class="keyword">new</span> Stats(compilation);<span class="comment">//stats是一 个用来描述打包后结果的对象</span></span><br><span class="line">+                  <span class="keyword">this</span>.hooks.done.callAsync(stats,err=&gt;&#123;<span class="comment">//done表示整个流程结束了</span></span><br><span class="line">+                  callback(err,stats);</span><br><span class="line">+                  &#125;);</span><br><span class="line">+            &#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//准备运行编译</span></span><br><span class="line">        <span class="keyword">this</span>.hooks.beforeRun.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">            <span class="comment">//运行</span></span><br><span class="line">            <span class="keyword">this</span>.hooks.run.callAsync(<span class="keyword">this</span>, err =&gt; &#123;</span><br><span class="line">                <span class="keyword">this</span>.compile(onCompiled); <span class="comment">//开始编译,编译完成后执行conCompiled回调</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>plugin 是 贯穿整个生命周期的。<br>plugin 分为注册和触发的两个环节，<br>刚开始就全部注册了，但这个时候插件函数没有触发执行，而是在执行编译的过程中，逐渐执行。<br>loader 只是中间的一个环节</p><p>非常重要的问题<br>模块ID的问题<br>不管你是相对本地的模块，还是三方模块<br>最后它的 moduleId 全部都一个相对于项目的根目录打的路径</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Webpack 源码系列之」调试</title>
      <link href="/2020/10/09/Webpack%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95/"/>
      <url>/2020/10/09/Webpack%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<blockquote><p>学习一个工具或者库的源码之前，需要对一个库有一个基本的认识，比如源码的结构，还有如何调试，属于一个前提条件。而 webpack 是我即 react 之后，希望通读的一个工具库，其实在团队中，自己需要去完成一些技术的指标，而相应的技术储备是必不可少的。就前端工程化而言，webpack 是避不开的一条路。所以在阅读源码的同时，希望能收获更广阔的技术视野，以及之后遇到这个东西的时候，知道其原理。</p></blockquote><a id="more"></a><h2 id="阅读-webpack-源码系列">阅读 Webpack 源码系列</h2><p>本系列基于 <code>webpack-4</code> 分支，版本 <code>4.44.2</code> 进行阅读</p><ul><li><p>「Webpack 源码系列之」调试</p></li><li><p>「Webpack 源码系列之」工作流</p></li><li><p>「Webpack 源码系列之」HMR</p></li><li><p>「Webpack 源码系列之」TreeShaking</p></li></ul><p>正在更新中 …</p><h2 id="为什么选择-webpack4-阅读">为什么选择 webpack4 阅读</h2><p>1、在阅读过程中，webpack5 （2020年 10 月 10日）其实出来没多久，对于一些新特性，项目中也会很少用到。我们可以了解完 4 的东西之后，咋去对比了解 5 的特性。更加有助于我们掌握。</p><p>2、对于阅读源码，借鉴资料是必不可少的，网上很多 webpack 4 版本的资料，相对于 webpack5 来说，如果版本不一致，容易走弯路。</p><h2 id="如何调试">如何调试</h2><p>对于一个庞大的开源工程，逐一看代码是不现实的，我们需要清楚的无非是主流程，以及这个流程完成之后，输出一些变量值来判断这个流程是干什么的。这种无可避免的需要用到调试工具。</p><h2 id="vscode-调试">VsCode 调试</h2><p>随着 <code>vscode</code> 逐渐完善 <code>debugger</code> 模块，目前用 <code>vscode</code> 来调试 <code>node</code> 程序已经是一件比较容易的事情了</p><p>创建 <code>launch.json</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="string">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">      <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="string">"name"</span>: <span class="string">"启动程序"</span>,</span><br><span class="line">      <span class="string">"cwd"</span>:<span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">      <span class="string">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/webpack/debugger.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地的 <code>webpack.config</code> 配置文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path  = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context:process.cwd(),<span class="comment">//当前的工作目录</span></span><br><span class="line">    mode:<span class="string">'development'</span>,</span><br><span class="line">    devtool:<span class="literal">false</span>,</span><br><span class="line">    entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'main.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增调试文件 <code>debugger.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 引入核心模块</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">"webpack"</span>);</span><br><span class="line"><span class="comment">//2. 加载配置文件</span></span><br><span class="line"><span class="keyword">const</span> webpackOptions = <span class="built_in">require</span>(<span class="string">"./webpack.config"</span>);  </span><br><span class="line"><span class="comment">//3. 执行 webpack 得到编译对象 compiler ，它是核心的编译对象</span></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(webpackOptions);</span><br><span class="line"><span class="keyword">debugger</span></span><br><span class="line">compiler.run(<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 编译完成之后执行回调</span></span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="comment">// stats 是编译结果的描述对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(stats.toJson(&#123; <span class="comment">// webpack 都是数组  webpack 5 都是 set</span></span><br><span class="line">      entries: <span class="literal">true</span>,<span class="comment">// 入口 entryPoints </span></span><br><span class="line">      chunks: <span class="literal">false</span>,<span class="comment">// 代码块 [main]</span></span><br><span class="line">      modules: <span class="literal">false</span>,<span class="comment">// 模块 ['./src/index.js','./src/title.js']</span></span><br><span class="line">      assets: <span class="literal">false</span>,<span class="comment">// 本次产出的资源 [main.js]</span></span><br><span class="line">    &#125;), <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动调试按钮，进入调试界面。</p><p>调试界面：</p><p><img src="http://qiniu.xueshiming.cn/vscode%E8%B0%83%E8%AF%95.png" alt="VsCode调试"></p><h2 id="chrome-devtools-调试">Chrome DevTools 调试</h2><p>我们也可以用 Chrome 来调试代码</p><p><code>node --inspect index.js</code></p><p>然后打开 <code>chrome://inspect</code></p><p>点击 <code>Open dedicated DevTools for Node</code></p><p>调试界面：</p><p><img src="http://qiniu.xueshiming.cn/DevTools%E8%B0%83%E8%AF%95.png" alt="DevTools调试"></p><h2 id="总结">总结</h2><p>关于调试：调试技巧在平常的工作中也是可以用到的，由于前端会偏向于交互的特性，所以 <code>console.log</code> 这些我会很常用，但是向<code>debug</code> 这些，当接触 <code>node</code> 之后，会发现比 <code>console.log</code> 实用太多了。所以，这边文章中的调试方式，可适用于大部分场景。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器渲染基本原理解析</title>
      <link href="/2020/01/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/01/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<blockquote><p>大多数设备的刷新频率是60Hz，也就说是浏览器对每一帧画面的渲染工作要在16ms内完成,超出这个时间，页面的渲染就会出现卡顿现象，影响用户体验。前端的用户体验给了前端直观的印象，因此对B/S架构的开发人员来说，熟悉浏览器的内部执行原理显得尤为重要。</p></blockquote><a id="more"></a><h2 id="1-浏览器主要组成与浏览器线程">1. 浏览器主要组成与浏览器线程</h2><h3 id="1-1-浏览器组件">1.1 浏览器组件</h3><p>浏览器大体上由以下几个组件组成，各个浏览器可能有一点不同。</p><p><img src="http://qiniu.xueshiming.cn/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E4%BB%B6.png" alt="浏览器组件"></p><ul><li><strong>界面控件</strong> – 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分</li><li><strong>浏览器引擎</strong> – 查询与操作渲染引擎的接口</li><li><strong>渲染引擎</strong> – 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML、CSS并将结果显示到窗口中</li><li><strong>网络</strong> – 用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现</li><li><strong>UI后端</strong> – 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现</li><li><strong>JS解释器</strong> - 用于解析执行JavaScript代码</li><li><strong>数据存储持久层</strong> - 浏览器需要把所有数据存到硬盘上，如cookies。新的HTML5规范规定了一个完整（虽然轻量级）的浏览器中的数据库 <code>web database</code></li></ul><blockquote><p>注意：chrome浏览器与其他浏览器不同，chrome使用多个渲染引擎实例，每个Tab页一个，即每个Tab都是一个独立进程。</p></blockquote><h3 id="1-2-浏览器中的进程与线程">1.2 浏览器中的进程与线程</h3><p>Chrome浏览器使用多个进程来隔离不同的网页，在Chrome中打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎实例。因为如果非多进程的话，如果浏览器中的一个tab网页崩溃，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的，所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源，所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。</p><p>在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：</p><h4 id="1-gui-渲染线程">1. GUI 渲染线程</h4><p>GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的，也就是说被冻结了。</p><h4 id="2-javascript引擎线程">2. JavaScript引擎线程</h4><p>JS为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。</p><p>GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h4 id="3-定时触发器线程">3. 定时触发器线程</h4><p>浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p><h4 id="4-事件触发线程">4. 事件触发线程</h4><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。</p><h4 id="5-异步http请求线程">5. 异步http请求线程</h4><p>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。</p><h2 id="2-渲染过程">2. 渲染过程</h2><h3 id="2-1-渲染流程">2.1 渲染流程</h3><p>用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中基础的渲染流程图：</p><p><img src="http://qiniu.xueshiming.cn/%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png" alt="浏览器渲染流程"></p><p>webkit引擎渲染的详细流程，其他引擎渲染流程稍有不同：</p><p><img src="http://qiniu.xueshiming.cn/webkit%E5%BC%95%E6%93%8E%E6%B8%B2%E6%9F%93.png" alt="webkit引擎渲染"></p><p>渲染流程有四个主要步骤：</p><ul><li><strong>解析HTML生成DOM树</strong> - 渲染引擎首先解析 HTML 文档，生成 DOM 树</li><li><strong>构建Render树</strong> - 接下来不管是内联式，外联式还是嵌入式引入的 CSS 样式会被解析生成 CSSOM 树，根据 DOM 树与 CSSOM 树生成另外一棵用于渲染的树-渲染树(Render tree)</li><li><strong>布局Render树</strong> - 然后对渲染树的每个节点进行布局处理，确定其在屏幕上的显示位置</li><li><strong>绘制Render树</strong> - 最后遍历渲染树并用 UI 后端层将每一个节点绘制出来</li></ul><p>以上步骤是一个渐进的过程，为了提高用户体验，渲染引擎试图尽可能快的把结果显示给最终用户。它不会等到所有HTML都被解析完才创建并布局渲染树。它会在从网络层获取文档内容的同时把已经接收到的局部内容先展示出来。</p><h3 id="2-2-渲染细节">2.2 渲染细节</h3><h4 id="1-生成dom树">1. 生成DOM树</h4><p>DOM树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。DOM树的根节点就是document对象。</p><p>DOM树的生成过程中可能会被CSS和JS的加载执行阻塞，具体可以参见下一章。当HTML文档解析过程完毕后，浏览器继续进行标记为deferred模式的脚本加载，然后就是整个解析过程的实际结束触发DOMContentLoaded事件，并在async文档文档执行完之后触发load事件。</p><h4 id="2-生成render树">2. 生成Render树</h4><p>生成DOM树的同时会生成样式结构体CSSOM（CSS Object Model）Tree，再根据CSSOM和DOM树构造渲染树Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。从MVC的角度来说，可以将Render树看成是V，DOM树与CSSOM树看成是M，C则是具体的调度者，比HTMLDocumentParser等。</p><p>可以这么说，没有DOM树就没有Render树，但是它们之间不是简单的一对一的关系。Render树是用于显示，那不可见的元素当然不会在这棵树中出现了，譬如 <code>&lt;head&gt;</code>。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。</p><h4 id="3-dom树与render树">3. DOM树与Render树</h4><p>DOM对象类型很丰富，什么head、title、div，而Render树相对来说就比较单一了，毕竟它的职责就是为了以后的显示渲染用嘛。Render树的每一个节点我们叫它渲染器renderer。</p><p>一棵Render树大概是酱紫，左边是DOM树，右边是Render树：</p><p><img src="http://qiniu.xueshiming.cn/render%E6%A0%91.png" alt="Render树"></p><p>从上图我们可以看出，renderer与DOM元素是相对应的，但并不是一一对应，有些DOM元素没有对应的renderer，而有些DOM元素却对应了好几个renderer，对应多个renderer的情况是普遍存在的，就是为了解决一个renderer描述不清楚如何显示出来的问题，譬如有下拉列表的select元素，我们就需要三个renderer：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。</p><p>另外，renderer与DOM元素的位置也可能是不一样的。那些添加了 <code>float</code> 或者 <code>position:absolute</code> 的元素，因为它们脱离了正常的文档流，构造Render树的时候会针对它们实际的位置进行构造。</p><h4 id="4-布局与绘制">4. 布局与绘制</h4><p>上面确定了renderer的样式规则后，然后就是重要的显示元素布局了。当renderer构造出来并添加到Render树上之后，它并没有位置跟大小信息，为它确定这些信息的过程，接下来是 <strong>布局</strong> (layout)。</p><p>浏览器进行页面布局基本过程是以浏览器可见区域为画布，左上角为 (0,0)基础坐标，从左到右，从上到下从DOM的根节点开始画，首先确定显示元素的大小跟位置，此过程是通过浏览器计算出来的，用户CSS中定义的量未必就是浏览器实际采用的量。如果显示元素有子元素得先去确定子元素的显示信息。</p><p>布局阶段输出的结果称为box盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都转化为了绝对单位。</p><p>在 <strong>绘制</strong>(painting)阶段，渲染引擎会遍历Render树，并调用renderer的 paint() 方法，将renderer的内容显示在屏幕上。绘制工作是使用UI后端组件完成的。</p><h4 id="5-回流与重绘">5. 回流与重绘</h4><p><strong>回流</strong>(reflow)：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染。reflow 会从 <html>这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</html></p><p><strong>重绘</strong>(repaint)：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。</p><p>每次Reflow，Repaint后浏览器还需要合并渲染层并输出到屏幕上。所有的这些都会是动画卡顿的原因。Reflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。可以在csstrigger上查找某个css属性会触发什么事件。</p><p><strong>reflow与repaint的时机：</strong></p><ul><li><code>display:none</code> 会触发 <code>reflow</code>，而 <code>visibility:hidden</code> 只会触发 <code>repaint</code>，因为没有发生位置变化。</li><li>有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。</li><li>有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</li></ul><h2 id="3-关键渲染路径与阻塞渲染">3. 关键渲染路径与阻塞渲染</h2><p>在浏览器拿到HTML、CSS、JS等外部资源到渲染出页面的过程，有一个重要的概念<strong>关键渲染路径</strong>（Critical Rendering Path）。例如为了保障首屏内容的最快速显示，通常会提到一个渐进式页面渲染，但是为了渐进式页面渲染，就需要做资源的拆分，那么以什么粒度拆分、要不要拆分，不同页面、不同场景策略不同。具体方案的确定既要考虑体验问题，也要考虑工程问题。了解原理可以让我们更好的优化关键渲染路径，从而获得更好的用户体验。</p><p>现代浏览器总是并行加载资源，例如，当 HTML 解析器（HTML Parser）被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。</p><p>同时，由于下面两点：</p><ul><li><p>CSS 被视为渲染 阻塞资源 (包括JS) ，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕，才会进行下一阶段。</p></li><li><p>JavaScript 被认为是解释器阻塞资源，HTML解析会被JS阻塞，它不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。</p></li></ul><p>存在阻塞的 CSS 资源时，浏览器会延迟 JavaScript 的执行和 DOM 构建。另外：</p><ul><li><p>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</p></li><li><p>JavaScript 可以查询和修改 DOM 与 CSSOM。</p></li><li><p>CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。</p></li></ul><p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p><ul><li><p>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</p></li><li><p>JavaScript 应尽量少影响 DOM 的构建。</p></li></ul><p>下面来看看 CSS 与 JavaScript 是具体如何阻塞资源的。</p><h3 id="3-1-css">3.1 CSS</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    p &#123;</span></span><br><span class="line"><span class="undefined">        color: red;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"index.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的 link 标签（无论是否 inline）会被视为阻塞渲染的资源，浏览器会优先处理这些 CSS 资源，直至 CSSOM 构建完毕。</p><p>渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。</p><p>最容易想到的当然是精简 CSS 并尽快提供它。除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"index.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"print.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"other.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(min-width: 30em) and (orientation: landscape)"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一个资源会加载并阻塞。第二个资源设置了媒体类型，会加载但不会阻塞，print 声明只在打印网页时使用。第三个资源提供了媒体查询，会在符合条件时阻塞渲染。</p><p>关于CSS加载的阻塞情况：</p><ul><li><p>css加载不会阻塞DOM树的解析</p></li><li><p>css加载会阻塞DOM树的渲染</p></li><li><p>css加载会阻塞后面js语句的执行</p></li></ul><p>没有js的理想情况下，html与css会并行解析，分别生成DOM与CSSOM，然后合并成Render Tree，进入Rendering Pipeline；但如果有js，css加载会阻塞后面js语句的执行，而（同步）js脚本执行会阻塞其后的DOM解析（所以通常会把css放在头部，js放在body尾）</p><h3 id="3-2-javascript">3.2 JavaScript</h3><p>JavaScript 的情况比 CSS 要更复杂一些。如果没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行。观察下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> Do not go gentle into that good night,<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"inline1"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage,rage against the dying of the light.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Old age should burn and rave at close of day;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"inline2"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Rage,rage against the dying of the light.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 script 标签会阻塞 HTML 解析，无论是不是 inline-script。上面的 P 标签会从上到下解析，这个过程会被两段 JavaScript 分别打断一次（加载、执行）。</p><p>解析过程中无论遇到的JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒 <code>JavaScript</code> 解析器，就会进行暂停 (blocked )浏览器解析HTML，并等到 CSSOM 构建完毕，才去执行js脚本。因为脚本中可能会操作DOM元素，而如果在加载执行脚本的时候DOM元素并没有被解析，脚本就会因为DOM元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。</p><h3 id="3-3-改变脚本加载次序defer与async">3.3 改变脚本加载次序defer与async</h3><p><code>defer</code> 与 <code>async</code> 可以改变之前的那些阻塞情形，这两个属性都会使 script 异步加载，然而执行的时机是不一样的。注意 async 与 defer 属性对于 inline-script 都是无效的，所以下面这个示例中三个 script 标签的代码会从上到下依次执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"1"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"2"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">console</span>.log(<span class="string">"3"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面脚本会按需输出 1 2 3，故，下面两节讨论的内容都是针对设置了 src 属性的 script 标签。</p><p>先放个熟悉的图~</p><p><img src="http://qiniu.xueshiming.cn/%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90%E6%A1%88%E4%BE%8B.png" alt="代码解析案例"></p><p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p><h4 id="defer">defer</h4><p>defer 属性表示延迟执行引入 JavaScript，即 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，再触发 DOMContentLoaded(初始的 HTML 文档被完全加载和解析完成之后触发，无需等待样式表图像和子框架的完成加载) 事件 。</p><p>defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 的解析，执行阶段被放到 HTML 标签解析完成之后。</p><h4 id="async">async</h4><p>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发(HTML解析完成事件)之后。需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件。换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行。</p><p>从上一段也能推出，多个 async-script 的执行顺序是不确定的，谁先加载完谁执行。值得注意的是，向 document 动态添加 script 标签时，async 属性默认是 true。</p><h4 id="document-createelement">document.createElement</h4><p>使用 document.createElement 创建的 script 默认是异步的，示例如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log (<span class="built_in">document</span>.createElement(<span class="string">"script"</span>).async); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以，通过动态添加 script 标签引入 JavaScript 文件默认是不会阻塞页面的。如果想同步执行，需要将 async 属性人为设置为 false。</p><p>如果使用 document.createElement 创建 link 标签会怎样呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = <span class="built_in">document</span>.createElement(<span class="string">"link"</span>);</span><br><span class="line">style.rel = <span class="string">"stylesheet"</span>;</span><br><span class="line">style.href = <span class="string">"index.css"</span> ;</span><br><span class="line"><span class="built_in">document</span>.head.appendChild(style); <span class="comment">// 阻塞</span></span><br></pre></td></tr></table></figure><p>其实这只能通过试验确定，已知的是，Chrome 中已经不会阻塞渲染，Firefox、IE 在以前是阻塞的，现在会怎样目前不太清楚。</p><h2 id="4-优化渲染性能">4. 优化渲染性能</h2><p>结合渲染流程，可以针对性的优化渲染性能：</p><ul><li><p>优化JS的执行效率</p></li><li><p>降低样式计算的范围和复杂度</p></li><li><p>避免大规模、复杂的布局</p></li><li><p>简化绘制的复杂度、减少绘制区域</p></li><li><p>优先使用渲染层合并属性、控制层数量</p></li><li><p>对用户输入事件的处理函数去抖动（移动设备）</p></li></ul><p>这里主要参考Google的浏览器渲染性能的基础讲座，想看更详细内容可以去瞅瞅~</p><h3 id="4-1-优化js的执行效率">4.1 优化JS的执行效率</h3><ul><li><strong>动画实现使用 <code>requestAnimationFrame</code></strong></li></ul><p>setTimeout(callback)和setInterval(callback)无法保证callback函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，如下图：</p><p><img src="http://qiniu.xueshiming.cn/%E4%B8%A2%E5%B8%A7.png" alt="丢帧"></p><p><code>requestAnimationFrame(callback)</code> 可以保证callback函数在每帧动画开始的时候执行。注意：jQuery3.0.0以前版本的animate函数就是用setTimeout来实现动画，可以通过jquery-requestAnimationFrame这个补丁来用requestAnimationFrame替代setTimeout。</p><ul><li><strong>长耗时的JS代码放到Web Workers中执行</strong></li></ul><p>JS代码运行在浏览器的主线程上，与此同时，浏览器的主线程还负责样式计算、布局、绘制的工作，如果JavaScript代码运行时间过长，就会阻塞其他渲染工作，很可能会导致丢帧。前面提到每帧的渲染应该在16ms内完成，但在动画过程中，由于已经被占用了不少时间，所以JavaScript代码运行耗时应该控制在3-4毫秒。如果真的有特别耗时且不操作DOM元素的纯计算工作，可以考虑放到Web Workers中执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSortWorker = breakBigTaskIntoMicroTasks(monsterTaskList);</span><br><span class="line">requestAnimationFrame(processTaskList);</span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">processTaskList</span>(<span class="params">taskStartTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextTask = taskList.pop();</span><br><span class="line">    <span class="comment">// 执行小任务</span></span><br><span class="line"></span><br><span class="line">    processTask(nextTask)</span><br><span class="line">    <span class="keyword">if</span>(taskList.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        requestAnimationFrame(requestAnimationFrame)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用Chrome DevTools的Timeline来分析JavaScript的性能</strong></li></ul><p>打开 <code>ChromeDevTools&gt;Timeline&gt;JSProfile</code>，录制一次动作，然后分析得到的细节信息，从而发现问题并修复问题。</p><h3 id="4-2-降低样式计算的范围和复杂度">4.2 降低样式计算的范围和复杂度</h3><p>添加或移除一个DOM元素、修改元素属性和样式类、应用动画效果等操作，都会引起DOM结构的改变，从而导致浏览器要repaint或者reflow。那么这里可以采取一些措施。</p><ul><li><strong>降低样式选择器的复杂度</strong></li></ul><p>尽量保持class的简短，或者使用Web Components框架。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box:nth-last-child(-n+<span class="number">1</span>).title &#123;&#125;</span><br><span class="line"><span class="comment">// 改善后</span></span><br><span class="line"></span><br><span class="line">.final-box-title &#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>减少需要执行样式计算的元素个数</strong></li></ul><p>由于浏览器的优化，现代浏览器的样式计算直接对目标元素执行，而不是对整个页面执行，所以我们应该尽可能减少需要执行样式计算的元素的个数。</p><h3 id="4-3-避免大规模-复杂的布局">4.3 避免大规模、复杂的布局</h3><p>布局就是计算DOM元素的大小和位置的过程，如果你的页面中包含很多元素，那么计算这些元素的位置将耗费很长时间。布局的主要消耗在于：1. 需要布局的DOM元素的数量；2. 布局过程的复杂程度</p><ul><li><strong>1. 尽可能避免触发布局</strong></li></ul><p>当你修改了元素的属性之后，浏览器将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树，对于DOM元素的几何属性修改，比如width/height/left/top等，都需要重新计算布局。对于不能避免的布局，可以使用Chrome DevTools工具的Timeline查看布局的耗时，以及受影响的DOM元素数量。</p><ul><li><strong>2. 使用flexbox替代老的布局模型</strong></li></ul><p>老的布局模型以相对/绝对/浮动的方式将元素定位到屏幕上，而Floxbox布局模型用流式布局的方式将元素定位到屏幕上。通过一个小实验可以看出两种布局模型的性能差距，同样对1300个元素布局，浮动布局耗时14.3ms，Flexbox布局耗时3.5ms。IE10+支持。</p><ul><li><strong>3. 避免强制同步布局事件的发生</strong></li></ul><p>根据渲染流程，JS脚本是在layout之前执行，但是我们可以强制浏览器在执行JS脚本之前先执行布局过程，这就是所谓的强制同步布局。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">requestAnimationFrame(logBoxHeight)</span><br><span class="line"><span class="comment">// 先写后读，触发强制布局</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 更新box样式</span></span><br><span class="line"></span><br><span class="line">    box.classList.add(<span class="string">'super-big'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了返回box的offersetHeight值</span></span><br><span class="line">    <span class="comment">// 浏览器必须先应用属性修改，接着执行布局过程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(box.offsetHeight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先读后写，避免强制布局</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logBoxHeight</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取box.offsetHeight</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(box.offsetHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新box样式</span></span><br><span class="line"></span><br><span class="line">    box.classList.add(<span class="string">'super-big'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JS脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。因此，如果你在当前帧获取属性之前又对元素节点有改动，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JS逻辑。</p><ul><li><strong>4. 避免连续的强制同步布局发生</strong></li></ul><p>如果连续快速的多次触发强制同步布局，那么结果更糟糕。比如下面的例子，获取box的属性，设置到paragraphs上，由于每次设置paragraphs都会触发样式计算和布局过程，而下一次获取box的属性必须等到上一步设置结束之后才能触发。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeWidth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 会让浏览器陷入 ‘读写读写’ 循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; paragraphs.length; i++)&#123;</span><br><span class="line">        paragraphs[i].style.width = box.offsetWidth + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改善后方案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> width = box.offsetWidth;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resizeWidth</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; paragraphs.length; i++) &#123;</span><br><span class="line">        paragraphs[i].style.width = width + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：可以使用FastDOM来确保读写操作的安全，从而帮你自动完成读写操作的批处理，还能避免意外地触发强制同步布局或快速连续布局，消除大量操作DOM的时候的布局抖动。</p><h3 id="4-4-简化绘制的复杂度-减少绘制区域">4.4 简化绘制的复杂度、减少绘制区域</h3><p>Paint就是填充像素的过程，通常这个过程是整个渲染流程中耗时最长的一环，因此也是最需要避免发生的一环。如果Layout被触发，那么接下来元素的Paint一定会被触发。当然纯粹改变元素的非几何属性，也可能会触发Paint，比如背景、文字颜色、阴影效果等。</p><ul><li><strong>1. 提升移动或渐变元素的绘制层</strong></li></ul><p>绘制并非总是在内存中的单层画面里完成的，实际上，浏览器在必要时会将一帧画面绘制成多层画面，然后将这若干层画面合并成一张图片显示到屏幕上。这种绘制方式的好处是，使用transform来实现移动效果的元素将会被正常绘制，同时不会触发其他元素的绘制</p><ul><li><strong>2. 减少绘制区域，简化绘制的复杂度</strong></li></ul><p>浏览器会把相邻区域的渲染任务合并在一起进行，所以需要对动画效果进行精密设计，以保证各自的绘制区域不会有太多重叠。另外可以实现同样效果的不同方式，应该采用性能更好的那种。</p><ul><li><strong>3. 通过Chrome DevTools来分析绘制复杂度和时间消耗，尽可能降低这些指标</strong></li></ul><p>打开DevTools，在弹出的面板中，选中 <code>MoreTools&gt;Rendering</code> 选项卡下的Paint flashing，这样每当页面发生绘制的时候，屏幕就会闪现绿色的方框。通过该工具可以检查Paint发生的区域和时机是不是可以被优化。通过Chrome DevTools中的 Timeline&gt;Paint选项可以查看更细节的Paint信息</p><h3 id="4-5-优先使用渲染层合并属性-控制层数量">4.5 优先使用渲染层合并属性、控制层数量</h3><ul><li><strong>1. 使用transform/opacity实现动画效果</strong></li></ul><p>使用transform/opacity实现动画效果，会跳过渲染流程的布局和绘制环节，只做渲染层的合并。</p><table><thead><tr><th><strong>Type</strong></th><th><strong>Func</strong></th></tr></thead><tbody><tr><td>Position</td><td>transform: translate(-px,-px)</td></tr><tr><td>Scale</td><td>transform: scale(-)</td></tr><tr><td>Rotation</td><td>transform: rotate(-deg)</td></tr><tr><td>Skew</td><td>transform: skew(X/Y)(-deg)</td></tr><tr><td>Matrix</td><td>transform: matrix(3d)(…)</td></tr><tr><td>Opacity</td><td>opacity: 0-1</td></tr></tbody></table><p>使用transform/opacity的元素必须独占一个渲染层，所以必须提升该元素到单独的渲染层。</p><ul><li><strong>2. 提升动画效果中的元素</strong></li></ul><p>应用动画效果的元素应该被提升到其自有的渲染层，但不要滥用。在页面中创建一个新的渲染层最好的方式就是使用CSS属性will-change，对于目前还不支持will-change属性、但支持创建渲染层的浏览器，可以通过3D transform属性来强制浏览器创建一个新的渲染层。需要注意的是，不要创建过多的渲染层，这意味着新的内存分配和更复杂的层管理。注意，IE11，Edge17都不支持这一属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.moving-element&#123;</span><br><span class="line">    will-change: transform;</span><br><span class="line">    transform: translateZ(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>3. 管理渲染层、避免过多数量的层</strong></li></ul><p>尽管提升渲染层看起来很诱人，但不能滥用，因为更多的渲染层意味着更多的额外的内存和管理资源，所以当且仅当需要的时候才为元素创建渲染层。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">will-change: transform;</span><br><span class="line">transform: translateZ(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>4. 使用Chrome DevTools来了解页面的渲染层情况</strong></li></ul><p>开启 <code>Timeline&gt;Paint</code> 选项，然后录制一段时间的操作，选择单独的帧，看到每个帧的渲染细节，在ESC弹出框有个Layers选项，可以看到渲染层的细节，有多少渲染层，为何被创建？</p><h2 id="4-6-对用户输入事件的处理函数去抖动-移动设备">4.6 对用户输入事件的处理函数去抖动（移动设备）</h2><p>用户输入事件处理函数会在运行时阻塞帧的渲染，并且会导致额外的布局发生。</p><ul><li><strong>1. 避免使用运行时间过长的输入事件处理函数</strong></li></ul><p>理想情况下，当用户和页面交互，页面的渲染层合并线程将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致JavaScript、布局和绘制过程发生。但是如果被触摸的元素绑定了输入事件处理函数，比如<code>touchstart/touchmove/touchend</code>，那么渲染层合并线程必须等待这些被绑定的处理函数执行完毕才能执行，也就是用户的滚动页面操作被阻塞了，表现出的行为就是滚动出现延迟或者卡顿。</p><p>简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够快速的执行完毕，以便腾出时间来让渲染层合并线程完成他的工作。</p><ul><li><strong>2. 避免在输入事件处理函数中修改样式属性</strong></li></ul><p>输入事件处理函数，比如scroll/touch事件的处理，都会在requestAnimationFrame之前被调用执行。因此，如果你在上述输入事件的处理函数中做了修改样式属性的操作，那么这些操作就会被浏览器暂存起来，然后在调用requestAnimationFrame的时候，如果你在一开始就做了读取样式属性的操作，那么将会触发浏览器的强制同步布局操作。</p><ul><li><strong>3. 对滚动事件处理函数去抖动</strong></li></ul><p>通过requestAnimationFrame可以对样式修改操作去抖动，同时也可以使你的事件处理函数变得更轻</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line"></span><br><span class="line">    lastScrollY = <span class="built_in">window</span>.scrllY;</span><br><span class="line">    <span class="comment">// Prevent multiple rAf callbacks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(scheduledAnimationFrame)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    scheduledAnimationFrame = <span class="literal">true</span>;</span><br><span class="line">    requestAnimationFrame(readAndUpdatePage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, onScroll);</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><blockquote><p>转载自：<a href="https://mp.weixin.qq.com/s/njwpsI-5T2mewPYjNef0jA" target="_blank" rel="noopener">浏览器渲染基本原理解析</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆栈内存和闭包</title>
      <link href="/2020/01/10/%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E9%97%AD%E5%8C%85/"/>
      <url>/2020/01/10/%E5%A0%86%E6%A0%88%E5%86%85%E5%AD%98%E5%92%8C%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="ecstack">ECStack</h2><pre><code>&gt;当我们浏览器加载页面的时候，浏览器会形成一个能够供代码执行的环境 ，叫 ECStack （栈内存）</code></pre><h2 id="ec">EC</h2><pre><code>&gt;Execution Context: 包括 全局执行上下文，函数执行上下文，`Eval` 函数执行上下文（指的是运行在 `eval` 函数中的代码，很少用而且不建议使用）</code></pre><h2 id="ec-g">EC(G)</h2><pre><code>&gt;Execution Global：全局执行上下文，只有一个，浏览器中的全局对象（GO）就是 window 对象，this 指向这个全局对象</code></pre><h2 id="go">GO</h2><pre><code>&gt;Global Object：全局对象</code></pre><h2 id="ao">AO</h2><pre><code>&gt;Activation Object: 活动对象</code></pre><h2 id="vo">VO</h2><pre><code>&gt;Variable object 变量对象</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">z</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x +y +z)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> C = A(<span class="number">2</span>);</span><br><span class="line">C(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="闭包的形成">闭包的形成</h2><p>1、当我们浏览器加载页面的时候，浏览器会形成一个能够供代码执行的环境 ，叫 <code>ECStack(执行栈)</code><br>然后在一个 <code>EC(GLOBAL)</code> 全局执行上下文中创建 GO 全局对象 并且 进栈执行，压入栈底。</p><p>2、在 <code>EC(GLOBAL)</code> 中 创建 <code>VO(G)</code>：<br>当遇到一个函数 <code>A</code> 声明时：保存函数变量<br>然后创建一个堆，将函数体内代码当做代码字符串你存储起来<br>初始化当前函数作用域 <code>[[scope]]</code> 为 所在（EC）上下文中的变量对象 VO/AO</p><p>3、当 <code>A</code> 执行的时候，形成一个函数执行上下文 <code>EC(A)</code>，<code>EC(A)</code> 中包含一个 <code>AO(A)</code>，<br>压缩到栈 <code>ECStack</code> 里执行，<br>初始化内置实参集合 <code>arguments</code>，创建形参变量并赋值，变量提升<br>初始化 <code>this</code> 指向<br>初始化 <code>[[scopeChain]]:&lt;VO(G)&gt;</code></p><p>4、初始化内置实参集合 <code>arguments</code>，创建形参变量并赋值<br>在 EC(A函数) 中遇到 A中 B函数的声明，就再创建一个堆，指向 B 函数，<br><code>B[[scope]] = AO(A)</code></p><p>因为 B 执行的返回值 赋值给了 C，全局变量 C 占用了 <code>EC(A)</code> 中B的堆，<br>A函数 所以不能出栈， <code>EC(A)</code> 不能释放，这就形成了闭包</p><p>5、C 函数执行，形成 <code>EC(C)</code>, this 指向 window, <code>[[scopeChain]: AO(A)]</code></p><p>形成作用域链：  AO(A) -&gt; VO(G) -&gt; GO</p><h2 id="闭包的形成总结">闭包的形成总结</h2><p>1、函数在创建的时候：</p><ul><li>创建一个堆（将函数体内的代码当做代码字符串存储起来 和  对应的键值对{length: 形参个数，name: 函数名，prototype: 原型}）</li><li>初始化当前函数作用域[[scope]] = 所在（EC）上下文中的变量对象VO/AO</li></ul><p>2、函数执行的时候：</p><ul><li>创建一个新的执行上下文EC(压缩到栈ECStack里执行)</li><li>初始化 this 指向</li><li>初始化作用域链 <code>[[scopeChain]]:&lt;xxx&gt;</code></li><li>创建AO变量对象来存储变量<ul><li><code>==&gt; arguments ==&gt; 形参 ==&gt; 代码执行</code></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react中props和state有什么区别?</title>
      <link href="/2019/10/25/react%E4%B8%ADprops%E5%92%8Cstate%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2019/10/25/react%E4%B8%ADprops%E5%92%8Cstate%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      <content type="html"><![CDATA[<blockquote><p>props和state之间的确切区别是什么？理解它们的工作原理相当容易，尤其是在上下文中查看时，但是从概念上理解它们也有些困难。一开始令人困惑，因为它们都具有抽象术语，并且它们的值看起来相同，但是它们也具有不同的作用。</p></blockquote><a id="more"></a><h3 id="setstate-实际做了什么？">setState 实际做了什么？</h3><p><code>setState()</code>会对一个组件的 state 对象安排一次更新。当 <code>state</code> 改变了，该组件就会重新渲染。</p><h3 id="state-和-props-之间的区别是什么？">state 和 props 之间的区别是什么？</h3><p><code>props（“properties” 的缩写）</code>和 <code>state</code> 都是普通的 <code>JavaScript</code> 对象。它们都是用来保存信息的，这些信息可以控制组件的渲染输出，而它们的一个重要的不同点就是：</p><ul><li><p><code>props</code> 是传递给组件的（类似于函数的形参），而 <code>state</code> 是在组件内被组件自己管理的（类似于在一个函数内声明的变量）。</p></li><li><p><code>props</code> 是不可修改的，所有 <code>React</code> 组件都必须像纯函数一样保护它们的 <code>props</code> 不被更改。 由于 <code>props</code> 是传入的，并且它们不能更改，因此我们可以将任何仅使用 <code>props</code> 的 <code>React</code> 组件视为 <code>pureComponent</code>，也就是说，在相同的输入下，它将始终呈现相同的输出。</p></li><li><p><code>state</code> 是在组件中创建的，一般在 <code>constructor</code>中初始化 <code>state</code></p></li><li><p><code>state</code> 是多变的、可以修改，每次<code>setState</code>都异步更新的。</p></li></ul><h3 id="为什么-setstate-给了我一个错误的值？">为什么 setState 给了我一个错误的值？</h3><p>在 <code>React</code> 中，<code>this.props</code> 和 <code>this.state</code> 都代表着已经被渲染了的值，即当前屏幕上显示的值。</p><p>调用 <code>setState</code> 其实是异步的 —— 不要指望在调用 <code>setState</code> 之后，<code>this.state</code> 会立即映射为新的值。如果你需要基于当前的 <code>state</code> 来计算出新的值，那你应该传递一个函数，而不是一个对象（详情见下文）。</p><p>代码不会像预期那样运行的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">incrementCount() &#123;</span><br><span class="line">  // 注意：这样 *不会* 像预期的那样工作。</span><br><span class="line">  this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleSomething() &#123;</span><br><span class="line">  // 假设 `this.state.count` 从 0 开始。</span><br><span class="line">  this.incrementCount();</span><br><span class="line">  this.incrementCount();</span><br><span class="line">  this.incrementCount();</span><br><span class="line">  // 当 React 重新渲染该组件时，`this.state.count` 会变为 1，而不是你期望的 3。</span><br><span class="line"></span><br><span class="line">  // 这是因为上面的 `incrementCount()` 函数是从 `this.state.count` 中读取数据的，</span><br><span class="line">  // 但是 React 不会更新 `this.state.count`，直到该组件被重新渲染。</span><br><span class="line">  // 所以最终 `incrementCount()` 每次读取 `this.state.count` 的值都是 0，并将它设为 1。</span><br><span class="line"></span><br><span class="line">  // 问题的修复参见下面的说明。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>那么应该如何更新那些依赖于当前的 <code>state</code> 的 <code>state</code> 呢？</p></blockquote><p>给 <code>setState</code> 传递一个函数，而不是一个对象，就可以确保每次的调用都是使用最新版的 <code>state</code>。</p><blockquote><p>给 setState 传递一个对象与传递一个函数的区别是什么？</p></blockquote><p>传递一个函数可以让你在函数内访问到当前的 <code>state</code> 的值。因为 <code>setState</code> 的调用是分批的，所以你可以链式地进行更新，并确保它们是一个建立在另一个之上的，这样才不会发生冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">incrementCount() &#123;</span><br><span class="line">  this.setState((state) =&gt; &#123;</span><br><span class="line">    // 重要：在更新的时候读取 `state`，而不是 `this.state`。</span><br><span class="line">    return &#123;count: state.count + 1&#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleSomething() &#123;</span><br><span class="line">  // 假设 `this.state.count` 从 0 开始。</span><br><span class="line">  this.incrementCount();</span><br><span class="line">  this.incrementCount();</span><br><span class="line">  this.incrementCount();</span><br><span class="line"></span><br><span class="line">  // 如果你现在在这里读取 `this.state.count`，它还是会为 0。</span><br><span class="line">  // 但是，当 React 重新渲染该组件时，它会变为 3。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setstate-什么时候是异步的？">setState 什么时候是异步的？</h3><p>目前，在事件处理函数内部的 <code>setState</code> 是异步的。（V16.10）</p><p>例如，如果 <code>Parent</code> 和 <code>Child</code> 在同一个 <code>click</code> 事件中都调用了 <code>setState</code> ，这样就可以确保 <code>Child</code> 不会被重新渲染两次。取而代之的是，<code>React</code> 会将该 <code>state</code> 等到浏览器事件结束的时候，再统一地进行更新。这种机制可以在大型应用中得到很好的性能提升</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>神奇的reduce</title>
      <link href="/2019/08/25/%E7%A5%9E%E5%A5%87%E7%9A%84reduce/"/>
      <url>/2019/08/25/%E7%A5%9E%E5%A5%87%E7%9A%84reduce/</url>
      <content type="html"><![CDATA[<h5 id="none"></h5><blockquote><p>reduce ( ) 这个函数有些复杂，不知到怎么描述好，直接看例子吧：</p></blockquote><a id="more"></a><ul><li>func：接受4个参数得函数，<br>previous, current, index, array，之前值，当前值，索引，数组本身。func的返回值，会作为下一次迭代时previous的值。</li><li>initialValue：可选，表示初始值，如果指定initialValue，则作为初始时previous的值，如果缺省，数组得第一个元素为previous值，第二个元素为current。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">previous, current, index, array</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> previous + current;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line">过程展开如下：</span><br><span class="line"><span class="comment">// 初始：</span></span><br><span class="line">previous = initialValue = <span class="number">1</span>, current = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 第一次迭代 之后</span></span><br><span class="line">previous = <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span>, current = <span class="number">3</span>;<span class="comment">//current 向后移动一个元素</span></span><br><span class="line"><span class="comment">// 第二次迭代之后</span></span><br><span class="line">previous = <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span>, current = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// 第三次迭代之后</span></span><br><span class="line">previous = <span class="number">6</span> + <span class="number">4</span> = <span class="number">10</span>, current = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 第四次迭代之后</span></span><br><span class="line">previous = <span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span> ,current = <span class="literal">undefined</span><span class="comment">// 没有了，退出，返回15；</span></span><br></pre></td></tr></table></figure><h4 id="拓展：reduceright">拓展：reduceRight()</h4><p>和reduce类似，只不过从数组结尾开始，从右向左迭代。</p><h4 id="应用">应用</h4><ul><li>json数组去重</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ZYTX"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"Y13xG_4wQnOWK1Qw"</span>,</span><br><span class="line">    <span class="string">"gender"</span>: <span class="string">"AAAAAA.doc"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ZYTA"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"Y13xG_4wQnOWK1Qw"</span>,</span><br><span class="line">    <span class="string">"gender"</span>: <span class="string">"BBBBBB.doc"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ZDTX"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"Y13xG_4wQnOWK1Qw"</span>,</span><br><span class="line">    <span class="string">"gender"</span>: <span class="string">"CCCCCC.doc"</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"ZYTX"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"Y13xG_4wQnOWK1Qw"</span>,</span><br><span class="line">    <span class="string">"gender"</span>: <span class="string">"AAAAAA.doc"</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="keyword">let</span> hash = &#123;&#125;;</span><br><span class="line">    arr = arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">item, next</span>) </span>&#123;</span><br><span class="line">        hash[next.name] ? <span class="string">''</span> : hash[next.name] = <span class="literal">true</span> &amp;&amp; item.push(next);</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><ul><li>数组去重</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.sort().reduce(<span class="function">(<span class="params">init, current</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(init.length === <span class="number">0</span> || init[init.length<span class="number">-1</span>] !== current) &#123;</span><br><span class="line">init.push(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> init;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><ul><li>reduce 实现 promise  串行执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runPromiseInSequence</span>(<span class="params">arr, input</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> arr.reduce(</span><br><span class="line">(promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),</span><br><span class="line"><span class="built_in">Promise</span>.resolve(input)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(a * <span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(a * <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function 3  - will be wrapped in a resolved promise by .then()</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// promise function 4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p4</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">resolve(a * <span class="number">4</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promiseArr = [p1, p2, f3, p4];</span><br><span class="line">runPromiseInSequence(promiseArr, <span class="number">10</span>)</span><br><span class="line">.then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><p>拓展：更加简便的方法，使用异步函数来实现<br><code>runPromiseInSequence</code>可以简化为：Ï</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runPromiseInSequence</span>(<span class="params">myPromises</span>) </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myPromises) &#123;</span><br><span class="line"><span class="keyword">await</span> value();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序常被忽略的知识</title>
      <link href="/2019/06/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/06/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote><p>在开发小程序的同时，也别忘记去理解一些原理性和细节性的问题，因为这是我们提升的关键。<strong>to be an engineer, not a coder.</strong></p></blockquote><a id="more"></a><h3 id="tips-先来一些干货">Tips: 先来一些干货</h3><h5 id="wx：key-不仅仅是唯一标识">wx：key  不仅仅是唯一标识</h5><p>列表数据发生改变重新出发页面渲染的时候，列表中的项目可以保持自身状态<br>比如在<code>input</code>组件里，输入了内容之后<br>在页面渲染之后，不希望<code>input</code> 内容发生改变，需要用此属性<br>这个属性，在页面重新渲染的时候，确保带有 <code>key</code> 的组件 会重新排序，而不是重新渲染，从而提高页面渲染性能的效率</p><p>另外：如不提供 <code>wx:key</code>，会报一个 <code>warning</code>， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p><h5 id="block是一个包装元素-不是组件-渲染之后页面看不出来">Block是一个包装元素，不是组件，渲染之后页面看不出来</h5><h5 id="wx：if-和hidden-区别">wx：if 和hidden 区别</h5><p><code>wx:if</code>在切换时有局部渲染的过程，从而保证条件块渲染时，可以销毁并重新渲染，有更高的切换消耗<br><code>hidden</code>始终渲染。可以控制视图上的显示和隐藏，有更高的初始化渲染消耗,<br>所以元素频繁切换的话，使用<code>hidden</code></p><h4 id="wxml支持文件引用">wxml支持文件引用</h4><p><code>import</code>： 只能引用我们定义模板文件的模板内容块</p><p><img src="http://qiniu.xueshiming.cn/1" alt=""><br>作用域的概念：只能引用目标文件定义的<code>template</code>模板，如果目标文件内嵌套了其他模板，是不会被引用的，避免了引用模板死循环的问题</p><p><img src="http://qiniu.xueshiming.cn/2" alt=""><br><code>include</code> : 把目标 文件内除了模板代码块外的 所有代码都引入，相当于拷贝到了<code>include</code>位置这里</p><p><img src="http://qiniu.xueshiming.cn/3" alt=""></p><h4 id="wxss和css对比">Wxss和css对比</h4><p><img src="http://qiniu.xueshiming.cn/4" alt=""></p><blockquote><p>尺寸单位rpx</p></blockquote><p>先了解几个概念：</p><p><img src="http://qiniu.xueshiming.cn/5" alt=""></p><ul><li><code>设备像素</code>： 设备能控制的显示的最小物理单位<br>这个最小物理单位是屏幕上一个个点，点是固定不变的</li><li><code>CSS像素</code>：外部编程的概念，css代码中使用的逻辑像素</li><li><code>PPI/DPI</code>：每英寸拥有的像素数目</li></ul><p><img src="http://qiniu.xueshiming.cn/6" alt=""></p><ul><li><code>DPR</code>：手机的某一方向上设备像素和css像素之比</li></ul><p>虽然<code>wxss</code>支持<code>rem</code>，但是我们知道<code>rem</code>是根据<code>html</code>根元素的<code>fontSize</code>大小来适配的，<br><code>wxss</code>不能直接操作<code>html</code>的样式属性，所以<code>rem</code>适配方案就失效了。<br><code>rpx</code>应运而生，规定屏幕宽度为<code>750rpx</code>，从而我们可以根据屏幕宽度来自适应，<code>rpx</code>和<code>rem</code>实现方式是相似的，而且<code>rpx</code>最终转换为<code>rem</code></p><blockquote><p>样式导入</p></blockquote><ul><li><p>外联样式引入：<code>@import ‘./ss.wxss’</code></p></li><li><p>内连样式引入：<code>style</code> 一般用来写动态的样式</p></li></ul><blockquote><p>选择器</p></blockquote><p><strong>优先级</strong></p><p><img src="http://qiniu.xueshiming.cn/7" alt=""><br>一般想要修改他人插件样式的时候使用<code>!import</code></p><hr><h3 id="小程序运行机制">小程序运行机制</h3><blockquote><p>小程序两种启动方式：冷启动，热启动</p></blockquote><ul><li>热启动：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。</li><li>冷启动：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。</li></ul><blockquote><p>小程序什么时候会主动销毁？</p></blockquote><ol><li>小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁</li><li>当我们在短时间内连续两次收到系统告警的时候，微信就会主动销毁，短时间间隔是5s</li></ol><hr><h3 id="小程序更新机制：">小程序更新机制：</h3><p>小程序在冷启动的时候遇到版本更新，小程序会异步加载，帮我们下载最新版本的代码包，并同时使用微信本地版本的代码包启动，也就是说最新的代码包，将在小程序下次启动才去加载。如果偏要使用最新版本的代码包，我们可以使用api来处理</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html" target="_blank" rel="noopener">wx.getUpdateManager</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const updateManager = wx.getUpdateManager()</span><br><span class="line"></span><br><span class="line">updateManager.onCheckForUpdate(function (res) &#123;</span><br><span class="line">  // 请求完新版本信息的回调</span><br><span class="line">  console.log(res.hasUpdate)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">updateManager.onUpdateReady(function () &#123;</span><br><span class="line">  wx.showModal(&#123;</span><br><span class="line">    title: &apos;更新提示&apos;,</span><br><span class="line">    content: &apos;新版本已经准备好，是否重启应用？&apos;,</span><br><span class="line">    success(res) &#123;</span><br><span class="line">      if (res.confirm) &#123;</span><br><span class="line">        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br><span class="line">        updateManager.applyUpdate()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">updateManager.onUpdateFailed(function () &#123;</span><br><span class="line">  // 新版本下载失败</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="小程序加载机制：">小程序加载机制：</h3><p>小程序的启动流程图里面：</p><p><img src="http://qiniu.xueshiming.cn/8" alt=""><br>左侧的部分是在启动的时候，微信客户端里面的视图层和逻辑层一些交互逻辑以及数据缓存的存取操作，在小程序启动的时候，会向<code>cdn</code>请求最新代码包，第一次启动必须等到代码包下载完毕，注入到<code>webView</code>容器内执行之后，才能看到小程序页面，所以在网络不好的情况下，我们会感觉到页面打开比较慢，客户端会帮我们把代码包缓存到本地，当我们下一次启动的时候，我们会从 <code>cdn</code> 请求是否有最新版本的代码包。</p><hr><h3 id="小程序应用和页面的生命周期：">小程序应用和页面的生命周期：</h3><blockquote><p>小程序应用生命周期：onLaunch，onShow，onHide，onError</p></blockquote><p>首次进入小程序，从 <code>cdn</code> 或者小程序本地拿到代码包注入到运行环境，<br>微信客户端会给我们逻辑层<code>app.js</code>的<code>app</code>实例来派发<code>onLaunch</code>事件，<br>在逻辑层，<code>app.js</code>的 <code>app</code> 构造器的参数里面的<code>onLaunch</code>方法就会被调用。<br>当用户使用<code>home</code>件或者点击右上角小程序关闭按钮，来关闭小程序时，小程序是没有被直接销毁的，这时<code>app</code>构造器的参数里面的<code>onHiede</code>方法就会被调用，当我们再次打开小程序时，微信唤起小程序，<code>onShow</code>方法就会被调用，<br>当小程序脚本发现错误时，或<code>api</code>调用失败时，会调用<code>onError</code>。</p><blockquote><p>小程序页面的生命周期：onLoad，onShow，onReady，onHide，onUnload，</p></blockquote><p>页面未被销毁之前，<code>onLoad</code>只会调用一次，<br>页面显示之后，会调用page实例里面的<code>onShow</code><br>当页面初次渲染之后，<code>onReady</code>就会被调用，页面未被销毁之前，只会调用一次<br><code>onReady</code>触发之后，逻辑层和视图层进行交互，<br>当我们在当前页面打开新的页面之后，当前页面会触发<code>onHide</code>，<br>如果关闭当前页，会触发<code>onUnload</code></p><p>负责页面视图的<code>view</code>线程和处理数据的服务以及服务的服务线程，<code>AppService</code>，<br>协同完成生命周期周期调用</p><p><img src="http://qiniu.xueshiming.cn/9" alt=""></p><hr><h3 id="小程序事件模型">小程序事件模型</h3><p><img src="http://qiniu.xueshiming.cn/10" alt=""></p><h5 id="1-事件捕获阶段">1. 事件捕获阶段</h5><p>绑定的事件从最外层节点向下传递到目标节点元素，依次检查，所经过的节点是否绑定了同一事件类型的监听回调函数，如果有则执行对应的事件回调函数</p><h5 id="2-事件处理阶段">2. 事件处理阶段</h5><p>事件在到达目标节点之后，会触发目标节点所绑定的监听回调函数</p><h5 id="3-事件冒泡阶段">3. 事件冒泡阶段</h5><p>事件从目标节点，向上冒泡到最外层节点，依次检查经过的节点是否绑定了，同样事件类型的监听回调函数，如果有，会执行这个回调函数</p><p><code>target</code>属性： 触发事件的当前组件<br><code>currentTarget</code>属性： 触发事件的根源组件</p><p><code>eg:</code> 如果有外层<code>view</code>还有个里层<code>view</code>嵌套，都通过<code>bind</code>绑定了点击事件，<code>target</code>为外层<code>view</code>组件的事件对象,<code>currentTarget</code>为底层<code>view</code>组件的事件对象</p><p><img src="http://qiniu.xueshiming.cn/11" alt=""></p><ul><li><code>type</code> 触发事件的触发类型</li><li><code>timestamp</code> 触发事件的时间戳</li><li><code>target</code> 触发事件的根源组件，包括触发事件根源组件的id自定义属性的集合</li><li><code>currenTarget</code> 事件绑定额当前组件 ，包括当前组件的<code>id</code>，类型，<code>data</code>自定义属性的集合</li><li><code>touches</code> 是一个数组，每一个元素都是一个<code>touc</code>h对象 ，标识当前停留在屏幕上的触摸点和信息</li><li><code>changedTouches</code> 是一个数据，标识有变化的 触摸点，即当前触摸点从有到无或从无到有的变化</li><li><code>detail</code>  标识各个事件带有的数据，点击事件： ‘触摸点距离文档左上角的距离’<br>媒体事件，触发事件的时候播放状态，以及时间戳</li></ul><hr><h3 id="小程序运行环境：">小程序运行环境：</h3><blockquote><p>在不同环境下的<code>javascript</code>脚本运行环境是不同的，微信小程序运行在三端<code>：iOS（iPhone/iPad）</code>、<code>Android</code> 和 用于调试的开发者工具。</p></blockquote><p><strong>三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</strong></p><ul><li><p>在 <code>iOS</code> 上，小程序逻辑层的 <code>javascript</code> 代码运行在 <code>JavaScriptCore</code> 中，视图层是由 <code>WKWebView</code> 来渲染的，环境有 <code>iOS8</code>、<code>iOS9</code>、<code>iOS10</code>；</p></li><li><p>在 <code>Android</code> 上，</p><ul><li>旧版本，小程序逻辑层的 <code>javascript</code> 代码运行中 <code>X5 JSCore</code> 中，视图层是由 <code>X5</code> 基于 <code>Mobile</code> <code>Chrome 57</code> 内核来渲染的</li><li>新版本，小程序逻辑层的 <code>javascript</code> 代码运行在 <code>V8</code> 中，视图层是由自研 <code>XWeb</code> 引擎基于 <code>Mobile Chrome 6 7</code> 内核来渲染的；</li></ul></li><li><p>在 开发工具上，小程序逻辑层的 <code>javascript</code> 代码是运行在 <code>NW.js</code> 中，视图层是由 <code>Chromium 60 Webview</code> 来渲染的。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上手捣鼓linux命令系列(更新)</title>
      <link href="/2019/06/20/Linux/"/>
      <url>/2019/06/20/Linux/</url>
      <content type="html"><![CDATA[<blockquote><p>最近将博客换成了https协议，并将自己小程序后台部署到了我的ubuntu服务器上，期间学习到了很多东西，下面便一一悉知</p></blockquote><a id="more"></a><p><strong>tips：</strong></p><h4 id="nginx配置">nginx配置</h4><p>每次<code>nginx</code>配置完时，都需要<code>service nginx restart</code>或<code>service nginx start</code>来重启<code>nginx</code>服务</p><p>拓展：关于<code>nginx</code>更多的信息，updating…</p><h4 id="改写文件权限">改写文件权限</h4><p><code>sudo chmod 777 /etc/nginx/myssl</code>,在scp上传文件夹时候需要设置文件夹可写权限,</p><p>我干脆权限设置最高(有些粗暴哈哈😀，但是不可取)</p><p>拓展：updating…</p><h4 id="找端口杀进程">找端口杀进程</h4><p>这个问题我们经常遇到，但是想用的时候总是忘记，<code>lsof -i:9981</code>查找到 <code>9981</code> 端口对应的<br><code>pId: 22463</code>然后<code>kill -9 22463</code>就可以了。</p><p>拓展：updating…</p><h4 id="查看nginx的报错原因">查看nginx的报错原因</h4><p>查找<code>nginx</code>的日志文件,查看<code>log</code>文件获取报错信息<code>/var/log/nginx</code></p><h4 id="使项目持久运行在服务器上">使项目持久运行在服务器上</h4><p>用screen保持项目在服务器上长久运行<a href="https://www.jianshu.com/p/b24f597c0561" target="_blank" rel="noopener">戳这儿</a></p><p>拓展：updating…</p><h4 id="保持ssh连接不断开">保持ssh连接不断开</h4><p>经常遇到终端断开了ssh远程链接，然后终端卡顿，很是头疼<code>/etc/ssh/sshd_config</code>,添加：<br><code>ClientAliveInterva 120</code></p><p><code>ClientAliveCountMax 720</code></p><p>重启sshd服务：</p><p><code>systemctl restart sshd</code></p><blockquote><p>第一句意思是服务端每间隔120s会向客户端发送一个空数据包，第二句表示服务器最大会发送720次,120*720=24小时，24小时期间连接是不会断开的</p></blockquote><h4 id="2017-11-22-更新">2017-11-22 更新</h4><p>在windows下，下载<code>jdk-8u25-linux-64.tar.gz</code></p><p>使用<code>Xshell5p.exe</code>用来访问远程面板</p><ol><li>在windows下面下好 tar.gz</li><li>上传文件 rz</li><li>解压文件 tar -xzvf jdk-8u25-linux-x64.tar.gz</li><li>进入当前用户目录  cd home/fisherman</li><li>vi .bash -profile  编辑文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=&quot;$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&quot;</span><br><span class="line">PATH=&quot;$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOMR/bin&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li><p><code>:wq!</code>退出</p></li><li><p><code>source .bash_profile</code>命令生效</p></li><li><p><code>java -version</code> 查询java版本</p></li><li><p><code>tar zcvf secu.tar.gz tt</code>将文件压缩到tt目录</p></li><li><p>启动<code>linuxshell</code>的时候，<code>stdin</code>,<code>stdout</code>,<code>stderr</code>,三个文件描述符会自动打开，他们的值分别是：标准输入，标准输出、标准错误</p></li><li><p>为脚本程序添加执行权限的命令及参数：chmod a+x filename</p></li><li><p>用八进制表示权限：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r--4 w--2  x--1</span><br><span class="line">r--r--r--   444</span><br><span class="line">drw------   600</span><br></pre></td></tr></table></figure><h4 id="xshell-连到-远程服务器">xshell 连到 远程服务器</h4><p><img src="http://qiniu.xueshiming.cn/clipboard.png" alt="连接远程服务器"></p><ol><li>输入远程服务器的ip：</li></ol><p><img src="http://qiniu.xueshiming.cn/clipboard2.png" alt="服务器ip"></p><ol start="2"><li>输入用户名和密码，就登录成功了</li></ol><p><img src="http://qiniu.xueshiming.cn/clipboard3.png" alt="填写自己的用户名"></p><ol start="3"><li>然后可以修改用户名密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd fisherman &amp;&amp; echo 123456 | passwd --stdin fisherman</span><br><span class="line">fisherman--自己的用户名：mark</span><br></pre></td></tr></table></figure><blockquote><p>每天一个linux命令：<a href="https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="noopener">叮</a><br>对权限的参考: <a href="https://blog.csdn.net/sinat_35209943/article/details/52449743" target="_blank" rel="noopener">传送门</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端国际化探索(二)</title>
      <link href="/2019/03/10/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%BA%8C)/"/>
      <url>/2019/03/10/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<blockquote><p>在这里我继续思考整理汇总一下国际化方案，后续可以针对一些重要的点进行突破和落地。</p></blockquote><a id="more"></a><h3 id="国际化的目的">国际化的目的</h3><p>简单的说一个国外网站被你打开却以为是国内公司开的，那么这个网站的国际化就做的非常成功。</p><p>所以国际化的目的就是：让各个地区的人都能感受到这个网站像本地的网站一样，亲切、易用。</p><p>然而这个目标很难实现，在做调研的时候，亚马逊属于国际化比较好的网站，开设分站并在主要几个国家都有专门的运营团队等，然而让普通人打开这个中国亚马逊，还是能感受到与淘宝、京东的不同。</p><p>即便是无法完全实现目标，我们仍然可以用技术以较低成本来尽可能改善体验，因此还是有一定的价值来探索这个</p><h3 id="国际化的流程和步骤">国际化的流程和步骤</h3><p>一个其他地区的人访问我们的网页，然后最终得到一个国际化友好的网页，这个过程发生了什么？这个过程有哪些问题和解决方案？下面就来整条链路的梳理一下。</p><ul><li>入口 URL 附带相关参数。</li><li>通过 IP 地址进行判断。</li></ul><p>第一种方法适用于引导页进行跳转，使用范围比较小。<br>初次访问的判断方法最好是 IP 判断的方式进行。<br>后端也有相关接口，初次访问的人可以用这种方式进行粗略的定位，因为 IP 肯定会有误差。</p><h3 id="记录-cookie-并提供用户切换地区-语言的功能">记录 Cookie 并提供用户切换地区、语言的功能</h3><p>访问之后，我们可以粗略拿到该用户所在的地区，因此可以回写一个 Cookie 来保存当前用户的一些信息，通常比较重要的信息有：</p><ul><li>地区</li><li>语言</li><li>货币</li></ul><p>这几个信息组合就可以，共同确定唯一的一个信息，所以我起了个名字叫『唯一地区语言定位串』。但是目前缺乏一套一致的数据规范，因此会产生一些问题：</p><ul><li>地区是按国家维度区分还是按区域？香港是表示为 HK 还是 CN？</li><li>语言按照什么维度区分？用什么表示？繁体和简体都属于中文，只用中文区分？chinese 和 zh-cn 用哪种表示？</li></ul><p>这些信息如果没有一套规范和列表，很难进行统一和推广，如果没有在一开始就全集团统一确定下来，后期就会像 GBK、UTF-8 这样的编码问题一样，后患无穷。</p><h3 id="针对特定区域进行国际化处理">针对特定区域进行国际化处理</h3><p>获取信息只是第一步，下面轮到我们进行国际化处理了。</p><p>国际化的处理主要分为两部分：</p><ul><li>页面内容改变</li><li>页面交互样式改变<br>按照当地的习惯设计视觉、展示当地的语言的内容等，基本就是国际化处理的核心。这块也是最复杂最有挑战性的部分。</li></ul><h3 id="文本内容改变">文本内容改变</h3><p>固定文案的处理比较简单，最常见的方法就是创建一个映射表，用一个标记来表示该文案，然后不同区域下读取不同的文案内容即可。</p><p>现在市场上也有非常多类似的工具可以帮你简化这些操作，比如 i18next 等。</p><p>比较麻烦的是动态数据这块，就拿淘宝业务举例，就是各种商品数据，比如标题等信息。这些信息怎么进行本地化语言转换就是一个需要突破的问题。即便是看似最简单的繁简体转换，也没有那么简单。有些香港、台湾的惯用语等，并不是单个汉字转成繁体就可以的。更具体的细节可以点击这里。</p><p>由于目前在考虑做英文站，需要大量英文数据，后端也有考虑批量翻译商品数据直接存入数据库的方式来处理。但这种翻译不够完善，最大的缺陷在于无法对图片的内容翻译。一个淘宝商品详情承载最大信息量的不是商品标题等，而是商品的图片。卖家往往通过在商品图片上打字来介绍这个商品，所以这种批量转换只能在搜索和 SEO 方面能有所价值。对于真实成交和本地化的体验可能没有非常大的效果。</p><p>既然商品信息都是卖家提交的，那国际化的内容，能否让卖家自行提交、编辑？这或许是一个最好的突破口，提供给卖家多语言的编辑入口，赋能想要发展国外业务的卖家，在搜索排名上也会更倾向于这些本地化做的好的商家。这样既解决了本地化内容的问题，又促进了卖家的成交，还带给了买家愉快的购物体验。</p><p>更进一步，让淘宝真的只是作为一个交易平台，在当地推广，让本地人开店把商品卖给本地人，建立本地商品库，那是更好的一种方案了。</p><p>除了商品数据之外，还有一个非常重要不可忽视的就是价格信息。包括货币表示符号、货币单位、价格映射，也是一块比较大的挑战。而稍有差池则会引起强烈的不满。比如类似人民币的这种货币符号，跟日元等比较像，如果没有表述清楚可能会产生一些误解。</p><h3 id="图片内容改变">图片内容改变</h3><p>拿淘宝首页来举例。商品图片内容改变的挑战已经在在上面列出来了，所以不再赘述。本节所说的图片是由视觉做的，然后由我们进行控制的图片，比如首焦图：</p><p><img src="http://qiniu.xueshiming.cn/%E9%A6%96%E7%84%A6%E5%9B%BE.jpg" alt="首焦图"></p><p>这种图片的多语言、国际化我们应该怎么处理呢？马上就可以想到：让视觉在做的时候，把相关文案、视觉换一下，做成多张图片就好了，然后由技术进行定向切换图片地址实现。</p><p>但跟淘海外支持视觉讨论了下，并没有这么简单。如果要做好一个国际化的突破，是需要非常细致的做，并不是简单的文案转换即可，视觉都要有变化。对于十分重要的场景（双十一等）这样的投入也是值得的。而日常的一些需求，如果这样做就会十分的浪费资源，投入跟产出比比较低。</p><p>他介绍了一种更方便实现的思路，希望可以通过技术手段来解决掉这个问题。顺着他描述的需求的原型，我补充了一些更细节的技术实现思路，在这里简单介绍下。</p><p>首先活动图片其实是有一些共性的，比如下图：<br><img src="http://qiniu.xueshiming.cn/TB19dcGLVXXXXXYXXXXXXXXXXXX-578-384.jpg" alt="性冷淡风"><br>基本元素就几个：宣传文案、利益点、辅助图片等。其实很容易形成规范固定下来，比如设计时就放这几个元素，然后基于这几个元素设计一张底图，约定好几个文案元素的位置、大小、字体等，然后由运营填写文案。我们的技术工具可以自动把文案翻译并合并到图片上生成多张多语言的图片。然后当请求这个图片时，会自动根据地区进行返回。实在不行也可以手动填写进去，进行定向投放。</p><p>再到后面，甚至都不需要视觉资源。运营想要一个活动，利用现有的模板，从高质量图片库中取出辅助图片，放上去定下位置，填下文案就可以了。</p><p>这样就可以减少人力资源的投入，也可以很好的实现图片的国际化处理，极大的提高了效率。</p><h3 id="交互样式改变">交互样式改变</h3><p>对于样式、交互的国际化，马上想到的应该是通过给 body 加『唯一地区语言定位串』相关联的 class 来实现定制。这样也有问题，就是与浏览器强绑定，无法实现跨端复用。当你的内容用在 Native 或者没有 body 标签的地方，就没法用了。</p><p>如果用这样一套方案，有两个点需要着重考虑：</p><p>根据语系和习惯来定制 class，而不是语言。比如英文和德语都是字母，他们的样式个性化就有共通性，而不需要定义多个 class 重复编写规则，产生冗余代码。<br>样式是用来适配内容而不是约束内容。中文内容翻译成英文，长度势必会增长，从而产生错位。这就需要在视觉时就要思考到溢出要怎么处理。可以像响应式布局那样流动起来，样式用来适配内容，而不是固定死约束内容展示。<br>后端的处理在这里会有比较大的优势，就 Midway 而言，可以根据上面解析出来的『唯一地区语言定位串』直接映射到某个区域的 xtpl 模板，实现非常灵活的改变。</p><h3 id="国际化的部署服务器">国际化的部署服务器</h3><p>终于到了最后一步，服务器部署国际化。国内的网络都变幻莫测，更别提国外连到国内服务器的网速了。所以我们的服务器也要进行国际化部署。这样就依靠阿里云多造（租）点机房了。</p><p>但并不是所有应用都能迁移到国外，有些核心数据还是要在国内机房。那么这么远距离的链接、数据沟通、应用部署又带来非常多的、不可预知的挑战。</p><h3 id="最后">最后</h3><p>整个过程中，除了上面描述的那些问题和挑战，目前我能想到的还有两个：</p><ul><li>文件编码</li><li>内容不准确性的修正和个性化需要投入的人力成本</li></ul><p>目前淘宝由于历史原因还有一些应用是 GBK 编码，GBK 编码显然不能用于国际化、全球化，特殊语言的国家访问看下来全是『口口口口口口口口口口口口口口口口』。或许这也是一个契机，就像升级 https 那样，推动整个集团去 GBK。</p><p>内容和个性化始终需要人力，我们如何能利用技术进一步提高效率解决人力问题？这也是一个挑战。</p><h3 id="附：国际化方案探索脑图">附：国际化方案探索脑图</h3><p><img src="http://qiniu.xueshiming.cn/%E5%9B%BD%E9%99%85%E5%8C%96%E8%84%91%E5%9B%BE.jpg" alt="国际化探索脑图"></p><p>摘自：<a href="https://taobaofed.org/blog/2016/03/21/internationalization/" target="_blank" rel="noopener">国际化探索</a></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端国际化探索(一)</title>
      <link href="/2019/01/20/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%B8%80)/"/>
      <url>/2019/01/20/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<blockquote><p>对于海外的业务需求，我们期望能让客户有一个良好的用户体验，因此前端需要适配国际化。</p></blockquote><a id="more"></a><h3 id="面临的挑战">面临的挑战</h3><p>乍一听，这个海外项目需求并没有什么特别的地方，似乎就多了一个国际化适配。但细细一想，事情可没这么简单，前端开发面临了很多新的问题。下面梳理一下国际化开发中通常会面临的挑战：</p><ul><li><p>页面文案全部可配置 需要配置的文案大致有四种：label、placeholder、字段校验提示信息、超链接。<br><img src="http://qiniu.xueshiming.cn/%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%981" alt="页面文案配置"></p></li><li><p>页面文案样式处理 文案样式需要特别注意，不同语言的文字，可能会有不同的表现。例如下面两张图所示：</p><ul><li>英语（页面样式正常）<br><img src="http://qiniu.xueshiming.cn/%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%982" alt="英文"></li><li>土耳其语（页面样式异常）<br><img src="http://qiniu.xueshiming.cn/%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%983" alt="土耳其语"></li></ul></li><li><p>日期、数字格式处理 页面上展示日期或数量的地方，也是需要做国际化适配。</p></li><li><p>LTR／RTL 很多中东国家的语言习惯都是 RTL，可以尝试使用 direction 和 transform 来解决。</p></li><li><p>图片（banner）国际化 如果你想把国际化做的足够精细，那么图片国际化也是需要考虑的。</p></li><li><p>第三方 UI 组件 如果使用了第三方 UI 组件，如：elementUI、ant design UI 等，这些 UI 框架通常都宣称支持国际化，但支持的国际化语言数量有限，并不一定能满足业务需求。</p></li><li><p>前端开发工作量和后期维护成本激增 大量的文案需要被提取出来，被提取出来的文案最终会被合并到一个文件中去，如：en-US.json。这些工作如果通过手工完成，那么工作量会是非常巨大的。</p></li></ul><h3 id="国际化文案的处理思路">国际化文案的处理思路</h3><p>以上列举出了很多挑战，但实际上“页面文案处理”才是最主要的矛盾，因为它直接导致前端开发工作量和维护成本的激增。<br>下面我们重点来讨论文案处理思路，其实从实现国际化的角度来看，jQuery、Vue、React 等都只是载体而已，实现思路都是相通的，因此国际化文案处理与具体的技术框架并不耦合。</p><p>一般我们会使用两种比较流行的国际化方案：<a href="https://github.com/yahoo/react-intl" target="_blank" rel="noopener">react-intl</a>、<a href="https://github.com/alibaba/react-intl-universal" target="_blank" rel="noopener">react-intl-universal</a>，下面，我来做一个对比：</p><table><thead><tr><th></th><th style="text-align:center">react-intl</th><th style="text-align:center">react-intl-universal</th></tr></thead><tbody><tr><td>切换不刷新页面</td><td style="text-align:center">优</td><td style="text-align:center">劣</td></tr><tr><td>js文件支持(重要)</td><td style="text-align:center">劣</td><td style="text-align:center">优</td></tr><tr><td>名词单双数，默认值，html</td><td style="text-align:center">优</td><td style="text-align:center">优</td></tr><tr><td>无破坏性</td><td style="text-align:center">劣(装饰器的代码实现会改变ref)</td><td style="text-align:center">优</td></tr></tbody></table><p>react-intl只支持在jsx文件的内容中使用，但是由于项目配置化编程的缘故，很多中文是写在js对象中的。react-intl不支持在普通js对象中使用，很不方便。而且他的装饰器实现会改变组件的ref。他唯一的好处是他的切换不需要刷新页面，不过这种低频的操作刷新页面倒也无妨。</p><p>接下来将会抛出几种国际化文案处理思路，每种思路对生产力和生产关系的要求有高有低，姑且将其分别对应为石器时期、青铜时期、黄金时期。</p><h4 id="石器时期">石器时期</h4><p>传统的国际化开发流程：前端开发到一定阶段，将文案提取到资源文件（通常为  en-US.json），然后将资源文件发送给翻译团队，翻译团队翻译出各国语言版本的文案，每种语言对应一个资源文件，最后将这些资源文件发回给前端开发人员，前端开发人员更新到自己本地。如下图所示：<br><img src="http://qiniu.xueshiming.cn/%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A31" alt="图"></p><ul><li>适用场景</li></ul><ol><li>页面上要提取的文案不多</li><li>支持的国际化语言较少，比如：只需要支持中文和英文</li><li>项目需求较固定，后期只做简单维护，不会新增大的需求</li></ol><ul><li><p>分析<br>这是国际化开发的基本流程，“前端开发”和“翻译团队”是必不可少的两个节点，但它们相互之间依赖的太重。“提取文案”的过程本质上是在重复劳动，因此可以考虑由程序来完成。</p></li><li><p>代码示例</p><p>App.js</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; IntlProvider, FormattedMessage &#125; <span class="keyword">from</span> <span class="string">'react-intl'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'querystring'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">'./logo.svg'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./App.css'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> DEFAULT_MESSAGES <span class="keyword">from</span> <span class="string">'./i18n/en-US.json'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_LOCALE = <span class="string">'en-US'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line"> messages: DEFAULT_MESSAGES,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line"> <span class="keyword">const</span> search = <span class="built_in">window</span>.location.search.slice(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">const</span> params = qs.parse(search);</span><br><span class="line"> <span class="keyword">const</span> locale = params.locale || DEFAULT_LOCALE;</span><br><span class="line"> <span class="keyword">const</span> messages = <span class="built_in">require</span>(<span class="string">`./i18n/<span class="subst">$&#123;locale&#125;</span>.json`</span>);</span><br><span class="line"> <span class="keyword">debugger</span>;</span><br><span class="line"> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">   messages,</span><br><span class="line"> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; messages &#125; = <span class="keyword">this</span>.state;</span><br><span class="line"> <span class="keyword">return</span> (</span><br><span class="line">   &lt;IntlProvider locale=<span class="string">"en"</span> messages=&#123;messages&#125;&gt;</span><br><span class="line">  &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">    &lt;header className=<span class="string">"App-header"</span>&gt;</span><br><span class="line">   &lt;img src=&#123;logo&#125; className=<span class="string">"App-logo"</span> alt=<span class="string">"logo"</span> /&gt;</span><br><span class="line">   &lt;p&gt;</span><br><span class="line">     &lt;FormattedMessage</span><br><span class="line">    id=<span class="string">"welcome"</span></span><br><span class="line">    defaultMessage=&#123;<span class="string">`Hello world!`</span>&#125;</span><br><span class="line">     /&gt;</span><br><span class="line">   &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">   &lt;a</span></span><br><span class="line"><span class="regexp">     className="App-link"</span></span><br><span class="line"><span class="regexp">     href="/</span>?locale=zh-CN<span class="string">"</span></span><br><span class="line"><span class="string">     rel="</span>noopener noreferrer<span class="string">"</span></span><br><span class="line"><span class="string">   &gt;</span></span><br><span class="line"><span class="string">     zh-CN</span></span><br><span class="line"><span class="string">   &lt;/a&gt;</span></span><br><span class="line"><span class="string">   &lt;a</span></span><br><span class="line"><span class="string">     className="</span>App-link<span class="string">"</span></span><br><span class="line"><span class="string">     href="</span>/?locale=en-US<span class="string">"</span></span><br><span class="line"><span class="string">     rel="</span>noopener noreferrer<span class="string">"</span></span><br><span class="line"><span class="string">   &gt;</span></span><br><span class="line"><span class="string">     en-US</span></span><br><span class="line"><span class="string">   &lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/header&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;</span></span><br><span class="line"><span class="string">   &lt;/IntlProvider&gt;</span></span><br><span class="line"><span class="string"> );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default App;</span></span><br></pre></td></tr></table></figure><p>en-US.json</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">"welcome"</span>: <span class="string">"Hello world!"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="青铜时期">青铜时期</h4><p>前面分析了“提取文案”的过程本质上是在重复劳动，那我们看看有没有办法进行改进。我们可以先对比一下“无国际化需求”和“有国际化需求”时的前端开发流程。如图所示：</p><p><img src="http://qiniu.xueshiming.cn/%E9%9D%92%E9%93%9C%E6%97%B6%E6%9C%9F1" alt="图"></p><p>可以看出右边多了三个过程：</p><ol><li>将文案提取为变量</li><li>为变量命名，要合乎其场景</li><li>将变量和文案信息存到资源文件</li></ol><p>这里我们提出一个期望或愿景：希望能像开发普通业务一样去开发有国际化需求的业务！</p><p>为了达成这一愿景，我们需要有一个工具：它能够扫描指定的文件，并能识别出文件中的字符串，然后能根据字符串的含义生成变量名，并用变量表达式替换掉原来的字符串，最后能够将提取出来的变量自动追加到资源文件中。</p><p>如何实现这样的工具？我们可以用 Babel 将js文件解析为一颗语法树，然后遍历并找出字符串节点，接下来调用 Google Cloud Translation API 将字符串翻译为英文，并以此作为变量名得到变量表达式，最后用变量表达式替换掉原来的文本即可。如下图所示：</p><p><img src="http://qiniu.xueshiming.cn/%E9%9D%92%E9%93%9C%E6%97%B6%E6%9C%9F2" alt="图"></p><p>幸运的是，<a href="https://github.com/ProtoTeam/i18n-pick" target="_blank" rel="noopener">i18n-pick</a> 已经有那么点味道了~</p><p><img src="http://qiniu.xueshiming.cn/%E9%9D%92%E9%93%9C%E6%97%B6%E6%9C%9F3" alt="图"></p><ul><li>分析 这是站在开发层面，对前端开发体验和开发效率提出的改进办法，<strong>将重复的事情交给程序去完成。</strong></li></ul><h4 id="黄金时期">黄金时期</h4><p>有了石器时期的生产方式作为铺垫，我们可以在此基础上继续做改进。既然“前端开发”和“翻译团队”之间依赖的太重，那我们可以在中间加一个节点“文案配置平台”。前端将提取的文案直接上传到“文案配置平台”，翻译团队直接在“文案配置平台”上进行文案翻译，前端直接从“文案配置平台”获取翻译后的最新文案。</p><p><img src="http://qiniu.xueshiming.cn/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3" alt="图"></p><ul><li><p>文案配置平台应当具备的基本能力</p><ol><li>面向前端开发人员：文案录入、输出</li><li>面向翻译团队：文案翻译、发布</li><li>其他：文案版本控制</li></ol></li><li><p>适用场景</p><ol><li>有大量的国际化业务需求</li><li>希望将其沉淀为通用能力平台，提升业务开发效率</li></ol></li><li><p>分析<br>这是从架构层面对国际化开发方式进行优化和提效，一般大的互联网公司因为其自身业务的复杂度，都早已沉淀出很多的通用能力平台。</p></li></ul><h3 id="总结">总结</h3><p>以上每种思路都有各自适用的场景，实际生产中需要从开发成本、开发体验、后期维护、能力沉淀等多维度进行考虑。这篇文章旨在抛砖引玉打开思路，各位看官可以将自己的思路抛出来一起讨论。</p><h3 id="参考">参考</h3><ul><li><a href="https://www.w3.org/standards/webdesign/i18n" target="_blank" rel="noopener">Internationalization</a></li><li><a href="https://zhuanlan.zhihu.com/p/47864242" target="_blank" rel="noopener">国际化 - 通用 LTR/RTL 布局解决方案</a></li><li><a href="https://github.com/ProtoTeam/i18n-pick" target="_blank" rel="noopener">i18n-pick</a></li><li><a href="https://github.com/brigand/babel-plugin-handbook/blob/master/translations/zh-Hans/README.md#visitors" target="_blank" rel="noopener">Babel 插件开发指南</a></li><li><a href="https://github.com/googleapis/nodejs-translate" target="_blank" rel="noopener">Google Cloud Translation API: Node.js Client</a></li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 生命周期管理</title>
      <link href="/2018/10/31/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2018/10/31/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>你有没有遇到过这样的问题: setState应该写在哪里？我们应该什么时候去获取后台的数据？怎样减少页面不必要的渲染？带着问题我们一起来回顾一下React生命周期那些知识点</p></blockquote><a id="more"></a><h2 id="生命周期">生命周期</h2><p>我们先看下面的图建立一个React组件生命周期的直观认识，图为React 16的生命周期，总的来说React组件的生命周期分为三个部分: <code>挂载(Mounting)</code> ，<code>更新(Updating)</code> 和 <code>卸载(Unmounting)</code> ，React16 多出来一个componentDidCatch() 函数用于捕捉错误。知道什么时候去使用哪些生命周期函数对于掌握和理解React是非常重要的，你可以看到这些生命周期函数有一定的规律，比如在某件事情发生之前调用的会用xxxWillxxx，而在这之后发生的会用xxxDidxxx。</p><p><img src="http://qiniu.xueshiming.cn/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="code"></p><p>接下来我们就这三个阶段分别介绍一下各个生命周期函数，详细的生命周期函数解释可以看官方文档  <a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a></p><h3 id="挂载-4个">挂载（4个）</h3><blockquote><p>当组件实例创建并插入 DOM 时，其生命周期调用顺序如下：</p></blockquote><ul><li><a href="https://reactjs.org/docs/react-component.html#constructor" target="_blank" rel="noopener">constructor()</a></li><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops" target="_blank" rel="noopener">static getDerivedStateFromProps()</a></li><li><a href="https://reactjs.org/docs/react-component.html#render" target="_blank" rel="noopener">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidmount" target="_blank" rel="noopener">componentDidMount()</a></li></ul><h4 id="constructor-props">constructor(props)</h4><ul><li>如果不初始化 state 或不进行方法绑定， 则不需要为 React 组件实现构造函数。在 React 组件挂载之前，会调用他的构造函数。再为 React.Component 子类 实现构造函数时，需要首先调用 super(props)，否则，this.props 在构造函数中出现未定义的 bug。</li><li>构造函数主要是初始化 <strong>state</strong> 和为 <strong>事件处理函数</strong> 绑定实例。</li><li>在 constructor 内不要调用 <strong>setState()</strong>，也不要做任何订阅。</li></ul><p>一个示例 constructor 实现如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">  <span class="keyword">super</span>(props);</span><br><span class="line">  <span class="keyword">this</span>.state = &#123;</span><br><span class="line">    color: <span class="string">'#fff'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不需要初始化状态也不需要绑定handle函数的this，那么你可以不实现constructor函数，由默认实现代替。</p><h4 id="static-getderivedstatefromprops-props-state">static getDerivedStateFromProps(props, state)</h4><p>这个函数会在每次渲染前都调用，让组件在 props 变化时更新 state ，返回null则说明不需要更新state。</p><p>该方法主要用来替代 componentWillReceiveProps 方法，willReceiveProp s经常被误用，导致了一些问题，因此在新版本中被标记为unsafe。以<a href="https://juejin.im/post/5abf4a09f265da237719899d" target="_blank" rel="noopener">掘金</a>上的🌰为例，componentWillReceiveProps的常见用法如下，根据传进来的属性值判断是否要load新的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.currentRow !== nextProps.currentRow) &#123;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 检测到变化后更新状态、并请求数据 --&gt;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        isScrollingDown: nextProps.currentRow &gt; <span class="keyword">this</span>.props.currentRow,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">this</span>.loadAsyncData()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadAsyncData() &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个方法的一个问题是外部组件多次频繁更新传入多次不同的 props，而该组件将这些更新 batch 后仅仅触发单次自己的更新，这种写法会导致不必要的异步请求，相比下来getDerivedStateFromProps 配合componentDidUpdate 的写法如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: <span class="literal">false</span>,</span><br><span class="line">    lastRow: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 不再提供 prevProps 的获取方式 --&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextProps.currentRow !== prevState.lastRow) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        isScrollingDown: nextProps.currentRow &gt; prevState.lastRow,</span><br><span class="line">        lastRow: nextProps.currentRow,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认不改动 state --&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line"></span><br><span class="line">     &lt;!-- 仅在更新触发后请求数据 --&gt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loadAsyncData()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadAsyncData() &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式只在更新触发后请求数据，相比下来更节省资源。</p><blockquote><p>注意 getDerivedStateFromProps 是一个 static 方法，意味着拿不到实例的 this</p></blockquote><h4 id="render">render()</h4><blockquote><p>该方法在一个 React 组件中是必须实现的</p></blockquote><p>这是 React 组件的核心方法，用于根据状态 state 和属性 props 渲染一个 React 组件。我们应该保持该方法的纯洁性，这会让我们的组件更易于理解，只要 state 和 props 不变，每次调用 render 返回的结果应当相同，所以 <strong>请不要在render方法中改变组件状态，也不要在在这个方法中和浏览器直接交互。</strong></p><h4 id="componentdidmount">componentDidMount()</h4><p>componentDidMount 方法会在 render 方法之后立即被调用，该方法在整个 React 生命周期中<strong>只会被调用一次</strong>。React 的组件树是一个树形结构，此时你可以认为这个组件以及他下面的所有子组件都已经渲染完了，所以在这个方法中你可以调用和真实DOM相关的操作了。有些组件的启动工作是依赖 DOM 的，例如动画的启动。</p><p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅</p><p>我们可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 等情况下，你可以使用此方式处理。</p><p>下面的代码演示了如何在componentDidMount加载数据并设置状态:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'componentDidMount'</span>);</span><br><span class="line">   fetch(<span class="string">"https://api.github.com/search/repositories?q=language:java&amp;sort=stars"</span>)</span><br><span class="line">     .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">     .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">         <span class="keyword">this</span>.setState(&#123; <span class="comment">// 触发render</span></span><br><span class="line">           items: result.items</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;)</span><br><span class="line">     .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123; <span class="built_in">console</span>.log(error)&#125;);</span><br><span class="line">   <span class="comment">// this.setState(&#123;color: xxx&#125;) // 不要这样做</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="更新-5个">更新（5个）</h3><blockquote><p>当组件的 props 和 state 发生变化的时候会触发更新</p></blockquote><ul><li><a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops" target="_blank" rel="noopener">static getDerivedStateFromProps()</a>  上文已描述，不赘述</li><li><a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate" target="_blank" rel="noopener">shouldComponentUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#render" target="_blank" rel="noopener">render()</a> 上文已描述，不赘述</li><li><a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate" target="_blank" rel="noopener">getSnapshotBeforeUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidupdate" target="_blank" rel="noopener">componentDidUpdate()</a></li></ul><h4 id="shouldcomponentupdate-nextprops-nextstate">shouldComponentUpdate(nextProps, nextState)</h4><p>你可以用这个方法来告诉React是否要进行下一次render()，默认这个函数放回 true，即每次更新状态和属性的时候都进行组件更新。注意这个函数如果返回false并不会导致子组件也不更新。</p><p>这个钩子函数一般不需要实现, 如果你的组件性能比较差或者渲染比较耗时，你可以考虑使 React.PureComponent 重新实现该组件，PureComponent 默认实现了一个版本的shouldComponentUpdate 会进行 state 和 props 的比较。当然如果你有自信，可以自己实现比较 nextProps 和 nextState 是否发生了改变。</p><p>该函数通常是优化性能的紧急出口，是个大招，不要轻易用，如果要用可以参考<a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a> .</p><h4 id="getsnapshotbeforeupdate-prevprops-prevstate">getSnapshotBeforeUpdate(prevProps, prevState)</h4><p>该方法的触发时间为 update 发生的时候，在 render 之后 dom 渲染之前返回一个值，此生命周期的任何返回值将作为参数传递，作为 componentDidUpdate 的第三个参数。该函数与 componentDidUpdate 一起使用可以取代 componentWillUpdate 的所有功能，比如以下是官方的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// 我们是否在 list 中添加新的 items ？</span></span><br><span class="line">    <span class="comment">// 捕获滚动​​位置以便我们稍后调整滚动位置。</span></span><br><span class="line">    <span class="keyword">if</span> (prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      <span class="keyword">return</span> list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    <span class="comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span></span><br><span class="line">    <span class="comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span></span><br><span class="line">    <span class="comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span></span><br><span class="line">    <span class="keyword">if</span> (snapshot !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents... */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在上述示例中，重点是从 getSnapshotBeforeUpdate 读取 scrollHeight 属性，<br>因为 “render” 阶段生命周期（如 render）和<br>“commit” 阶段生命周期（如 getSnapshotBeforeUpdate 和 componentDidUpdate）之间可能存在延迟。</p><h4 id="componentdidupdate-prevprops-prevstate-snapshot">componentDidUpdate(prevProps, prevState, snapshot)</h4><p>该方法会在更新后会被立即调用。首次渲染不会执行此方法。</p><p>当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p><p>如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123;</span><br><span class="line">  <span class="keyword">if</span>(prevProps.myProps !== <span class="keyword">this</span>.props.myProp) &#123;</span><br><span class="line">    <span class="comment">// 典型用法（不要忘记比较 props）：</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.userID !== prevProps.userID) &#123;</span><br><span class="line">        <span class="keyword">this</span>.fetchData(<span class="keyword">this</span>.props.userID);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。</strong></p><h3 id="卸载-1个">卸载（1个）</h3><p>卸载期间是指组件被从DOM树中移除时，调用的相关方法为:</p><ul><li><a href="https://zh-hans.reactjs.org/docs/react-component.html#componentwillunmount" target="_blank" rel="noopener">componentWillUnmount()</a></li></ul><h4 id="componentwillunmount">componentWillUnmount()</h4><p>该方法会在组件被卸载之前被调用。你可以在这个函数中进行相关清理工作，比如删除定时器之类的，取消网络请求或清除在 componentDidMount() 中创建的订阅等</p><p>下面给个示例代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除timer</span></span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID1);</span><br><span class="line">    clearTimeout(<span class="keyword">this</span>.timerID2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">this</span>.myWebsocket.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消消息订阅...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="错误捕获">错误捕获</h3><p>React16中新增了一个生命周期函数:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentdidcatch" target="_blank" rel="noopener">componentDidCatch()</a></li></ul><h4 id="componentdidcatch-error-info">componentDidCatch(error, info)</h4><p>在 react 组件中如果产生的错误没有被捕获会被抛给上层组件，如果上层也不处理的话就会抛到顶层导致浏览器白屏错误，在 React16 中我们可以实现这个方法来捕获子组件产生的错误，然后在父组件中妥善处理，比如搞个弹层通知用户网页崩溃等。</p><p>在这个函数中请只进行错误恢复相关的处理，不要做其他流程控制方面的操作。比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromError(error) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染可以显示降级 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// "组件堆栈" 例子:</span></span><br><span class="line">    <span class="comment">//   in ComponentThatThrows (created by App)</span></span><br><span class="line">    <span class="comment">//   in ErrorBoundary (created by App)</span></span><br><span class="line">    <span class="comment">//   in div (created by App)</span></span><br><span class="line">    <span class="comment">//   in App</span></span><br><span class="line">    logComponentStackToMyService(info.componentStack);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// 你可以渲染任何自定义的降级 UI</span></span><br><span class="line">      <span class="keyword">return</span> &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="react16中的生命周期函数变化">React16中的生命周期函数变化</h3><p>componentWillMount(直接在 componentDidMount 中即可)，componentWillUpdate( componentDidUpdate + getSnapshotBeforeUpdate ),<br>componentWillReceiveProps（ getDerivedStateFromProps + componentDidUpdate ） 等生命周期方法在下个主版本中会被废弃?<br>根据这份<a href="https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md" target="_blank" rel="noopener">RFC</a>，是的，这些生命周期方法被认为是不安全的，在React16中被重命名为 UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，而在更下个大版本中他们会被废弃。详见<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" target="_blank" rel="noopener">React 16.3版本发布公告</a>。</p><p><a href="https://www.html.cn/qa/react/14367.html" target="_blank" rel="noopener">为什么废弃</a>？从上面的生命周期的图中可以看出，被废弃的三个函数都是在render之前，因为fiber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。</p><p><a href="https://juejin.im/post/5ae6cd96f265da0b9c106931" target="_blank" rel="noopener">React v16.3 版本新生命周期函数浅析及升级方案</a></p><h3 id="总结">总结</h3><p>总结一下，以上讲的这些生命周期都有自己存在的意义，但在 React 使用过程中我们最常用到的生命周期函数是如下几个:</p><ul><li>constructor: 初始化状态，进行函数绑定</li><li>componentDidMount: 进行DOM操作，进行异步调用初始化页面</li><li>componentWillReceiveProps: 根据props更新状态</li><li>componentWillUnmount: 清理组件定时器，网络请求或者相关订阅等<br>其他的逻辑一般和用户的操作有关(各种handleClickXXXX），当然需要用到其他生命周期函数可以按需正确使用。如果阅读文章过程中遇到问题欢迎评论进行修正。</li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序探险指南（一）</title>
      <link href="/2018/10/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A2%E9%99%A9%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/10/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A2%E9%99%A9%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>终于有时间去详细了解一下小程序了，下面我们就从HelloWorld开始，走近小程序，一探究竟。</p></blockquote><a id="more"></a><h3 id="准备工作">准备工作</h3><ul><li><p>注册小程序账号<br>要想开始开发小程序我们需要完成以下流程：</p><p><img src="http://qiniu.xueshiming.cn/%E7%94%B3%E8%AF%B7%E8%B4%A6%E5%8F%B7.png" alt="开发前准备工作"></p></li><li><p>安装微信开发者工具<br>包含</p><p>Windows 64位 / Windows 32位 / Mac OS</p><blockquote><p>Windows 仅支持 Windows 7 及以上版本。</p></blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">安装地址请戳</a></p></li></ul><p><img src="http://qiniu.xueshiming.cn/%E5%AE%89%E8%A3%85.png" alt="开发工具安装"></p><ul><li>使用微信开发者工具</li></ul><p>初始界面：</p><p><img src="http://qiniu.xueshiming.cn/useTool.png" alt="使用开发工具"></p><p>编译器界面：<br>分为一下几栏：<br><code>模拟器</code>：<br>微信开发者工具是支持实时调试的，左边就相当于模拟器，可以看到代码最新的效果，很方便。</p><p><code>代码编辑区</code>：<br>当然是在这个编写小程序代码啦。</p><p><code>调试区</code>：<br>十分像chrom浏览器的调试栏，调试程序，查看网络请求等。</p><p><code>远程调试</code>：<br>这是微信小程序开发者最喜欢的一个功能，直接可以在真机上模拟效果。</p><p><img src="http://qiniu.xueshiming.cn/%E7%BC%96%E8%AF%91%E5%99%A8%E7%95%8C%E9%9D%A2.png" alt="使用开发工具"></p><ul><li>小程序版本<br>从最初的开发到最后小程序发布上线，我们需要经历一下几个版本：</li></ul><p><img src="http://qiniu.xueshiming.cn/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC.png" alt="小程序版本"></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Symbol对象</title>
      <link href="/2018/09/19/Symbol%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/09/19/Symbol%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>称符号对象，是es2015(也就是es6)中新添加的数据类型。通过Symbol()可以得到一个唯一的值，所以这个值很适合做标识符。</p></blockquote><a id="more"></a><h3 id="概念">概念</h3><p>Symbol() function 返回一个类型为symbol的值，Symbol有静态属性，原型上也有methods，但是缺少constructor，所以你不能<code>new Symbol()</code>来执行；</p><blockquote><p>引用官方翻译，符号是一种特殊的、不可变的数据类型，它可以作为对象属性的标识符使用。符号对象是一个对的符号原始数据类型的隐式对象包装器。</p></blockquote><ul><li>类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(); // Symbol中参数为字符串，用来描述。</span><br><span class="line">console.log(typeof sym); //&quot;symbol&quot;</span><br></pre></td></tr></table></figure><ul><li>唯一性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;abc&apos;);</span><br><span class="line">const sym2 = Symbol(&apos;cba&apos;);</span><br><span class="line">console.log(sym1,sym2); //Symbol(abc) Symbol(cba)</span><br><span class="line">//参数的作用就是描述，便于调试</span><br><span class="line">console.log(sym1.toString()) //&apos;Symbol(abc)&apos;</span><br></pre></td></tr></table></figure><ul><li>new关键字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sym = new Symbol(); // TypeError</span><br></pre></td></tr></table></figure><h3 id="获取symbol类型值的三种方式">获取symbol类型值的三种方式</h3><ul><li>通过Symbol对象</li></ul><blockquote><p>也就是前面说的  let sym = Symbol();得到一个为一个的symbol值</p></blockquote><ul><li>Symbol.for(string)</li></ul><blockquote><p>可以注册一个symbol，再次调用Symbol.for(string)会得到这个symbol值，区别于Symbol()是唯一的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&apos;abc&apos;);</span><br><span class="line">const sym1 = Symbol.for(&apos;abc&apos;);</span><br><span class="line">console.log(sym === sym1); //false</span><br><span class="line">console.log(sym1 === Symbol.for(&apos;abc&apos;)); //true</span><br></pre></td></tr></table></figure><p>-Symbol.iterator</p><blockquote><p>这个比较特别，得到的也是symbol类型的值，是es6中提出用到对象中，被for…of遍历所用，下面将进行详细介绍。</p></blockquote><p>由于这个值是标准规范提出，用于每个object中，所以应该是固定的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol.iterator === Symbol.iterator); //true</span><br></pre></td></tr></table></figure><h3 id="用途">用途</h3><blockquote><p>在我看来，symbol更多是应用于es6规范中，由于它的值唯一的特性，可以解决变量名，属性名冲突的问题，并切Symbol提出了一些属性和方法，用于过渡以及实现一些特殊的用途，比如对象的迭代器，instanceof的拓展等等。</p></blockquote><ul><li>栗子。像我们项目中大量的使用常量定义字符串，尤其是react+redux的项目中，我觉得用Symbol就不错。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const GETLIST_SUCCESS = Symbol(&apos;get-list-success&apos;);</span><br><span class="line"></span><br><span class="line">const getList = () =&gt; dispatch(&#123;</span><br><span class="line">   type: GETLIST_SUCCESS</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line">const list = function(state = &#123;&#125;, action) &#123;</span><br><span class="line">  switch(action.type):</span><br><span class="line">    case GETLIST_SUCCESS:</span><br><span class="line">      // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我这里只是举一个例子，这种标识性的Symbol可以用的地方。大家可以不必关注redux。</p></blockquote><ul><li>另外，Symbol值可以做为对象的key值，这样就能保证不会出现同名的属性名，防止对象属性被覆盖。下面我们将介绍Symbol作为属性名的写法。</li></ul><h3 id="作为对象的key">作为对象的key</h3><ul><li>对象[]方括号的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">const sym = Symbol();</span><br><span class="line">obj[sym] = &apos;syj&apos;;</span><br></pre></td></tr></table></figure><ul><li>对象内部定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  [sym]: &apos;syj&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Object.defineProperty定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line">const obj = Object.defineProperty(&#123;&#125;, sym, &#123;</span><br><span class="line">  enumerable: true, //可枚举</span><br><span class="line">  writable: true,  //可赋值运算符改变</span><br><span class="line">  configurable: true, //可改变，可删除</span><br><span class="line">  value: &apos;syj&apos;</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，symbol作为属性名不能通过 . 的形式添加。</p></blockquote><p>通过上述三种方式，我们就可以向对象添加key不会重复的symbol值了。意味着我们可以创建非字符串类型的属性名称，以防止使用常规手段来探查这些名称。</p><ul><li>symbol类型的key的遍历</li></ul><blockquote><p>当我们用symbol设置了对象的key以后，他是不会被之前的for…in，Object.keys()遍历出来的，需要用Object.getOwnPropertySymbols()获取，得到一个所有这个对象中的symbol属性名的数组。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;1&apos;);</span><br><span class="line">const sym2 = Symbol(&apos;2&apos;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [sym1]: &apos;syj&apos;,</span><br><span class="line">  [sym2]: &apos;fy&apos;</span><br><span class="line">&#125;</span><br><span class="line">const ary = Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(ary); //[ Symbol(1), Symbol(2) ]</span><br></pre></td></tr></table></figure><h3 id="内置的symbol值">内置的Symbol值</h3><ul><li>对象[]方括号的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">const sym = Symbol();</span><br><span class="line">obj[sym] = &apos;syj&apos;;</span><br></pre></td></tr></table></figure><ul><li>对象内部定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  [sym]: &apos;syj&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Object.defineProperty定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line">const obj = Object.defineProperty(&#123;&#125;, sym, &#123;</span><br><span class="line">  enumerable: true, //可枚举</span><br><span class="line">  writable: true,  //可赋值运算符改变</span><br><span class="line">  configurable: true, //可改变，可删除</span><br><span class="line">  value: &apos;syj&apos;</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，symbol作为属性名不能通过 <figure class="highlight plain"><figcaption><span>``` 的形式添加。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过上述三种方式，我们就可以向对象添加key不会重复的symbol值了。意味着我们可以创建非字符串类型的属性名称，以防止使用常规手段来探查这些名称。</span><br><span class="line"></span><br><span class="line">- symbol类型的key的遍历</span><br><span class="line"></span><br><span class="line">&gt;当我们用symbol设置了对象的key以后，他是不会被之前的for...in，Object.keys()遍历出来的，需要用Object.getOwnPropertySymbols()获取，得到一个所有这个对象中的symbol属性名的数组。</span><br></pre></td></tr></table></figure></p></blockquote><p>const sym1 = Symbol(‘1’);<br>const sym2 = Symbol(‘2’);<br>const obj = {<br>[sym1]: ‘syj’,<br>[sym2]: ‘fy’<br>}<br>const ary = Object.getOwnPropertySymbols(obj);<br>console.log(ary); //[ Symbol(1), Symbol(2) ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 内置的Symbol值</span><br><span class="line"></span><br><span class="line">&gt;JavaScript内建的一些在 ECMAScript 5 之前没有暴露给开发者的符号，它们代表语言的内部行为。</span><br><span class="line"></span><br><span class="line">- Symbol.iterator属性</span><br><span class="line"></span><br><span class="line">我觉得是最重要的属性，它的提出使对象可以使用迭代器遍历，之前只有Array,String等，这种内置Symbol.iterator属性的可以使用迭代器。ECMAScript旨在使JS中使用一种方法,比如for...of就可以遍历序列数据，不需要关注它内部的数据结构。其实就是JS往C,JAVA语言靠拢的趋势吧。</span><br><span class="line">为了避免此部分过于重，我们后面会专门研究迭代器和生成器。</span><br><span class="line"></span><br><span class="line">- Symbol.hasInstance</span><br><span class="line"></span><br><span class="line">&gt;之前我们用instanceof的时候，比如```a instaceof A```其实就是调用的A对象中的Symbol.hasInstance属性，它指向一个内部方法，现在es6拓展出来，我们可以自己定义啦。</span><br><span class="line"></span><br><span class="line">先看看下面的代码，猜想输出什么？</span><br></pre></td></tr></table></figure><p>class MyClass{<br>static <a href="num">Symbol.hasInstance</a> {<br>return num % 2 === 0<br>}</p><p><a href="num">Symbol.hasInstance</a> {<br>return num % 2 === 0<br>}<br>}<br>console.log(1 instanceof MyClass); // 序号(1)<br>console.log(2 instanceof MyClass); // 序号(2)<br>console.log(2 instanceof new MyClass()); // 序号(3)</p><p>const obj = {<br><a href="obj">Symbol.hasInstance</a> {<br>return num % 2 === 0<br>}<br>}<br>console.log(1 instanceof obj);// 序号(4)</p><pre><code>序号(1) MyClass类上有静态方法[Symbol.hasInstance], 1被当做参数传入function，返回结果false。 序号(2)同理,true。序号(3) 后面是实例化的对象，通过原型链查找到原型上[Symbol.hasInstance]，然后传入2执行，true。序号(4)是普通对象内部存在这个方法，执行返回false。</code></pre>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 高阶组件(repost)</title>
      <link href="/2018/08/23/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6(repost)/"/>
      <url>/2018/08/23/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6(repost)/</url>
      <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>本文代码浅显易懂，思想深入实用。此属于react进阶用法，如果还不是很了解react，建议从文档开始看起。</p></blockquote><a id="more"></a><p>我们都知道高阶函数是什么, 高阶组件其实是差不多的用法，只不过传入的参数变成了react组件，并返回一个新的组件.</p><blockquote><p>A higher-order component is a function that takes a component and returns a new component.</p></blockquote><p>形如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>高阶组件是react应用中很重要的一部分，最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。<br>如果你用过redux，那你就一定接触过高阶组件，因为react-redux中的connect<br>就是一个高阶组件。</p><p>另外本次demo代码都放在 <a href="https://github.com/sunyongjian/hoc-demo" target="_blank" rel="noopener">hoc-demo</a></p><h3 id="引入">引入</h3><p>先来一个最简单的高阶组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">'./simple-hoc'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default simpleHoc(Usual);</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> simpleHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'simpleHoc'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default simpleHoc;</span><br></pre></td></tr></table></figure><p>组件Usual通过simpleHoc的包装，打了一个log… 那么形如simpleHoc就是一个高阶组件了，通过接收一个组件class Usual，并返回一个组件class。 其实我们可以看到，在这个函数里，我们可以做很多操作。 而且return的组件同样有自己的生命周期，function，另外，我们看到也可以把props传给WrappedComponent(被包装的组件)。 高阶组件的定义我都是用箭头函数去写的，如有不适请参照<br><a href="https://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">arrow function</a></p><h3 id="装饰器模式">装饰器模式</h3><p>高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种</p><p>ES7中添加了一个decorator的属性，使用@符表示，可以更精简的书写。那上面的例子就可以改成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> simpleHoc <span class="keyword">from</span> <span class="string">'./simple-hoc'</span>;</span><br><span class="line"></span><br><span class="line">@simpleHoc</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>是同样的效果。<br>当然兼容性是存在问题的，通常都是通过babel去编译的。 babel提供了plugin，高阶组件用的是类装饰器，所以用 <code>transform-decorators-legacy</code></p><h2 id="两种形式">两种形式</h2><h3 id="属性代理">属性代理</h3><p>引入里我们写的最简单的形式，就是属性代理(Props Proxy)的形式。通过hoc包装wrappedComponent，也就是例子中的Usual，本来传给Usual的props，都在hoc中接受到了，也就是props proxy。 由此我们可以做一些操作</p><ul><li>操作props<br>最直观的就是接受到props，我们可以做任何读取，编辑，删除的很多自定义操作。包括hoc中定义的自定义事件，都可以通过props再传下去。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> propsProxyHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;WrappedComponent</span><br><span class="line">      &#123;...this.props&#125;</span><br><span class="line">      handleClick=&#123;this.handleClick&#125;</span><br><span class="line">    /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default propsProxyHoc;</span><br></pre></td></tr></table></figure><p>然后我们的Usual组件render的时候, console.log(this.props) 会得到handleClick。</p><ul><li>refs获取组件实例<br>当我们包装Usual的时候，想获取到它的实例怎么办，可以通过引用(ref),在Usual组件挂载的时候，会执行ref的回调函数，在hoc中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> refHoc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.instanceComponent, <span class="string">'instanceComponent'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;WrappedComponent</span><br><span class="line">      &#123;...this.props&#125;</span><br><span class="line">      ref=&#123;instanceComponent =&gt; this.instanceComponent = instanceComponent&#125;</span><br><span class="line">    /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default refHoc;</span><br></pre></td></tr></table></figure><ul><li>这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递   给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件<a href="https://reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener">文档</a>，即把input都做成受控的，改变value的时候，用onChange事件同步到state中。当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较。看一下代码就知道怎么回事了：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通组件Login</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> formCreate <span class="keyword">from</span> <span class="string">'./form-create'</span>;</span><br><span class="line"></span><br><span class="line">@formCreate</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label id=<span class="string">"username"</span>&gt;</span><br><span class="line">            账户</span><br><span class="line">          &lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">          &lt;input name="username" &#123;...this.props.getField('username')&#125;/</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &lt;label id="password"&gt;</span></span><br><span class="line"><span class="regexp">            密码</span></span><br><span class="line"><span class="regexp">          &lt;/</span>label&gt;</span><br><span class="line">          &lt;input name=<span class="string">"password"</span> &#123;...this.props.getField(<span class="string">'password'</span>)&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div onClick=&#123;this.props.handleSubmit&#125;&gt;提交&lt;/</span>div&gt;</span><br><span class="line">        &lt;div&gt;other content&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//HOC</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formCreate = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      fields: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange = <span class="function"><span class="params">key</span> =&gt;</span> e =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      fields: &#123;</span><br><span class="line">        ...this.state.fields,</span><br><span class="line">        [key]: e.target.value,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.fields);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getField = <span class="function"><span class="params">fieldName</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      onChange: <span class="keyword">this</span>.onChange(fieldName),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleSubmit: <span class="keyword">this</span>.handleSubmit,</span><br><span class="line">      getField: <span class="keyword">this</span>.getField,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (&lt;WrappedComponent</span><br><span class="line">      &#123;...props&#125;</span><br><span class="line">    /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default formCreate;</span><br></pre></td></tr></table></figure><p>这里我们把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。</p><h3 id="反向继承">反向继承</h3><p>反向继承(Inheritance Inversion)，简称II，本来我是叫继承反转的…因为有个模式叫控制反转嘛…<br>跟属性代理的方式不同的是，II采用通过 去继承WrappedComponent，本来是一种嵌套的关系，结果II返回的组件却继承了WrappedComponent，这看起来是一种反转的关系。<br>通过继承WrappedComponent，除了一些静态方法，包括生命周期，state，各种function，我们都可以得到。上栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usual</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> iiHoc <span class="keyword">from</span> <span class="string">'./ii-hoc'</span>;</span><br><span class="line"></span><br><span class="line">@iiHoc</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line">   <span class="keyword">super</span>();</span><br><span class="line">   <span class="keyword">this</span>.state = &#123;</span><br><span class="line">     usual: <span class="string">'usual'</span>,</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'didMount'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       Usual</span><br><span class="line">     &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   )</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/IIHOC</span></span><br><span class="line"><span class="regexp">import React from 'react';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const iiHoc = WrappedComponent =&gt; class extends WrappedComponent &#123;</span></span><br><span class="line"><span class="regexp">   render() &#123;</span></span><br><span class="line"><span class="regexp">     console.log(this.state, 'state');</span></span><br><span class="line"><span class="regexp">     return super.render();</span></span><br><span class="line"><span class="regexp">   &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default iiHoc;</span></span><br></pre></td></tr></table></figure><p>iiHoc return的组件通过继承，拥有了Usual的生命周期及属性，所以didMount会打印，state也通过constructor执行，得到state.usual。<br>其实，你还可以通过II：</p><ul><li>渲染劫持<br>这里HOC里定义的组件继承了WrappedComponent的render(渲染)，我们可以以此进行hijack(劫持)，也就是控制它的render函数。栗子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hijack-hoc</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hijackRenderHoc = <span class="function"><span class="params">config</span> =&gt;</span> WrappedComponent =&gt; <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; style = &#123;&#125; &#125; = config;</span><br><span class="line">    <span class="keyword">const</span> elementsTree = <span class="keyword">super</span>.render();</span><br><span class="line">    <span class="built_in">console</span>.log(elementsTree, <span class="string">'elementsTree'</span>);</span><br><span class="line">    <span class="keyword">if</span> (config.type === <span class="string">'add-style'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &lt;div style=&#123;&#123;...style&#125;&#125;&gt;</span><br><span class="line">        &#123;elementsTree&#125;</span><br><span class="line">      &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementsTree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> hijackRenderHoc;</span><br><span class="line"><span class="comment">//usual</span></span><br><span class="line">@hijackRenderHoc(&#123;<span class="attr">type</span>: <span class="string">'add-style'</span>, <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span>&#125;&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里通过二阶函数，把config参数预制进HOC， 算是一种柯理化的思想。<br>栗子很简单，这个hoc就是添加样式的功能。但是它暴露出来的信息却不少。首先我们可以通过config参数进行逻辑判断，有条件的渲染，当然这个参数的作用很多，react-redux中的connect不就是传入了props-key 嘛。再就是我们还可以拿到WrappedComponent的元素树，可以进行修改操作。最后就是我们通过div包裹，设置了style。但其实具体如何操作还是根据业务逻辑去处理的…<br><img src="http://qiniu.xueshiming.cn/%E5%85%83%E7%B4%A0%E6%A0%91.png" alt="元素树"></p><h3 id="我的应用场景">我的应用场景</h3><ul><li><p>通常我会通过高阶组件去优化之前老项目写的不好的地方，比如两个页面UI几乎一样，功能几乎相同，仅仅几个操作不太一样，却写了两个耦合很多的页面级组件。当我去维护它的时候，由于它的耦合性过多，经常会添加一个功能(这两个组件都要添加)，我要去改完第一个的时候，还要改第二个。而且有时候由于我的记性不好，会忘掉第二个… 就会出现bug再返工。更重要的是由于个人比较懒，不想去重构这部分的代码，因为东西太多了，花费太多时间。所以加新功能的时候，我会写一个高阶组件，往HOC里添加方法，把那两个组件包装一下，也就是属性代理。这样新代码就不会再出现耦合，旧的逻辑并不会改变，说不定哪天心情好就会抽离一部分功能到HOC里，直到理想的状态。</p></li><li><p>另一种情况就是之前写过一个组件A，做完上线，之后产品加了一个新需求，很奇怪要做的组件B跟A几乎一模一样，但稍微有区别。那我可能就通过II的方式去继承之前的组件A，比如它在didMount去fetch请求，需要的数据是一样的。不同的地方我就会放到HOC里，存储新的state这样，再通过劫持渲染，把不同的地方，添加的地方进行处理。但其实这算Hack的一种方式，能快速解决问题，也反映了组件设计规划之初有所不足(原因比较多)。</p></li><li><p>Container解决不了的时候甚至不太优雅的时候。其实大部分时候包一层Container组件也能做到差不多的效果，比如操作props，渲染劫持。但其实还是有很大区别的。比如我们现在有两个功能的container，添加样式和添加处理函数的，对Usual进行包装。栗子：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usual</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Usual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      Usual</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Usual;</span><br><span class="line"><span class="comment">//console - Object &#123;handleClick: function&#125;  "props"</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Usual <span class="keyword">from</span> <span class="string">'./usual'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StyleContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;div style=&#123;&#123; color: '#76d0a3' &#125;&#125;&gt;</span><br><span class="line">      &lt;div&gt;container&lt;/div&gt;</span><br><span class="line">      &lt;Usual &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default StyleContainer;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> StyleContainer <span class="keyword">from</span> <span class="string">'./container-add-style'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncContainer</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: <span class="keyword">this</span>.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (&lt;StyleContainer &#123;...props&#125; /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default FuncContainer;</span><br></pre></td></tr></table></figure><p>外层Container必须要引入内层Container，进行包装，还有props的传递，同样要注意包装的顺序。当然你可以把所有的处理都放到一个Container里。那用HOC怎么处理呢，相信大家有清晰的答案了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFunc = <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: <span class="keyword">this</span>.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const addStyle = WrappedComponent =&gt; class extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;div style=&#123;&#123; color: '#76d0a3' &#125;&#125;&gt;</span><br><span class="line">      &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line">class WrappedUsual extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.props, 'props');</span><br><span class="line">    return (&lt;div&gt;</span><br><span class="line">      &lt;WrappedComponent /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然HOC是更优雅一些的，每个HOC都定义自己独有的处理逻辑，需要的时候只需要去包装你的组件。相较于Container的方式，HOC耦合性更低，灵活性更高，可以自由组合，更适合应付复杂的业务。当然当你的需求很简单的时候，还是用Container去自由组合，应用场景需要你清楚。</p><h3 id="注意点-约束">注意点(约束)</h3><p>其实官网有很多，简单介绍一下。</p><ul><li><p>最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数</p></li><li><p>要给hoc添加class名，便于debugger。我上面的好多栗子组件都没写class 名，请不要学我，因为我实在想不出叫什么名了… 当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。<br><img src="http://qiniu.xueshiming.cn/WrappedUsual.png" alt="WrappedUsual"></p></li><li><p>静态方法要复制<br>无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。</p></li><li><p>refs不会传递。 意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。</p></li><li><p>不要在render方法内部使用高阶组件。简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。也就是如果你每次返回的结果都不是一个引用，react以为发生了变化，去更替这个组件会导致之前组件的状态丢失。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC不要放到render函数里面</span></span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">WrappedUsual</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props, <span class="string">'props'</span>);</span><br><span class="line">    <span class="keyword">return</span> (&lt;div&gt;</span><br><span class="line">      &lt;WrappedComponent /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用compose组合HOC。函数式编程的套路… 例如应用redux中的middleware以增强功能。redux-middleware解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addFuncHOC = ...</span><br><span class="line"><span class="keyword">const</span> addStyleHOC = ...<span class="comment">//省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> component =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.lenght === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> last = funcs[funcs.length - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> funcs.reduceRight(<span class="function">(<span class="params">res, cur</span>) =&gt;</span> cur(res), last(component));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedComponent = compose(addFuncHOC, addStyleHOC)(Usual);</span><br></pre></td></tr></table></figure><p>关于注意点，官网有所介绍，不再赘述。链接：<a href="https://reactjs.org/docs/higher-order-components.html#dont-mutate-the-original-component.-use-composition." target="_blank" rel="noopener">reactjs.org</a></p><h3 id="总结">总结</h3><p>高阶组件最大的好处就是解耦和灵活性，在react的开发中还是很有用的。<br>当然这不可能是高阶组件的全部用法。掌握了它的一些技巧，还有一些限制，你可以结合你的应用场景，发散思维，尝试一些不同的用法。</p><p>原文转自：<a href="https://github.com/sunyongjian/blog/issues/25" target="_blank" rel="noopener">blog</a></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Say Hi</title>
      <link href="/2018/07/01/Say%20Hi/"/>
      <url>/2018/07/01/Say%20Hi/</url>
      <content type="html"><![CDATA[<img src="http://qiniu.xueshiming.cn/weget.jpg" width="600" hegiht="400" align="center">Say hi<!-- .emoji{  height: 1.2em;} --><a id="more"></a><p>2018年已经过去一半了<br></p><p>过去的六个月还是很幸运，很美好<br></p><p>和老兄继续并肩作战 <img class="emoji" draggable="false" alt="💯" src="https://twemoji.maxcdn.com/2/72x72/1f4af.png"><br></p><p>工作，继续磨锤子<br></p><p>摄影，买一台单反<br></p><p>健身，首先的有肌肉<br></p><p>烧菜，从番茄炒蛋开始，已经算入门选手了，emm<br></p><p>        继续进阶<br></p><p>读书，读完10本书<br></p><p>旅行 <img class="emoji" draggable="false" alt="🌱" src="https://twemoji.maxcdn.com/2/72x72/1f331.png"> ，黄山-&gt;三亚-&gt;下一站在哪里-&gt;上海-&gt;广州-&gt;珠海</p>]]></content>
      
      <categories>
          
          <category> 展望 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>思忖</title>
      <link href="/2018/06/14/%E6%80%9D%E5%BF%96/"/>
      <url>/2018/06/14/%E6%80%9D%E5%BF%96/</url>
      <content type="html"><![CDATA[<img src="http://qiniu.xueshiming.cn/%E6%80%9D%E5%BF%96.jpg" width="600" hegiht="400" align="center"><p>思忖</p><a id="more"></a><p>这是在黄山等待日出的那一个瞬间<br><br>每个人都在期待着日出<br><br>每个人都想看到这一个美好的瞬间<br></p><!-- 在经历了漫长的寒夜<br/>终于等到日出的那一刻<br/>我的心暖了，所有人的心都暖了<br/>就像遇到一个人，之前的黑夜攒足了力气<br/>就是为了遇到一个像太阳一样的你<br/>就像，太阳期待人们<br/>等它出现在地平线上<br/>人们，也同样期待着太阳<br/>温暖我们的胸膛<br/>然后我们踏着光芒，走向前方 -->]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React和Redux数据流向</title>
      <link href="/2018/03/10/React%E5%92%8CRedux%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91/"/>
      <url>/2018/03/10/React%E5%92%8CRedux%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91/</url>
      <content type="html"><![CDATA[<blockquote><p>简单描述一下action 、reducer、store 三者的关系：</p></blockquote><a id="more"></a><p>使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。<br>store 就是把它们联系到一起的对象<br>用  this.props.dispath  (在页面.jsx文件中)去找一个action(在  Action.jsx  ) ，然后在这个<br>action中包含请求的请求方式:</p><ul><li>查询请求action</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getSelectDdata = <span class="function">(<span class="params">data</span>) =&gt;</span> ActionCreator(API_INIT_POST_MODEL,</span><br><span class="line"><span class="string">'/api/rcslmodelcascade/propertylist$&#123;queryData(data)&#125;'</span>,<span class="string">'GET'</span>)()</span><br></pre></td></tr></table></figure><ul><li>修改请求action</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> editPersional = <span class="function">(<span class="params">data</span>) =&gt;</span> ActionCreator(API_UPDATE_PERSONAL_LIMIT, <span class="string">'/api/rcslmodelprivate'</span>, <span class="string">'PUT'</span>, data)();</span><br></pre></td></tr></table></figure><ul><li>删除请求action</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> detelePersionalLimit = <span class="function">(<span class="params">data</span>) =&gt;</span> ActionCreator(API_DELETE_PERSIONAL_MODEL, <span class="string">'/api/rcslmodelprivate/$&#123;data&#125;'</span>, <span class="string">'DELETE'</span>)();</span><br></pre></td></tr></table></figure><ul><li>添加请求action</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addPersionalLimit = <span class="function">(<span class="params">data</span>) =&gt;</span> ActionCreator(API_POST_PERSIONAL_MODEL, <span class="string">'/api/rcslmodelprivate'</span>, <span class="string">'POST'</span>, data)();</span><br></pre></td></tr></table></figure><p>这时，我们还需要添加一个action Type，来表示用户完成任务的动作。于是在<br><code>ActionType.jsx</code>中就有好多形如：<code>export const API_INIT_POST_MODEL = ['REQUEST', 'POST_MODEL_SUCCESS', 'FAILURE'];</code></p><p>然后到reducer  , reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。在reducer里，你可以<br>用switch定义数据的形式，用来和后台对接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> API_INIT_POST_MODEL[<span class="number">1</span>]:</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      ...state,</span><br><span class="line">      selectData:</span><br><span class="line">       ＿.map(actions.data, (v, k) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: v.value.map(<span class="function">(<span class="params">v, k</span>) =&gt;</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> &#123;</span><br><span class="line">                                labelName: v.name,</span><br><span class="line">                                optionVal: v.value.map(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">                                    <span class="keyword">return</span> &#123;<span class="attr">value</span>: data.code, <span class="attr">name</span>: data.name&#125;</span><br><span class="line">                                &#125;),</span><br><span class="line">                                key: v.code,</span><br><span class="line">                                type: <span class="string">'select'</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;),</span><br><span class="line">                        name: v.name,</span><br><span class="line">                        code: v.code,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;),</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>然后返回新的state给store,在store.jsx文件中，<br>根据已有的 reducer 来创建 store 是非常容易的。我们使用combineReducers() 将多个 reducer 合并成为一个。并通过中间件applyMiddleware 创建store。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> finalCreateStore=composeWithDevTools(applyMiddleware(promiseMiddleware))(createStore)</span><br></pre></td></tr></table></figure><p>Redux store 保存了根 reducer 返回的完整 state 树。然后返回给</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactDom.render(</span><br><span class="line"> &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;history&#125; &gt;</span><br><span class="line">      &#123;routes&#125;</span><br><span class="line">    &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Provider&gt;</span><br><span class="line">）,<span class="built_in">document</span>.getElementById(<span class="string">'content'</span>)</span><br></pre></td></tr></table></figure><p>根节点，然后重新渲染数据</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>升级 Webpack4.0.1</title>
      <link href="/2018/03/04/Webpack4.0%E5%8D%87%E7%BA%A7/"/>
      <url>/2018/03/04/Webpack4.0%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<h3 id="webpack-4介绍">Webpack 4介绍</h3><p>Webpack 4 正式版已发布，Webpack 是一个现代 JavaScript 应用程序的模块打包器 (module bundler) 。<br>当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，<br>然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。</p><h5 id="更新点包括">更新点包括</h5><ol><li>Environment</li></ol><ul><li>不再支持 Node.js 4</li></ul><ol start="2"><li>Usage</li></ol><ul><li>现在可以在两种模式中选择 (mode or --mode) : 生产模式或开发模式</li></ul><ol start="3"><li>Syntax</li></ol><ul><li>import() 总是返回一个命名空间对象。CommonJS 模块被封装到默认导出中</li></ul><a id="more"></a><ol start="4"><li>Configuration</li></ol><ul><li>NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors (生产模式下 默认开启)</li><li>ModuleConcatenationPlugin -&gt; optimization.concatenateModules (开发模式下默认开启)</li><li>NamedModulesPlugin -&gt; optimization.namedModules (开发模式下默认开启)</li><li>CommonsChunkPlugin 已被移 除 -&gt; optimization.splitChunks, optimization.runtimeChun</li></ul><ol start="5"><li>JSON</li></ol><ul><li>webpack 现在能原生地处理 JSON</li><li>允许通过 ESM 语法导入 JSON</li></ul><ol start="6"><li>Optimization</li></ol><ul><li>更新 uglifyjs-webpack-plugin 至 v1 版本，以支持 ES15</li></ul><p>注： 详细更新请看 <a href="https://juejin.im/post/5a951bf851882524d842ec8b" target="_blank" rel="noopener">webpack更新日志</a></p><h3 id="升级过程如下">升级过程如下</h3><ol><li>首先卸载原来的webpack版本，安装最新4.0.1版本</li></ol><ul><li>卸载命令<code>npm uninstall webpack -g</code></li><li>安装命令<code>npm install webpack@4.0.1 -g</code> 或者<code>yarn add webpack@4.0.1</code></li></ul><ol start="2"><li>添加optimization,这时会报错： Cannot find module ‘webpack/bin/config-yargs’</li></ol><ul><li>需要安装<code>webpack-dev-server</code></li><li>首先卸载<code>npm uninstall webpack-dev-server -g</code></li><li>然后再安装<code>yarn add webpack-dev-server@3.0.1-beta.0</code></li></ul><ol start="3"><li>启动项目 <code>yarn run dev</code></li></ol><ul><li>发现提示需要安装<code>webpack-cli</code> (用来启动webpack)</li><li>安装<code>yarn add webpack-cli -D</code></li></ul><ol start="4"><li>然后启动项目你会发现错误信息:<code>...please use config.optimization.splitChunks instead</code>和<br><img src="http://qiniu.xueshiming.cn/instead.png" alt="错误信息"></li></ol><p><code>compilation.mainTemplate.applyPluginsWaterfall is not a function</code></p><p>此时需要,在webpack.config中添加<code>optimization</code></p><p><img src="http://qiniu.xueshiming.cn/optimization.png" alt="optimization"></p><p>运行命令： <code>yarn add webpack-contrib/html-webpack-plugin -D</code></p><ol start="5"><li>然后启动项目会出现编译警告:<code>The mode option has not been set...</code>,<br><img src="http://qiniu.xueshiming.cn/mode.png" alt="错误信息"></li></ol><ul><li>需要在 <code>package.json</code> 里&quot;dev&quot;和&quot;build&quot;添加<br><code>--mode development</code><br><code>--mode production</code></li></ul><ol start="6"><li><code>yarn run dev</code> 启动项目</li></ol><h3 id="参考">参考</h3><p><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">webpack中文文档</a></p><p><a href="https://doc.webpack-china.org/plugins" target="_blank" rel="noopener">以及插件列表</a></p><h3 id="升级效果">升级效果</h3><ul><li>升级前<br><img src="http://qiniu.xueshiming.cn/%E5%8D%87%E7%BA%A7%E5%89%8D.png" alt="升级前"></li><li>升级后<br><img src="http://qiniu.xueshiming.cn/%E5%8D%87%E7%BA%A7%E5%90%8E.png" alt="升级后"><br>风控限额项目由原来的webpack3.10.0升级到4.0.1,</li></ul><p>打包速度由原来的 41424ms 提升到 36396ms,减少了5秒</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新建分支并提交到远程分支</title>
      <link href="/2018/02/28/%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
      <url>/2018/02/28/%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</url>
      <content type="html"><![CDATA[<h5 id="新建分支并提交到远程分支">新建分支并提交到远程分支</h5><ol><li><code>git checkout -b phase</code> 新建分支phase 并切换到phase</li><li><code>git push origin phase:phase</code> 推送到远程分支</li><li><code>git branch</code> 查看本地分支</li><li><code>git branch -r</code> 查看远程分支<br>如果远程分支上有phase，说明提交成功，就可以在分支上开发了!</li></ol><a id="more"></a><hr><p>在master分支上：</p><ol><li><code>git fetch</code> 远程跟踪分支已更新(Git术语叫做commit)，需要将这些更新取回本地</li><li><code>git status</code> 查询一下状态</li><li>若提示落后于<code>origin/master</code></li><li><code>git merge origin/master</code> 将远端master分支的代码merge进本地分支</li><li><code>git status</code> 再次确认</li><li><code>git checkout -b test</code> 新建分支test 并且换到test</li></ol><p>其他git命令：</p><p><code>git reset –hard origin/master</code> 将本地的状态回退到和远程的一样</p><p><code>git rest</code> 在git的一般使用中，如果发现错误的将不想暂存的文件被git add进入索引之后，</p><p>想回退取消，则可以使用命令： <code>git reset HEAD &lt;file&gt;</code></p><p><code>git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]</code>：</p><p>将当前的分支重设<code>(reset)</code>到指定的<code>&lt;commit&gt;</code>或者<code>HEAD</code>(默认，如果不显示指定<code>&lt;commit&gt;</code>，默认是<code>HEAD</code>，即最新的一次提交)，</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git（二）</title>
      <link href="/2017/12/26/Git%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/12/26/Git%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>最近在开发项目的过程中，我所在一个叫dev的分支开发，正开发到一半，头儿让我去master分支<br>修改一个bug，所以我必须先把正在改的代码暂存起来或者提交，才可以去切换分支开发。<br>在这个场景下：有三种方法去解决：</p><h5 id="及时commit代码">及时commit代码</h5><p>在dev分支上把已经开发完成的部分代码commit掉,不push，然后切换到master分支上修改代码,<br>做完了commit,所有分支互不影响，当然勤commit是一个好习惯。</p><a id="more"></a><h5 id="使用git-stash">使用git stash</h5><p>在dev分支上，我可以</p><blockquote><p>git stash或者 git stash save “修改的信息&quot;</p></blockquote><p>这样的话，你的代码就回到上一个commit了,直接git stash也行，git stash 栈会给你一个hash值作为版本的说明，但我觉得最好自己写说明比较明朗。然后你到master分支之后，完成了头二交给的任务，你就可以回到dev分支，然后输入：</p><blockquote><p>git stash pop或git stash list</p></blockquote><p>就可以回到刚才修改时候的版本了。这就相当于，压栈出栈的过程，将旧版本代码压栈，然后<br>切换分支开发，然后回到原先分支，出栈获得之前正在修改的代码。<br>而</p><blockquote><p>git stash apply stash@{0}</p></blockquote><p>的作用是可以指定栈中的一个版本，<br>通过</p><blockquote><p>git stash list 可以看到所有的版本信息:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;<span class="number">0</span>&#125;: On master: Uncommitted changes before rebase</span><br><span class="line">stash@&#123;<span class="number">1</span>&#125;: On master: Uncommitted changes before Checkout</span><br></pre></td></tr></table></figure><p>然后你可以选择一个你需要的版本执行：</p><blockquote><p>git stash apply stash@{0}</p></blockquote><p>然后你的代码就回来了。</p><h5 id="用ide工具的shelve的功能">用IDE工具的shelve的功能</h5><p>我用的webStorm有shelve功能，shelve的意思是“将…搁在一边”，即把还没写完的代码先搁在一边。</p><p>首先在IDE的底部找到<code>Version Control</code>，点开会有local的选项卡，选中你要搁置的代码，点击右键，选择“Shelve Changes”，在提交的输入框中输入你的注释，以便回来的时候识别你需要的版本，点击“Shelve Changes”键即可。这时选项卡上会多一个“Shelf”的选项卡，里面就有你搁置的代码。</p><p>这时候你可以去master分支修改代码，改完了之后回到dev分支，到“Shelf”选项卡下选择你要恢复的代码或者版本，点击右键选择“Unshelve Changes”，你的搁置的代码就回来了。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React组件间通信</title>
      <link href="/2017/12/10/React%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2017/12/10/React%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>处理 React 组件之间的交流方式，主要取决于组件之间的关系，<br>下面我们根据不同情况，来讲讲React的组件通信。</p></blockquote>  <a id="more"></a><ul><li>【父组件】向【子组件】传值；</li><li>【子组件】向【父组件】传值；</li><li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间的传值）</li></ul><h3 id="父子传值：">父子传值：</h3><hr><h4 id="父向子传">父向子传</h4><p><code>父组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = e =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value: this.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是parent</span><br><span class="line">        &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Child value=&#123;this.state.value&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; value &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是Child，得到传下来的值：&#123;value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件做的就是定义好 state ，定义好事件函数，在input onChange 的时候，去缓存 value 值，然后点击 button 的时候，改变 state , 子组件只负责展示 value 。</p><h4 id="子向父传">子向父传</h4><p>child 组件通知 parent 组件， 主要是依靠 parent 传下来的 callback 函数执行，改变 parent 组件的状态，或者把 child 自己的 state 通知 parent 。分两种情况：</p><ul><li>state 定义在 parent 组件<br><code>父组件：</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Parent extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = value =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是parent, Value是：&#123;this.state.value&#125;&lt;/div&gt;</span><br><span class="line">        &lt;Child setValue=&#123;this.setValue&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleChange = e =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    const &#123; setValue &#125; = this.props;</span><br><span class="line">    setValue(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是Child</span><br><span class="line">        &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">          state 定义在 parent</span><br><span class="line">          &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">          &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parent 组件把改变 state 的 setValue 函数传给 child ，child 组件自己处理内部的状态（这里是表单的value值），当 child 组件分发消息的时候， 执行 parent 的 setValue 函数，从而改变了 parent 的 state，state发生变化， parent 组件执行 re-render</p><ul><li>state 定义在 child 组件</li></ul><p><code>父组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line"></span><br><span class="line">  onChange = value =&gt; &#123;</span><br><span class="line">    console.log(value, &apos;来自 child 的 value 变化&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是parent</span><br><span class="line">        &lt;Child onChange=&#123;this.onChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      childValue: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  childValChange = e =&gt; &#123;</span><br><span class="line">    this.childVal = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  childValDispatch = () =&gt; &#123;</span><br><span class="line">    const &#123; onChange &#125; = this.props;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      childValue: this.childVal,</span><br><span class="line">    &#125;, () =&gt; &#123; onChange(this.state.childValue) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是Child</span><br><span class="line">        &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">          state 定义在 child</span><br><span class="line">          &lt;input onChange=&#123;this.childValChange&#125; /&gt;</span><br><span class="line">          &lt;div className=&quot;button&quot; onClick=&#123;this.childValDispatch&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候 state 是需要定义在 child 组件的，比如弹窗， CheckBox 这种开关性质的，逻辑是重复的，state 定义在组件内部更好维护， 复用性更好。但是 child 的 state 是需要告知我的 parent 组件的， 同样还是执行 parent 传下来的 change 函数。</p><h3 id="兄弟组件：">兄弟组件：</h3><hr><p>有时候可能出现页面中的某两部分通信，比如省市的级联选择，点击 button 改变颜色等等，组件并不是父子级，没有嵌套关系的时候。这种时候通常是依赖共有的顶级 Container 处理或者第三方的状态管理器。其实原理都是相通的，兄弟 A 的 value 发生变化，分发的时候把 value 值告诉一个中间者 C ，C 会自动告知 B，实现 B 的自动render 。</p><h4 id="利用共有的container">利用共有的Container</h4><p><code>container</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Container extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = value =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;A setValue=&#123;this.setValue&#125;/&gt;</span><br><span class="line">        &lt;B value=&#123;this.state.value&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>兄弟A：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    const &#123; setValue &#125; = this.props;</span><br><span class="line">    setValue(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">        我是Brother A, &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>兄弟B：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const B = props =&gt; (</span><br><span class="line">  &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">    我是Brother B, value是：</span><br><span class="line">    &#123;props.value&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">export default B;</span><br></pre></td></tr></table></figure><p>组件 A 中的表单 value 值，告知了父级 Container 组件（通过 setValue 函数改变 state），组件 B 依赖于 Container 传下来的 state，会做出同步更新。这里的中间者是 Container。</p><h4 id="利用context">利用Context</h4><p>上面的方式，如果嵌套少还可以，如果嵌套特别多，比如一级导航栏下的二级导航栏下的某个按钮，要改变页面中 content 区域的 table 里的某个列的值…他们同属于一个 page 。这样传递 props 就会很痛苦，每一层组件都要传递一次。</p><p><code>顶级公共组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Context extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = value =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123; // 必需</span><br><span class="line">    return &#123;</span><br><span class="line">      value: this.state.value,</span><br><span class="line">      setValue: this.setValue,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;AParent /&gt;</span><br><span class="line">        &lt;BParent /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必需</span><br><span class="line">Context.childContextTypes = &#123;</span><br><span class="line">  value: PropTypes.string,</span><br><span class="line">  setValue: PropTypes.func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>A 的 parent：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AParent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">        &lt;A /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// A</span><br><span class="line">class A extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    const &#123; setValue &#125; = this.context;</span><br><span class="line">    setValue(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是parentA 下的 A, &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必需</span><br><span class="line">A.contextTypes = &#123;</span><br><span class="line">  setValue: PropTypes.func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>B 的 parent：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BParent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">        &lt;B /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// B</span><br><span class="line">class B extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是parentB 下的 B, value是：</span><br><span class="line">        &#123;this.context.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.contextTypes = &#123;</span><br><span class="line">  value: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>组件 A 仍是 消息的发送者，组件 B 是接收者， 中间者是 Context 公有 Container 组件。context是官方文档的一个 API ，通过 getChildContext 函数定义 context 中的值，并且还要求 childContextTypes 是必需的。这样属于这个 Container 组件的子组件，通过 <code>this.context</code> 就可以取到定义的值，并且起到跟 state 同样的效果。中间者其实还是 Container，只不过利用了上下文这样的 API ，省去了 props 的传递。另外：这个功能是实验性的，未来可能会有所改动。</p><p>Context 也存在自己的问题。如果你用过 context，你可能会发现一个问题，当 context 发生改变的时候，比如数据流向是从 Container(context 定义) -&gt; A -&gt; B -&gt; C(接收 context)，组件 A, B 也会发生 render，这样 C 组件才能拿到更新后的 context。万一你在 A, B 使用 shouldComponentUpdate: false 拦截了，或者某个组件是 PureComponent，context 发生变化，C 没有重新渲染，故拿不到最新的 context。</p><p>针对这种情况，我们要做的不是想方设法让 A，B render，而是通过其他手段，来实现 C 的重新渲染。通常是使用 context 做依赖注入，即 context 只注入一次，后续不会发生变化，这样各种无视组件层级透传属性。context 里面的数据进行改造，添加 subscribe 这样的函数，然后当某个数据变化的时候做 patch。子组件可能会加这样的代码：</p><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.context.theme.subscribe(() =&gt; this.forceUpdate())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思想可以安全的使用 context，事实上 react-redux 也是这样做的。Provider 提供 context，connect 去做订阅。</p><h3 id="redux-mobx">Redux || Mobx</h3><p>Redux 或者 Mobx 是第三方的状态管理器，是这里我们通信的中间者。大型项目最直接的就是上库… 更方便，更不容易出错。 但其实小项目就没什么必要了。东西比较多，这里不再阐述它们的实现和做了什么。</p><h3 id="总结">总结</h3><p>react 特殊的自上而下的单向数据流，和 state 的特性，造就以这样的思想实现组件通信。除去发布订阅和 Redux 等，其他的都是 props 自上而下传递的理念，子组件需要的总是通过父组件传递下来的，关于 state 的定义，还是看具体的应用场景了。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git（三）</title>
      <link href="/2017/12/05/Git%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2017/12/05/Git%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h5 id="git小记">git小记</h5><pre><code> 最近遇到一个神奇的问题～ 平时推送到远程分支上用 git push 但发现了另一种方法，git push origin master 他们有什么区别呢？</code></pre><p>git push origin master 的意思就是，上传本地当前分支代码到master 分支，git push<br>是上传本地所有分支代码到远程对应分支上。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git（一）</title>
      <link href="/2017/12/01/Git%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/12/01/Git%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>提交如果遇到冲突的话，有两种解决方式，git merge和 git rebase。<br>首先来了解一下git pull：</p><p>将远程存储库中的更改合并到当前分支中。在默认模式下，git pull 是git fetch后跟git merge FETCH_HEAD的缩写。<br>更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。<br>也就是说git pull 分为两步，一步是git fetch，一步是git merge。</p><p>目前提交代码，先是git commit 到本地  然后 merge 或者 rebase。</p><a id="more"></a><h5 id="遇到冲突之git-base解决">遇到冲突之git base解决</h5><ol><li><p>首先查看所有分支：<br>git branch -r<br><img src="http://qiniu.xueshiming.cn/01.png" alt="查看所有分支"></p></li><li><p>检出一个分支：<br>git checkout -b root<br><img src="http://qiniu.xueshiming.cn/02.png" alt="检出分支"></p></li><li><p>当自己修改了本地分支之后<br>git push --set-upstream origin root<br>作用：推送当前分支并建立与远程上游的跟踪</p></li><li><p>试图去拉当前服务器上的分支,因为在要向服务器提交代码时，首先要拉服务器的代码<br>git pull<br>会有提示 ：（因为当时还没有commit到本地仓库）<br><img src="http://qiniu.xueshiming.cn/03.png" alt="提示"><br>提交到本地仓库：<br>git add .<br>git commit -m test<br><img src="http://qiniu.xueshiming.cn/04.png" alt="提交到本地仓库"></p></li><li><p>使用git pull --rebase</p></li></ol><p><img src="http://qiniu.xueshiming.cn/05.png" alt="rebase命令"></p><p><img src="http://qiniu.xueshiming.cn/06.png" alt="命令"></p><ol start="6"><li>使用git status 查看到哪一个文件有错误</li></ol><p><img src="http://qiniu.xueshiming.cn/07.png" alt="Routers.jsx报错"></p><ol start="7"><li>修改后(保留服务器的代码)：</li></ol><p><img src="http://qiniu.xueshiming.cn/08.png" alt="服务器代码"></p><p>其中&lt;&lt;&lt;&lt;HEAD 下 ====上是远程分支上的代码</p><p>====下  &gt;&gt;&gt;&gt;&gt;111 上是本地代码  （111是提交时候的注释）</p><h5 id="情况一：需要git-服务器上的代码">情况一：需要Git 服务器上的代码</h5><p><img src="http://qiniu.xueshiming.cn/09.png" alt="提交"></p><p>此处就不需要再git commit了，因为你所要提交的代码是和远程分支上一样的。</p><h5 id="情况二：保留本地代码">情况二：保留本地代码</h5><p>就需要git commit -m xxx</p><p>————&gt;我们这里演示的是保留远程分支上的代码：</p><p>所以执行 git rebase --continue  会出现以下情况：</p><p><img src="http://qiniu.xueshiming.cn/continue.png" alt="continue"></p><p>命令的作用是：  git会继续应用(apply)余下的补丁,因为已经git add .  过了<br>所以跳过此补丁</p><p>另外：在任何时候，都可以用git rebase --abort参数来终止rebase的行动，分支会回到rebase开始前的状态.</p><ol start="8"><li>最后根据提示来执行命令：<br><img src="http://qiniu.xueshiming.cn/11.png" alt="最后的命令"></li></ol><p>使用git需要养成的习惯～～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">经常commit，然后pull —reabase , 最后 push</span><br><span class="line"></span><br><span class="line">养成良好操作，尽量保持Master提交记录是一条线  利于code review</span><br></pre></td></tr></table></figure><p>git reabse 与git merge 区别<br>(<a href="https://www.cnblogs.com/kevingrace/p/5896706.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/5896706.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的React</title>
      <link href="/2017/11/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84React/"/>
      <url>/2017/11/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84React/</url>
      <content type="html"><![CDATA[<p>这几天正在学习React，有空记录一下！<br>比如：</p><h5 id="export和export-default">export和export default</h5><p>一般我们在定义了一个组件之后，为了复用，需要将它导出以提供给其他页面使用。<br>组件导出的关键字是:</p><blockquote><p>exprot default</p></blockquote><p>没有加default时，例如：</p><blockquote><p>export class Template{}</p></blockquote><p>当然，你可以在单个js文件里声明多个组件，例如Templates.js</p><blockquote><p>export class Template{}<br>export class AnotherTemplate{}</p></blockquote><p>这样在其他文件引用时，需要使用{}符号，且名称必须和class名称一样，like this：</p><blockquote><p>import {Template,AnotherTemplate} from ‘./components/Templates’;</p></blockquote><p>而加default时，例如：</p><a id="more"></a><blockquote><p>export default class Template{}</p></blockquote><p>然后在其他文件引用，像这样：</p><blockquote><p>import Template from ‘./components/Templates’;</p></blockquote><p>你也可以为这个组件另起一个别名，</p><blockquote><p>import TheTemplate from ‘./components/Templates’;</p></blockquote><p>但是每个文件里只能有一个default组件，可以包含其他非default组件：</p><blockquote><p>export default class Template{}<br>export class AnotherTemplate{}</p></blockquote><p>然后引用的时候，如下：</p><blockquote><p>import Template,{AnotherTemplate} from ‘./components/Templates’;</p></blockquote><p>总结：</p><ul><li>有default和没有default的区别在于：有default在引用时可以自定义名称，而没有default时需要使用{}括起来且名称必需和class名称一致</li><li>每个文件里只能有一个default组件，但可以有多个非default组件</li></ul><hr><h5 id="formitem">FormItem</h5><p>使用initValue 属性的时候，需要在提交“弹出框表单时”（CollectionCreateForm）</p><p>用form.resetFields() 方法重置表单数据，</p><p>如果缺少的话，点击修改某条数据是会回显上次表单修改后的值。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL中MAX函数与Group By一起使用的注意事项</title>
      <link href="/2017/10/27/MySQL%E4%B8%ADMAX%E5%87%BD%E6%95%B0%E4%B8%8EGroup%20By%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2017/10/27/MySQL%E4%B8%ADMAX%E5%87%BD%E6%95%B0%E4%B8%8EGroup%20By%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from  test;  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">| id | name  | age  | class |  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">|  1 | qiu   |   22 |     1 |   </span><br><span class="line">|  2 | liu   |   42 |     1 |   </span><br><span class="line">|  4 | zheng |   20 |     2 |   </span><br><span class="line">|  3 | qian  |   20 |     2 |   </span><br><span class="line">|  0 | wang  |   11 |     3 |   </span><br><span class="line">|  6 | li    |   33 |     3 |   </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果想找到每个Class里面的最大的Age，则需要使用roup by和max。<br>如下的Sql语句，则输出结果有错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,name,max(age),class from test group by class;  </span><br><span class="line">+----+-------+----------+-------+  </span><br><span class="line">| id | name  | max(age) | class |  </span><br><span class="line">+----+-------+----------+-------+  </span><br><span class="line">|  1 | qiu   |       42 |     1 |   </span><br><span class="line">|  4 | zheng |       20 |     2 |   </span><br><span class="line">|  0 | wang  |       33 |     3 |   </span><br><span class="line">+----+-------+----------+-------+  </span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>虽然找到的age是最大的age，但是与之匹配的用户信息却不是真实的信息，而是group by分组后的第一条记录的基本信息。<br>如果我使用以下的语句进行查找，则可以返回真实的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from (  </span><br><span class="line">    -&gt; select * from test order by age desc) as b  </span><br><span class="line">    -&gt; group by class;  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">| id | name  | age  | class |  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">|  2 | liu   |   42 |     1 |   </span><br><span class="line">|  4 | zheng |   20 |     2 |   </span><br><span class="line">|  6 | li    |   33 |     3 |   </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test t where t.age = (select max(age) from test where t.class = class) order by class;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sleep和Wait的区别</title>
      <link href="/2017/10/19/Sleep%E5%92%8CWait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/10/19/Sleep%E5%92%8CWait%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<ol><li>Java中sleep和wait的区别<br>① 这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。<br>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</li></ol><a id="more"></a><p>② 锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。<br>Thread.sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。<br>③ 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。</p><p>synchronized(x){<br>x.notify()<br>//或者wait()<br>}</p><p>java常见面试题(<a href="https://blog.csdn.net/shineflowers/article/details/40047479" target="_blank" rel="noopener">https://blog.csdn.net/shineflowers/article/details/40047479</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql获取当前日期并格式化</title>
      <link href="/2017/10/18/Mysql%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2017/10/18/Mysql%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>MYSQL 获取当前日期及日期格式话</p><a id="more"></a><p>获取系统日期： NOW()<br>格式化日期： DATE_FORMAT(date, format)<br>注： date：时间字段<br>format：日期格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回系统日期,输出 2009-12-25 14:38:59</span><br><span class="line">select now();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出 09-12-25</span><br><span class="line">select date_format(now(),&apos;%y-%m-%d&apos;);</span><br></pre></td></tr></table></figure><p>根据format字符串格式化date值:</p><ul><li>%U 周（0, 1, 52），其中Sunday 为周中的第一天</li><li>%u 周（0, 1, 52），其中Monday 为周中的第一天</li><li>%M 月名（January, February, …, December）</li><li>%b 缩写的月名（ January, February,…, December）</li><li>%m 两位数字表示的月份（01, 02, …, 12）</li><li>%c 数字表示的月份（1, 2, …, 12）</li><li>%Y 四位数字表示的年份</li><li>%y 两位数字表示的年份</li><li>%% 直接值“%”</li><li>%S, %s 两位数字形式的秒（ 00,01, …, 59）</li><li>%I, %i 两位数字形式的分（ 00,01, …, 59）</li><li>%H 两位数字形式的小时，24 小时（00,01, …, 23）</li><li>%h 两位数字形式的小时，12 小时（01,02, …, 12）</li><li>%k 数字形式的小时，24 小时（0,1, …, 23）</li><li>%l 数字形式的小时，12 小时（1, 2, …, 12）</li><li>%T 24 小时的时间形式（hh:mm:ss）</li><li>%r 12 小时的时间形式（hh:mm:ss AM 或hh:mm:ss PM）</li><li>%p AM或PM</li><li>%W 一周中每一天的名称（Sunday, Monday, …, Saturday）</li><li>%a 一周中每一天名称的缩写（Sun, Mon, …, Sat）</li><li>%d 两位数字表示月中的天数（00, 01,…, 31）</li><li>%e 数字形式表示月中的天数（1, 2， …, 31）</li><li>%D 英文后缀表示月中的天数（1st, 2nd, 3rd,…）</li><li>%w 以数字形式表示周中的天数（ 0 = Sunday, 1=Monday, …, 6=Saturday）</li><li>%j 以三位数字表示年中的天数（ 001, 002, …, 366）</li></ul><p>还有一些实现日期的函数，或者是返回月份中的最后一天 等<br>eg:MySQL last_day() 函数：返回月份中的最后一天。</p><p>详见：(<a href="https://blog.csdn.net/kangbrother/article/details/7030304" target="_blank" rel="noopener">https://blog.csdn.net/kangbrother/article/details/7030304</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql Decimal数据类型</title>
      <link href="/2017/10/17/Mysql%20Decimal%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/10/17/Mysql%20Decimal%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>最近忙着复习，更新的速度有些慢。在一次面试中，面试官问我，mysql里金额用什么存，我只用过普通的double，float，但回来一查，金额应该用Decimal 来存。受教了~</p><p>mysql里Decimal表示 128 位数据类型。double相比，decimal 类型具有更高的精度和更小的范围，它适合于财务和货币计</p><a id="more"></a><p>测试表，seller_cost字段定义为decimal(14,2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_decimal` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `seller_cost` decimal(14,2) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><p>起初，表中内容为空:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>插入整数部分长度为14的数字，报超出列范围的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,12345678901234);</span><br><span class="line">ERROR 1264 (22003): Out of range value for column &apos;seller_cost&apos; at row 1</span><br></pre></td></tr></table></figure><p>插入整数部分长度为12的数字，可以正确插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,123456789012);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询表，发现插入的整数值末尾被MySQL补了两位小数“.00”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>继续插入整数部分12位，小数部分5位的数字，可以成功插入，但是有警告，警告表明小数部分发生了截断，被截取成了两位小数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,123456789012.12345);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Level | Code | Message                                          |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Note  | 1265 | Data truncated for column &apos;seller_cost&apos; at row 1 |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">|  1 | 123456789012.12 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>缩小整数部分的长度为2，小数部分的长度继续保持为5，可以成功插入，但小数部分被截断为两位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; insert into test_decimal(id,seller_cost) values(1,12.12345);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Level | Code | Message                                          |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Note  | 1265 | Data truncated for column &apos;seller_cost&apos; at row 1 |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">|  1 | 123456789012.12 |</span><br><span class="line">|  1 |           12.12 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>继续插入一个小数部分不足两位的数字，可正确插入，且小数部分被自动补全到两位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,12.1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">|  1 | 123456789012.12 |</span><br><span class="line">|  1 |           12.12 |</span><br><span class="line">|  1 |           12.10 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>综上所述，DECIMAL(N,M)中M值的是小数部分的位数，若插入的值未指定小数部分或者小数部分不足M位则会自动补到M位小数，若插入的值小数部分超过了M为则会发生截断，截取前M位小数。N值得是整数部分加小数部分的总长度，也即插入的数字整数部分不能超过N-M位，否则不能成功插入，会报超出范围的错误。</p><p>详解mysql int类型的长度值问题（<a href="https://www.cnblogs.com/echo-something/archive/2012/08/26/mysql_int.html" target="_blank" rel="noopener">https://www.cnblogs.com/echo-something/archive/2012/08/26/mysql_int.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql decimal类型与decimal长度用法详解</title>
      <link href="/2017/10/15/Mysql%20decimal%E7%B1%BB%E5%9E%8B%E4%B8%8Edecimal%E9%95%BF%E5%BA%A6%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/10/15/Mysql%20decimal%E7%B1%BB%E5%9E%8B%E4%B8%8Edecimal%E9%95%BF%E5%BA%A6%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h5 id="float-double-decimal三者的区别介绍">float,double,decimal三者的区别介绍</h5><a id="more"></a><p>float:浮点型，含字节数为4，32bit，数值范围为-3.4E38~3.4E38（7个有效位）<br>double:双精度实型，含字节数为8，64bit数值范围-1.7E308~1.7E308（15个有效位）<br>decimal:数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）</p><h5 id="按存储的范围进行排序">按存储的范围进行排序</h5><p>float（real）<br>double<br>decimal（numeric）</p><h5 id="decimal的详细介绍">decimal的详细介绍</h5><p>decimal(a,b)</p><h5 id="参数说明">参数说明</h5><p>a指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。<br>b指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从 0 到 a之间的值。默认小数位数是 0。</p><h5 id="备注">备注</h5><p>DECIMAL数据类型用于要求非常高的精确度的计算中，这些类型允许指定数值的精确度和计数方法作为选择参数。精确度在这里是指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的个数。例如，语句DECIMAL (5,2)规定了存储的值将不会超过5位数字，开且小数点后面有2位数字。</p><h5 id="实例">实例</h5><blockquote><p>float f = 345.98756f;–结果显示为345.9876，只显示7个有效位，对最后一位数四舍五入。<br>double d=345.975423578631442d;–结果显示为345.975423578631，只显示15个有效位，对最后一位四舍五入。<br>–注：float和double的相乘操作，数字溢出不会报错，会有精度的损失。<br>decimal dd=345.545454879…–可以支持28位，对最后一位四舍五入。<br>–：当对decimal类型进行操作时，数值会因溢出而报错。</p></blockquote><h5 id="总结">总结</h5><p>数值存储范围越小的精度越高，存储数值范围越大，精度就越不准确，如果存储正常金额的情况下，使用money，好处在于可以存储不指定的小数点位数的数值，比较真实。如果对于既要求精度，又固定小数点位数的数值存储，采用decimal（numeric），优点在于可以自定义小数点位数，精度高。如特殊情况，如数值范围巨大只能用float（real）类型了，此类型一般不提倡使用</p><p>链接(<a href="https://blog.csdn.net/zhanghao143lina/article/details/53816884" target="_blank" rel="noopener">https://blog.csdn.net/zhanghao143lina/article/details/53816884</a>)<br>mysql数据类型(<a href="https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html" target="_blank" rel="noopener">https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String s1 = new String(&quot;abc&quot;)和String s2 = &quot;abc&quot;的区别</title>
      <link href="/2017/10/15/String%E7%9B%B8%E5%85%B3/"/>
      <url>/2017/10/15/String%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h5 id="今天在看jvm的时候突然想到这样一个问题-即">今天在看JVM的时候突然想到这样一个问题，即</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;abc&quot;);</span><br><span class="line">String s2 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);//答案是false</span><br></pre></td></tr></table></figure><p>问题有两个：</p><p>String s2 = “abc”时发生了什么？<br>String s1 = new String(“abc”）时又做了什么？<br>第二个问题是比较好回答的，根据官方文档的解释：</p><a id="more"></a><p>当我们在jdk1.6中讨论时，常量池放在方法区中。（jdk1.7中常量池放在堆内存中，jdk1.8放在元空间里面，和堆相对独立，所以导致string的intern方法因为以上变化在不同版本会有不同表现。）</p><blockquote><p>new String(“abc”);<br>Initializes a newly created String object so that it represents the same sequence of characters as the argument; in other words, the newly created string is a copy of the argument string. Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.</p></blockquote><p>简单解释一下：</p><blockquote><p>初始化一个新创建的String对象，换句话说，新创建的字符串是参数字符串的一个副本。除非确实需要一份副本，否则这种方法是不必要的，因为String是不可变的</p></blockquote><p>这句话实际上透露出两个意思，</p><p>在编译器编译的时候，当编译器注意到参数为字符串常量时，即将字符串作为常量放在class文件中的常量区，并在类加载时放入运行时常量池中。<br>在new操作符被调用时，在java堆中创建一个新的对象，然后对象的内容为常量池里面对应字符串的一个拷贝。<br>而在String s2 = “abc”被编译的时候，先检查class文件中是否包含该字符串常量，如果包含，直接返回常量池中的对象。</p><p>因此，在调用new操作时，对象始终存在于堆中，而直接字符串赋值时对象实际上是存在于常量池中的，<br>所以比较结果肯定是false</p><p>String s = new String(“hello”);</p><h5 id="generally-speaking">Generally speaking,</h5><ul><li>jdk1.6中: 首先&quot;hello&quot;字符串对象保存在 方法区的字符串常量池中， 在虚拟机栈中开辟空间 用来存放String 类型的变量s，在堆中开辟空间<br>存放 s 引用的对象，然后将常量池中的“hello” 拷贝一个副本给堆中的String。</li><li>jdk1.7中:首先&quot;hello&quot;字符串对象保存在堆内存的字符串常量池中<ul><li>1】在栈中开辟空间存放 s</li><li>2】在堆中开辟空间存放新建的String 对象&quot;hello&quot;</li><li>3】引用s指向堆中新建的String对象“hello”。</li></ul></li></ul><p>参考文章1、（<a href="https://blog.csdn.net/weixin_35663229/article/details/52796157?locationNum=15%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/weixin_35663229/article/details/52796157?locationNum=15）</a><br>参考文章2、（<a href="https://blog.csdn.net/u010644448/article/details/51980370%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/u010644448/article/details/51980370）</a></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JS(一)</title>
      <link href="/2017/09/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS(%E4%B8%80)/"/>
      <url>/2017/09/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<pre><code>javaScript数组的遍历，在项目中遇到的是这个问题：直接上图：</code></pre><h3 id="主要针对数组的遍历有一下方法">主要针对数组的遍历有一下方法</h3><p>传统方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>for in方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for each 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.forEach(callback)</span><br><span class="line">forEach()方法是ES2.1标准引入的。</span><br><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">arr.forEach(function(v,i)&#123;//v==value　为arr项，i==index　为arr索引</span><br><span class="line">    console.log(i+&apos;  &apos;v );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在最新的ES6中新增了一个方法<br>for of方法</p><p>遍历Array可以采用下标循环，遍历map和Set就无法使用下标，无法使用索引进行遍历<br>，为了统一集合类型，ES6标准引入了新的iterable类型，<br>Array、Map和Set都属于iterable类型。<br>具有iterable类型的集合可以通过新的for…of循环遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">for(var value of Arr)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for … of循环和for … in循环有何区别<br>for … in循环，它遍历的实际上是对象的属性名称。</p><p>一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p><p>当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p><p>for in 遍历数组时会为把数组索引作为键值　如：数组0、1、2、3、4、5、…的键；当我们这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">arr.value=&apos;val&apos;;</span><br><span class="line">//在使用for in 遍历时</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">    console.log(i+&apos;   &apos;+arr[i]);//这时的i为键值，不为数组索引</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">0   1</span><br><span class="line">1   2</span><br><span class="line">2   3</span><br><span class="line">3   4</span><br><span class="line">4   5</span><br><span class="line">5   6</span><br><span class="line">value   val</span><br><span class="line">接着执行，这时出现问题：</span><br><span class="line"></span><br><span class="line">arr;//输出[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">//使用 console.log(arr)时，这样</span><br><span class="line">console.log(arr);//输出[1, 2, 3, 4, 5, 6, value: &quot;val&quot;]</span><br><span class="line"></span><br><span class="line">//alert(arr)时</span><br><span class="line">alert(arr);//输出[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p>而当我们使用for of 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">arr.value=&apos;val&apos;;</span><br><span class="line">//在使用for in 遍历时</span><br><span class="line">for(var v of arr)&#123;</span><br><span class="line">    console.log(v);//v为数组的项</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>直接遍历出值</p><p>Map 遍历：</p><p>map:和forEach非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项；</p><p>区别：map的回调函数中支持return返回值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [12,23,24,42,1];</span><br><span class="line">var res = ary.map(function (item,index,input) &#123;</span><br><span class="line">     return item*10;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1]；</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>听罗胖聊天</title>
      <link href="/2017/09/02/%E5%90%AC%E7%BD%97%E8%83%96%E8%81%8A%E5%A4%A9/"/>
      <url>/2017/09/02/%E5%90%AC%E7%BD%97%E8%83%96%E8%81%8A%E5%A4%A9/</url>
      <content type="html"><![CDATA[<p>最近才了解到《逻辑思维》这个节目，其实这个节目在某酷上已经播出了好长一段时间了，</p><p>今天有闲心去看了两集《逻辑思维》，两级节目都令自己感触比较深。</p><ol><li>《拒绝逃离北上广》：他的这个观点，其实和自己一直心中有个认知是一样的：<br>见识很重要，在北上广，虽然房价贵，空气不好但是真的是“机会非常多”。<br>“机会”的定义，会随着你慢慢接触的事物变多之后，慢慢的丰富。所以，我想要以后生活在这里！</li><li>《知识焦虑》，今天说来也巧，在《意林》上，和节目中都看到了这个话题，对“知识爆炸”的更进一步了解了。<br>还有就是学习效率的问题，另类二八原则！<br>而且，正准备在地铁上去听书，在节目中就了解了碎片化学习，很巧。</li><li>二八法则频频出现在外来的信息中。</li></ol>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>盒子模型</title>
      <link href="/2017/09/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/09/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>今天来聊聊box-sizing</p><p>盒模型：<br>当你设置了元素的宽度，实际展现的元素超出你的设置：<br>这是因为元素的边框和内边距会撑开元素。看下面的例子，<br>两个相同宽度的元素显示的实际宽度却不一样。</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8001.png" alt="代码"></p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8002.png" alt="我小一些"></p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8003.png" alt="我大一些"></p><p>以前有一个代代相传的解决方案是通过数学计算。CSS开发者需要用比他们实际想要的宽度小一点的宽度，需要减去内边距和边框的宽度。<br>值得庆幸是你不需要再这么做了…</p><p>Box-sizing:</p><p>人们慢慢地意识到传统的盒子模型不直接，所以他们新增了一个叫做box-sizing</p><p>的css属性。当你设置一个元素为box-sizings: border-box;时此元素的内边距和边框不会再增加它的宽度。<br>这里有一个与前一页相同的例子，唯一的区别是两个元素都设置了box-sizing：border-box;</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8004.png" alt="boxSize代码"></p><p>效果：</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8005.png" alt="效果"><br>既然没有比这更好的方法，一些CSS开发者想要页面上的元素都有如此的表现。所以开发者们，都把以下代码放在他们的页面上：</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8006.png" alt="直观的方式"></p><p>这样可以确保所有的元素都会用这种更直观的方式排版。</p><p>不过box-sizing是个很新的属性，目前你还应该像上面例子中那样使用 -webkit-<br>和-moz- 前缀。  这可以这个启用特定浏览器实验中的特性。同时记住它是支持IE8+的</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不用四则做加法</title>
      <link href="/2017/08/25/%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2017/08/25/%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      <content type="html"><![CDATA[<h5 id="不用四则做加法">不用四则做加法</h5><p>直接上代码：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (num2 != <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">int</span> temp = num1 ^ num2;</span><br><span class="line">   System.out.println(<span class="string">"temp="</span> + temp);</span><br><span class="line">   System.out.println(<span class="string">"num1&amp;num2="</span> + (num1 &amp; num2));</span><br><span class="line">   num2 = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">   System.out.println(<span class="string">"(num1 &amp; num2) &lt;&lt; 1 ="</span> + num2);</span><br><span class="line">   num1 = temp;</span><br><span class="line">            System.out.print(num1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num1;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  Add(<span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">  <span class="comment">//2  :0010</span></span><br><span class="line">  <span class="comment">//3  :0011</span></span><br><span class="line">  <span class="comment">//2^3=0001  =1    异或运算符，用符号(^)表示，其运算规则是：两个操作数的位中，相同则结果为0，不同则结果为1。</span></span><br><span class="line">    <span class="comment">//2&amp;3=0010  =2    位与运算符，都为1则为1，否则为0。</span></span><br><span class="line">  <span class="comment">//2&lt;&lt;2=4                      右移运算符，num &lt;&lt; 1,相当于num乘以2</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路解读">思路解读</h5><blockquote><p>解析：<br>首先看十进制是如何做的： 5+7=12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。<br>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p></blockquote><blockquote><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111<br>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。<br>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。<br>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p></blockquote><h5 id="延伸">延伸</h5><ol><li>位异或运算（^）</li></ol><p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。<br>比如：8^11.</p><p>8转为二进制是1000，11转为二进制是1011.从高位开始比较得到的是：0011.然后二进制转为十进制，就是Integer.parseInt(“0011”,2)=3;</p><ol start="2"><li>位与运算符（&amp;）</li></ol><p>运算规则：两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。<br>比如：129&amp;128.</p><p>129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000000，即128.</p><ol start="3"><li>位或运算符（|）</li></ol><p>运算规则：两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。</p><p>比如：129|128.</p><p>129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000001，即129.</p><ol start="4"><li>位非运算符（~）</li></ol><p>运算规则：如果位为0，结果是1，如果位为1，结果是0.</p><p>比如：~37</p><p>在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.</p><p>8转为二进制是100101.</p><p>补码后为： 00000000 00000000 00000000 00100101</p><p>取反为：    11111111 11111111 11111111 11011010</p><p>因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。</p><p>因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：</p><p>00000000 00000000 00000000 00100110，此时二进制转原码为38</p><p>所以~37 = -38</p><hr><p>关于java 原码、反码、补码的解释<br>(<a href="https://blog.csdn.net/u010841296/article/details/52850307" target="_blank" rel="noopener">https://blog.csdn.net/u010841296/article/details/52850307</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中单链表的实现</title>
      <link href="/2017/08/23/Java%E4%B8%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/08/23/Java%E4%B8%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>Java中我们使用的ArrayList，其实现原理是数组。而LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。</p><a id="more"></a><p>单向链表是一种线性表，实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</p><h5 id="下面是具体的实现">下面是具体的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> mylink;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Java中链表的创建及相关操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fisherman</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLink</span> </span>&#123;</span><br><span class="line"> Node head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> data;<span class="comment">// 定义数据域</span></span><br><span class="line">  <span class="keyword">private</span> Node next; <span class="comment">// 定义指针域</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">/*  </span></span><br><span class="line"><span class="comment">    class NodeOther&#123;</span></span><br><span class="line"><span class="comment">     private int data;// 定义数据域</span></span><br><span class="line"><span class="comment">   private Node next; // 定义指针域</span></span><br><span class="line"><span class="comment">     public NodeOther()&#123;</span></span><br><span class="line"><span class="comment">      this.data= data;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 插入数据</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">  Node node = <span class="keyword">new</span> Node(data);</span><br><span class="line">  <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">   head = node;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Node tmp = head;</span><br><span class="line">  <span class="keyword">while</span> (tmp.next != <span class="keyword">null</span>) &#123; <span class="comment">// 若下一个节点不为空，指针后移</span></span><br><span class="line">   tmp = tmp.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tmp.next = node; <span class="comment">// 然后把新的节点添加</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 计算链表的长度</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">  Node tmp = head;</span><br><span class="line">  <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123; <span class="comment">// 若头结点不为空</span></span><br><span class="line">   size++; <span class="comment">// 长度加一</span></span><br><span class="line">   tmp = tmp.next;<span class="comment">// 指针后移一位，指向下一个节点，然后再进行循环，长度再加一</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除序号为index的节点</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">1</span> || index &gt; size())</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 若所找节点的序号不存在 ，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">   head = head.next;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 若序号为1，说明找的是头结点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">// 从第二个节点开始</span></span><br><span class="line">  Node preNode = head; <span class="comment">// 初始为head 作为前驱节点</span></span><br><span class="line">  Node currNode = preNode.next; <span class="comment">// 现在的节点为head的下一个节点</span></span><br><span class="line">  <span class="keyword">while</span> (currNode != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">    preNode.next = currNode.next; <span class="comment">// 删除 currNode（当前节点）节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   preNode = currNode; <span class="comment">// preNode节点变为下一个节点</span></span><br><span class="line">   currNode = currNode.next; <span class="comment">// currNode节点变为下一个节点</span></span><br><span class="line">   i++; <span class="comment">// 继续向后查找</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在不知道头指针的情况下删除指定节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteNodeOther</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">int</span> temp = node.data;</span><br><span class="line">  node.data = node.next.data;<span class="comment">// 把待删除节点下一节点的数据覆盖待删除节点数据</span></span><br><span class="line">  node.next.data = temp;<span class="comment">// 保存了已删除节点的数据</span></span><br><span class="line">  node.next = node.next.next;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 打印链表</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Node tmp = head;</span><br><span class="line">  <span class="keyword">while</span> (tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">   System.out.println(tmp.data);</span><br><span class="line">   tmp = tmp.next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  MyLink link = <span class="keyword">new</span> MyLink();</span><br><span class="line">  link.addNode(<span class="number">2</span>);</span><br><span class="line">  link.addNode(<span class="number">3</span>);</span><br><span class="line">  link.addNode(<span class="number">4</span>);</span><br><span class="line">        link.addNode(<span class="number">5</span>);</span><br><span class="line">  System.out.println(<span class="string">"长度为："</span> + link.size());</span><br><span class="line">  link.printList();</span><br><span class="line">  System.out.println(<span class="string">"删除第二个元素："</span> + link.deleteNode(<span class="number">2</span>));</span><br><span class="line">  System.out.println(<span class="string">"删除后长度为："</span> + link.size());</span><br><span class="line">  link.printList();</span><br><span class="line"> <span class="comment">/*  MyLink.NodeOther node=new MyLink().new NodeOther();</span></span><br><span class="line"><span class="comment">  System.err.println("删除第三个节点："+link.deleteNodeOther(node)); */</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>袋鼠过河</title>
      <link href="/2017/08/23/newCoder%E8%A2%8B%E9%BC%A0%E8%BF%87%E6%B2%B3/"/>
      <url>/2017/08/23/newCoder%E8%A2%8B%E9%BC%A0%E8%BF%87%E6%B2%B3/</url>
      <content type="html"><![CDATA[<p>最近忙着复习，博客就更新频率少低了，现在就先把觉得重要的算法题记录一下，在牛客网上做到的最简单的动态规划问题，当然这道题的变形在leetCode上也有（jumpGame）。</p><a id="more"></a><h5 id="题目描述">题目描述</h5><blockquote><p>一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1</p></blockquote><h5 id="输入描述">输入描述:</h5><blockquote><p>输入分两行，第一行是数组长度N (1 ≤ N ≤ 10000)，第二行是每一项的值，用空格分隔。</p></blockquote><h5 id="输出描述">输出描述:</h5><blockquote><p>输出最少的跳数，无法到达输出-1</p></blockquote><h5 id="示例1">示例1</h5><blockquote><p>输入<br>5<br>2 0 1 1 1<br>输出<br>4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Jump &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int N = sc.nextInt();</span><br><span class="line">int[] nums = new int[N + 1];</span><br><span class="line">int[] dp = new int[N + 1];</span><br><span class="line">for (int i = 0; i &lt; N; i++)</span><br><span class="line">nums[i] = sc.nextInt();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;=N; i++)</span><br><span class="line">dp[i] = 100000;</span><br><span class="line">nums[N] = 1;</span><br><span class="line">dp[0] = 0;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">if (nums[i] == 0)</span><br><span class="line">continue;</span><br><span class="line">for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">if (nums[j] &gt;= i - j)</span><br><span class="line">dp[i] = Math.min(dp[j] + 1, dp[i]);</span><br><span class="line">System.out.println(&quot;i=&quot; + i + &quot;,&quot; + &quot;j=&quot; + j + &quot;  &quot; + &quot;dp[&quot; + i + &quot;]: &quot; + dp[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println((dp[N] == 100000) ? -1 : dp[N]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内部类</title>
      <link href="/2017/08/23/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2017/08/23/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>这是我学习Java内部类的笔记<br>1.为什么使用内部类?<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，<br>对于内部类都没有影响</p><a id="more"></a><p>1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:<br>(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。<br>(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。<br>(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。<br>(4)、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。<br>(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。<br>2.内部类分类:<br>(一).成员内部类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Outer&#123;</span><br><span class="line">       private int age = 99;</span><br><span class="line">       String name = &quot;Coco&quot;;</span><br><span class="line">       public class Inner&#123;</span><br><span class="line">           String name = &quot;Jayden&quot;;</span><br><span class="line">           public void show()&#123;</span><br><span class="line">               System.out.println(Outer.this.name);</span><br><span class="line">               System.out.println(name);</span><br><span class="line">               System.out.println(age);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public Inner getInnerClass()&#123;</span><br><span class="line">           return new Inner();</span><br><span class="line">       &#125;</span><br><span class="line">       public static void main(String[] args)&#123;</span><br><span class="line">           Outer o = new Outer();</span><br><span class="line">           Inner in = o.new Inner();</span><br><span class="line">           in.show();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，<br>如 public 、 protected 、 private 等<br>2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，<br>如直接访问 Outer 类中的私有属性age<br>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，<br>即：内部类 对象名 = 外部类对象.new 内部类( );<br>4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}<br>5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:<br>(1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,<br>简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;<br>非静态内部类的作用域是实例级别<br>(2).常量是在编译器就确定的,放到所谓的常量池了<br>★★友情提示:<br>1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;<br>2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，<br>可以使用 this 关键字,如:Outer.this.name<br>(二).静态内部类: 是 static 修饰的内部类,<br>1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问<br>2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；<br>如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员<br>3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">99</span>;</span><br><span class="line">           <span class="keyword">static</span> String name = <span class="string">"Coco"</span>;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">               String name = <span class="string">"Jayden"</span>;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                   System.out.println(Outer.name);</span><br><span class="line">                   System.out.println(name);                  </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">               Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">               i.show();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>(三).方法内部类:访问仅限于方法内或者该作用域内<br>(1).局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的<br>(2).只能访问方法中定义的 final 类型的局部变量,因为:<br>当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,<br>直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;<br>==&gt;使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.<br>局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，<br>自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;<br>防止被篡改数据,而导致内部类得到的值不一致<br>   使用的形参为何要为 final???<br>在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，<br>也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，<br>毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解<br>和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        public class Outer&#123;</span><br><span class="line">            public void Show()&#123;</span><br><span class="line">                final int a = 25;</span><br><span class="line">                int b = 13;</span><br><span class="line">                class Inner&#123;</span><br><span class="line">                    int c = 2;</span><br><span class="line">                    public void print()&#123;</span><br><span class="line">                        System.out.println(&quot;访问外部类:&quot; + a);</span><br><span class="line">                        System.out.println(&quot;访问内部类:&quot; + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Inner i = new Inner();</span><br><span class="line">                i.print();</span><br><span class="line">            &#125;</span><br><span class="line">            public static void main(String[] args)&#123;</span><br><span class="line">                Outer o = new Outer();</span><br><span class="line">                o.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">  ```  </span><br><span class="line">(四).匿名内部类:</span><br><span class="line">(1).匿名内部类是直接使用 new 来生成一个对象的引用;</span><br><span class="line">(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，</span><br><span class="line">该类的定义会立即消失，所以匿名内部类是不能够被重复使用;</span><br><span class="line">(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;</span><br><span class="line">(4).匿名内部类中是不能定义构造函数的,匿名内部类中不能存在任何的静态成员变量和静态方法;</span><br><span class="line">(5).匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法</span><br><span class="line">(6).匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果</span><br></pre></td></tr></table></figure><p>public class OuterClass {<br>public InnerClass getInnerClass(final int   num,String str2){<br>return new InnerClass(){<br>int number = num + 3;<br>public int getNumber(){<br>return number;<br>}<br>};        /* 注意：分号不能省 */<br>}<br>public static void main(String[] args) {<br>OuterClass out = new OuterClass();<br>InnerClass inner = out.getInnerClass(2, “chenssy”);<br>System.out.println(inner.getNumber());<br>}<br>}<br>interface InnerClass {<br>int getNumber();<br>}</p><pre><code></code></pre>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android进程优先级悉知</title>
      <link href="/2017/08/01/Android%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%82%89%E7%9F%A5/"/>
      <url>/2017/08/01/Android%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%82%89%E7%9F%A5/</url>
      <content type="html"><![CDATA[<h4 id="进程优先级">进程优先级</h4><p>当系统的内存不足的时候，android系统将根据进程优先级选择杀死一些不太重要的进程，进程优先级从高到底分别为：</p><ul><li>前台进程：<ul><li>进程中处于前台的正与用户交互的activity</li><li>进程中包含与前台activity绑定的service</li><li>进程中包含调用了startForeground方法的service</li><li>进程中包含正在执行的onCreate(),onStart()或onDestory()方法的service</li><li>进程中包含正在执行onReceive()方法的BroadcastReceiver<br></li></ul></li></ul><a id="more"></a><p>系统中前台进程的数量很少，前台进程几乎不会被杀死，只有内存低到不能保证所有前台进程同时运行时才会选择杀死某个前台进程</p><ul><li>可视进程<ul><li>进程中包含未处于前台但仍然可见的activity(调用了activity的onPause()方法，但没有调用onStop()方法)<br>，典型的情况是运行activity是弹出对话框，此时的activity虽然不是前台activity，但仍然可见</li><li>进程中包含与可见activity绑定的service<br>可视进程不会被系统杀死，除非为了保证前台进程不得已而为之</li></ul></li><li>服务进程<ul><li>进程中包含已启动的service</li></ul></li><li>后台进程<br>进程中包含不可见的activity(onStop()方法调用后的activity)，后台进程不会直接影响用户体验，为了保证前台进程/可视进程/服务进程的运行，系统随时都可能杀死一个后台进程，一个正确的实现了生命周期方法的activity处于后台时被系统杀死，可以在用户重新启动它时恢复之前的运行状态</li><li>空进程<br>不包含任何处于活动状态的进程是一个空进程，系统进程杀死空进程。这不会造成任何影响，空进程存在的唯一理由是为了缓存一些启动数据，以便下次更快的启动。</li></ul><h3 id="进程优先级的额外说明">进程优先级的额外说明</h3><p>1.系统会赋予进程尽可能高的优先级. 例如一个进程既包含已启动的service, 也包含前台activity, 则这个进程会被视为前台进程。<br></p><p>2.由于组件之间的依赖性, 进程的优先级有可能被提高. 假如进程A服务于进程B, 则进程A的优先级不能低于进程B. 比如, 进程A的ContentProvider组件正在服务于进程B的某个组件, 或者进程A的service组件和进程B的某个组件绑定等, 这些情况下, 进程A的优先级都不会低于进程B(如果按照优先级规则, 进程A的优先级确实低于进程B, 则系统会选择提高进程A的优先级到和进程B相同)。<br></p><p>3.由于服务进程的优先级高于后台进程, 因此如果activity需要执行耗时操作, 最好还是启动一个service来完成. 当然, 在activity中启动子线程完成耗时操作也可以, 但是这样做的缺点在于, 一旦activity不再可见, activity所在的进程成为后台进程, 而内存不足时后台进程随时都有可能被系统杀死(但是启动service完成耗时操作会带来数据交互的问题, 比如耗时操作需要实时更新UI控件的状态的话, service就不是一个好的选择). 基于同样的考虑, 在BroadcastReceiver中也不应该执行耗时操作, 而应该启动service来完成(当然, BroadcastReceiver的生命周期过于短暂, 也决定了不能在其中执行耗时操作).</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小感悟</title>
      <link href="/2017/07/29/%E5%B0%8F%E6%84%9F%E6%82%9F/"/>
      <url>/2017/07/29/%E5%B0%8F%E6%84%9F%E6%82%9F/</url>
      <content type="html"><![CDATA[<p><img src="http://qiniu.xueshiming.cn/%E5%B0%8F%E6%84%9F%E6%82%9F.jpg" alt="小感悟"></p><p>        今天看了VoidKing的博客，有一些自己的感悟吧，谈不上很深，但绝对是触动了自己。<br><br>看到一些句子：<br><br>        好的爱情，其实最终得到的是心灵的休息，没有紧张、无须讨好、放掉面具，两个人都能踏实做自己，而且从不担心对方不能完全接纳自己真实的样子，在欣欣然的放松和喜滋滋的给予中，获得犹如充电般的爱的能量……那是两颗互相懂得的心彼此找到了真正的归宿。——青音<br></p><a id="more"></a><p>        感悟：其实无论爱情的什么阶段，最终都是心灵的栖息，在爱人面前展现的是最真实的自己，不论是不善言谈，还是谈天说地，都是两个人最本真的表达，其实没有什么会觉得无聊，只是在最亲近的人的面前，所表现出来的自己，才是最为自然，最为真挚的情感与细节，没有紧张，无需讨好，真的是两颗互相懂得的心，彼此找到了真正的归宿。<br><br>        证明相爱的最好办法就是分开，难过了，思念了，那就是真爱，就总会有遇见的那天。<br><br>        感悟：如果会遇见，那就是一辈子了吧。<br><br>“当你不去旅行，不去冒险，不去拼一份奖学金，不过没试过的生活，整天挂着QQ，刷着微博，逛着淘宝，玩着网游。干着我80岁都能做的事，你要青春干嘛？”<br>        感悟:曾经的自己也是这样想的，但随着慢慢接触的更多，心情变得越来越浮躁，这个繁华的世界，把自己搞得一团糟，其实不能说是完全的退步，更因该说自己对于“改变”这个词的认识还不够，改变的应该是面对任何事物的陈旧的观念，要接受新事物有些旧的东西，可以说是虽然旧，但真的是过去的自己引以为傲的的东西，这些东西并不能舍弃，要舍弃的是年少无知而养成的习惯或者是生活方式。要是现在和别人做的一样的事情，那以后用什么资本去和他们拼。可能青春需要疯狂，但青春的疯狂绝对不是，谈一场轰轰烈烈的恋爱，也绝对不是做一件让所有人都叹为观止的轰然举动，而是去过没有试过的生活，这是一种让你变得更加优秀的生活。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法</title>
      <link href="/2017/07/28/%E7%AE%97%E6%B3%95/"/>
      <url>/2017/07/28/%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h5 id="二分查找法">二分查找法</h5><p>对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。<br>给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，<br>返回-1。若该元素出现多次，请返回第一次出现的位置</p><a id="more"></a><p>测试样例：</p><blockquote><p>[1,3,5,7,9],5,3</p></blockquote><blockquote><p>返回 ： 1</p></blockquote><p>解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public int getPos(int[] A, int n, int val) &#123;</span><br><span class="line">        // 因为已是有序数组，所以不必排序</span><br><span class="line">        int low=0,high=n-1,mid;</span><br><span class="line">while(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/2;</span><br><span class="line">if(val&lt;A[mid])&#123;</span><br><span class="line">high=mid-1;</span><br><span class="line">&#125;else if(val&gt;A[mid])&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line"></span><br><span class="line">&#125;else &#123;</span><br><span class="line">          //处理两个相邻元素相等情况</span><br><span class="line">                    if(mid&gt;0&amp;&amp;A[mid]==A[mid-1])</span><br><span class="line">                    return mid-1;</span><br><span class="line">                    else return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          int[] A=&#123;1,2,4,4,5,5,6&#125;;</span><br><span class="line">          n=a.length;</span><br><span class="line">          val=5;</span><br><span class="line"> int result=getPos(A, n, val);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="世界上有10种人">世界上有10种人</h5><p>世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？</p><p>public class Solution {<br>public static int countBitDiff(int m, int n) {<br>int k = m ^ n; //先将二者做异或运算，得到结果；<br>int num = 0;<br>while(k&gt;0)<br>{                  //统计一个整数k含有多少个1；<br>k &amp;= (k-1);<br>num++;<br>}<br>return num;<br>}</p><pre><code>public static void main(String[] args) {    int b=count(1999,2299);System.out.println(&quot;-----&quot;+b);}</code></pre><p>}</p><p>举个例子：假如传入数据count(5,3);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        十进制     二进制</span><br><span class="line">         5        0 1 0 1</span><br><span class="line">      ^                      位异或:对应位相反为一，相同为0    </span><br><span class="line">         3        0 0 1 1</span><br><span class="line">      - - - - - - - - - - - -</span><br><span class="line">         6        0 1 1 0</span><br><span class="line">n=1   &amp;                      与运算：对应位都为1，则结果为1，否则为0</span><br><span class="line">         5        0 1 0 1</span><br><span class="line">      - - - - - - - - - - - -</span><br><span class="line">         4        0 1 0 0</span><br><span class="line">n=2   &amp;                      与运算：对应位都为1，则结果为1，否则为0</span><br><span class="line">         3        0 0 1 1</span><br><span class="line">      - - - - - - - - - - - -</span><br><span class="line">         0        0 0 0 0</span><br><span class="line"></span><br><span class="line">      当然结果为2了。</span><br></pre></td></tr></table></figure><p>#####分析一下代码：</p><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><p>ps : 计算机基础，二进制减法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   1 1 0 0 0 0                      1 2 0 0 0</span><br><span class="line">-    1 0 1 1 1            类比        3 9 9 9  </span><br><span class="line">- - - - - - - -         &lt;-----    - - - - - - - -</span><br><span class="line">     1 1 0 0 1                        8 0 0 1</span><br></pre></td></tr></table></figure><h4 id="知识点补充">知识点补充</h4><p>Java 位运算(移位、位与、或、异或、非)</p><h5 id="java提供的位运算符有：左移-右移-无符号右移-位与-位或-位非-位异或-除了位非-是一元操作符外-其它的都是二元操作符">Java提供的位运算符有：左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; ) 、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。</h5><ol><li>左移( &lt;&lt; )</li></ol><p>Test1、将5左移2位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[java]</span><br><span class="line">package com.xcy;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       System.out.println(5&lt;&lt;2);//运行结果是20</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是20，但是程序是怎样执行的呢？<br>首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):<br>0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：<br>0000 0000 0000 0000 0000 0000 0001 0100           换算成10进制为20</p><ol start="2"><li>右移( &gt;&gt; ) ，右移同理，只是方向不一样罢了(感觉和没说一样)<br>[java]<br>System.out.println(5&gt;&gt;2);//运行结果是1<br>还是先将5转为2进制表示形式：<br>0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：<br>0000 0000 0000 0000 0000 0000 0000 0001</li><li>无符号右移( &gt;&gt;&gt; )<br>我们知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高为为1<br>例如  -5换算成二进制后为：<br>1111 1111 1111 1111 1111 1111 1111 1011   (刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。。明明算起来得到的就是一个正数-_-)<br>我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[java]</span><br><span class="line">package com.xcy;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       System.out.println(5&gt;&gt;3);//结果是0</span><br><span class="line">       System.out.println(-5&gt;&gt;3);//结果是-1</span><br><span class="line">       System.out.println(-5&gt;&gt;&gt;3);//结果是536870911</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：</p><p>5换算成二进制：</p><p>0000 0000 0000 0000 0000 0000 0000 0101</p><p>5右移3位后结果为0，0的二进制为：</p><p>0000 0000 0000 0000 0000 0000 0000 0000        // (用0进行补位)</p><p>-5换算成二进制：</p><p>1111 1111 1111 1111 1111 1111 1111 1011</p><p>-5右移3位后结果为-1，-1的二进制为：</p><p>1111 1111 1111 1111 1111 1111 1111 1111   // (用1进行补位)</p><p>-5无符号右移3位后的结果 536870911 换算成二进制：<br>0001 1111 1111 1111 1111 1111 1111 1111   // (用0进行补位)</p><p>通过其结果转换成二进制后，我们可以发现，正数右移，高位用0补，负数右移，高位用1补，当负数<br>使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)<br>注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。(自行测试)</p><h5 id="最后-二进制的运算">最后，二进制的运算</h5><p>参考(<a href="https://www.chinatax.gov.cn/jypx/jsjjczs/multiply.htm" target="_blank" rel="noopener">https://www.chinatax.gov.cn/jypx/jsjjczs/multiply.htm</a>)</p><h5 id="抽象类-与-接口">抽象类 与 接口</h5><ul><li>抽象类：用abstract修饰，抽象类中可以没有抽象方法，但抽象方法肯定在抽象类中，且抽象方法定义时不能有方法体；抽象类不可以实例化只能通过继承在子类中实现其所有的抽象方法；抽象类如果不被继承就没有任何意义；抽象类为子类定义了一个公共类型，封装了子类中的重复内容。</li><li>接口:同Interface关键字定义接口，是特殊的抽象类因为类中只包含抽象方法；接口中不能定义成员变量可以定义常量；接口是其通过其他类使用implements关键字定义实现类，一个类一旦实现接口就必须实现其中的所有抽象方法，一个类可以实现多个接口，接口名之间用逗号隔开即可；一个接口可以通过extends关键字继承另一个接口，与此同时继承了父类中的所有方法。</li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构</title>
      <link href="/2017/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ol><li>排序：</li></ol><p>概念：将一个数据元素(或记录)的任意序列，重新排列成一个按关键字有序的序列。</p><p>分类：</p><ul><li>内部排序和</li><li>外部排序(数据量大时，需要将数据从内存调到外存)</li></ul><a id="more"></a><p>排序的性质：</p><ul><li>稳定排序</li><li>不稳定排序（某个算法规定a&gt;b,在排序过程中始终a&gt;b）</li></ul><p>常用内部排序：</p><ul><li>插入排序：(按查找的方式不同)直接插入排序、折半插入排序、2路插入排序、表插入排序、希尔排序</li><li>交换类排序：冒泡排序、 快速排序</li><li>选择类排序：简单选择排序、堆排序</li><li>归并排序</li><li>分配类排序：多关键字排序、基数排序</li></ul><hr><p>1、  直接插入排序：</p><p>①  思想：将一个元素插入到一个有序表中。下标为 0 的位置作为检测位，从一个元素逐步扩大有序序列</p><p>② 时间复杂度：平均情况:O(n²) 最好情况：O(n) 最坏情况:O(n²)</p><p>③ 空间复杂度：S(n) = O(1)</p><p>④   稳定性：稳定排序。<br>举例：100个数时无序的，先取一个数（习惯取第一个数）拿出来作为有序序列，再将剩下的99个数里取出一个数，插入到有序序列，有序序列在增大，无序序列在减小，排序完成</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line"> if (a[i] &lt; a[i - 1]) &#123;               // 这个加不加都可以</span><br><span class="line">  temp = a[i];                       // 把数组0位置的元素看作有序序列，从数组一位置开始，先把temp=a[1],保留a[1]，</span><br><span class="line">  for (j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; a[j]; j--) &#123;</span><br><span class="line">                                         // 判断a[i-1]与temp的大小 如果temp&lt;a[i-1]，把a[i-1]（大于temp的数后移一位）</span><br><span class="line">   a[j + 1] = a[j];</span><br><span class="line">   a[j] = temp;                     // 直到j减为0 把 temp的值赋值给a[0]; 这里相当于每次都将temp与左边比它大的数交换</span><br><span class="line">  &#125;</span><br><span class="line">                                     // 这里也可以这样a[j+1]=temp; 与 a[j] = temp; 执行结果类似，它是把temp这个位置的值空开了</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 折半插入排序</p><p>①   思想：因为是已经确定了前部分是有序序列，所以在查找插入位置的时候可以用折半查找的方法进行查找，提高效率。</p><p>②   时间复杂度：比较时的时间减为O(n㏒n)，但是移动元素的时间耗费未变，所以总是得时间复杂度还是O(n²)。</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;a.length;i++)&#123;</span><br><span class="line">   if(a[i]&lt;a[i-1])&#123;                         //没有这个判断也可以</span><br><span class="line">    temp=a[i];                             //把a[i]的值缓存</span><br><span class="line">             low=0;    high=i-1;              //标明上界和下界             </span><br><span class="line">             while(low&lt;=high)&#123;                //low=high的时候停止</span><br><span class="line">              mid=(low+high)/2;       </span><br><span class="line">              if(temp&gt;a[mid])&#123;      </span><br><span class="line">               low=mid+1;</span><br><span class="line">              &#125;else high=mid-1;              </span><br><span class="line">             &#125;</span><br><span class="line">             for(j=i;j&gt;low;j--)&#123;              //所有大于temp的数都后移一位 (因为j&gt;low所以a[low]取不到)</span><br><span class="line">              a[j]=a[j-1] ;                  //最后一次移位是将a[low+1]=a[low]</span><br><span class="line">             &#125;</span><br><span class="line">             a[low]=temp;                     //然后把temp的值给a[low]        </span><br><span class="line">   &#125;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>(了解)  2-路插入排序</p><p>① 思想：减少直接插入法的移动元素个数，分成两路子有序序列，需要N个记录的辅助空间</p><p>(了解)  表插入排序</p><p>① 思想：对静态链表做插入排序</p><p>做法：将一个记录插入到已排好序的有序表中，与直接插入不同，已修改2n次指针值代替移动记录</p><p>3、 希尔排序</p><p>①   思想：又称缩小增量排序法。把待排序序列分成若干较小的子序列，然后逐个使用直接插入排序法排序，最后再对一个较为有序的序列进行一次排序，主要是为了减少移动的次数，提高效率。这里是将增量以元素个数的一半开始。</p><blockquote><pre><code>                   38,49,65,97,76,13,27,49</code></pre></blockquote><pre><code>                    |     |     |     |                 0  1  2  3  4  5  6  7</code></pre><p>②   时间复杂度： 平均情况：O(n^1.5) 最好情况：O(n) 最坏情况:O(n²)</p><p>③   空间复杂度：O(1)</p><p>④   稳定性：不稳定排序。{2,4,1,2}，2和1一组4和2一组，进行希尔排序，第一个2和最后一个2会发生位置上的变化。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int Sort(int[] a)&#123;</span><br><span class="line">  int i,j,temp;</span><br><span class="line">    int n=a.length;</span><br><span class="line">    int d=n/2;                //以一半分组</span><br><span class="line">  while(d&gt;=1)&#123;</span><br><span class="line">                            //直接插入排序       把每组内的元素都看成一个序列，对这个序列进行直接插入排序</span><br><span class="line">   for(i=d;i&lt;a.length;i++)&#123; //i++控制 每组要做比较</span><br><span class="line">    temp=a[i];</span><br><span class="line">    for(j=i-d;j&gt;=0&amp;&amp;temp&lt;a[j];j=j-d)&#123;</span><br><span class="line">     a[j+d]=a[j];      </span><br><span class="line">    &#125;</span><br><span class="line">    a[j+d]=temp;</span><br><span class="line">   &#125;  </span><br><span class="line">   d/=2;   </span><br><span class="line">  &#125;     </span><br><span class="line">  for (int k : a) &#123;</span><br><span class="line">   System.out.print(&quot; &quot;+k);</span><br><span class="line">  &#125;     </span><br><span class="line">  return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>4、 冒泡排序</p><p>①   思想：反复扫描待排序序列，在扫描的过程中顺次比较相邻的两个元素的大小，若逆序就交换位置。第一趟，从第一个数据开始，比较相邻的两个数据，（以升序为例）如果大就交换，得到一个最大数据在末尾；然后进行第二趟，只扫描前n-1个元素，得到次大的放在倒数第二位。以此类推，最后得到升序序列。如果在扫描过程中，发现没有交换，说明已经排好序列，直接终止扫描。所以最多进行n-1趟扫描。</p><p>②   时间复杂度：平均 \最坏O(n²) 最好 O(n)</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void Sort(int[] a)&#123;</span><br><span class="line"> for(int i=0;i&lt;a.length-1;i++)&#123; //控制每一趟的比较，因为比较一趟就有一个数不用比较了（i=0  循环完，一个数就不用考虑了，以此类推）需要比较</span><br><span class="line">                                    //比较7次，但是最后一轮，剩下的最后一个数就确定了不用比较了，所以比较6次 即&lt;a.lenth-1 ,注意是&lt;</span><br><span class="line">   for(int j=0;j&lt;a.length-1-i;j++)&#123;  // 因为每次比较完都少一个数所以在a.length-1基础上减i</span><br><span class="line">    if(a[j+1]&lt;=a[j])&#123;</span><br><span class="line">     int temp=a[j+1];</span><br><span class="line">     a[j+1]=a[j];       </span><br><span class="line">     a[j]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">  for (int k : a) &#123;</span><br><span class="line">   System.out.println(k);</span><br><span class="line">  &#125;    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>5、 快速排序</p><p>① 思想：</p><p>E1：对待排序序列进行划分，使前一部分的key值均小于后一部分；为此需要选定枢轴（支点）</p><p>E2：对前半子序列进行快速排序；</p><p>E3：对后半子序列进行快速排序；</p><blockquote><p>思路： low  --------- high</p></blockquote><p>以第一个元素为基准，先从后往前看</p><p>low  左面都比它小，遇到一个比它大的数就换到后面，然后high-1</p><p>high 右面的数都不小于它，遇到一个比它小的数，就换到前面，然后low+1<br>②   时间复杂度：平均T(n) = O(n㏒n)，最坏O(n²)。</p><p>③   空间复杂度：S(n) = O(㏒n)。</p><p>④   稳定性：不稳定排序。{3， 2， 2}</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void Sort(int a[], int low, int hight) &#123;</span><br><span class="line">         int i, j, index;</span><br><span class="line">         if (low &gt; hight) &#123;</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         i = low;</span><br><span class="line">         j = hight;</span><br><span class="line">         index = a[i];          // 用子表的第一个记录做基准</span><br><span class="line">         while (i &lt; j) &#123;        // 从表的两端交替向中间扫描</span><br><span class="line">             while (i &lt; j &amp;&amp; a[j] &gt;= index) //控制</span><br><span class="line">                 j--;</span><br><span class="line">             if (i &lt; j)</span><br><span class="line">                 a[i++] = a[j]; // 用比基准小的记录替换低位记录</span><br><span class="line">             while (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                 i++;</span><br><span class="line">             if (i &lt; j)         // 用比基准大的记录替换高位记录</span><br><span class="line">                 a[j--] = a[i];</span><br><span class="line">         &#125;</span><br><span class="line">         a[i] = index;          // 将基准数值替换回 a[i]</span><br><span class="line">         Sort(a, low, i - 1);   // 对低子表进行递归排序</span><br><span class="line">         Sort(a, i + 1, hight); // 对高子表进行递归排序</span><br><span class="line"></span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>6、 简单选择排序：<br>①   思想：第一趟时，从第一个记录开始，通过n – 1次关键字的比较，从n个记录中选出关键字最小的记录，并和第一个记录进行交换。第二趟从第二个记录开始，选择最小的和第二个记录交换。以此类推，直至全部排序完毕。  /<em>选择排序与前面的简单(冒泡)排序算法思路一模一样，不同的地方在于，在寻找最小元素的时候，前者是每次都将最小元素存放到目的地，而后者则只是暂时存放一下其地址，到最后的时候才需要交换。因此，后者省略了很多的交换操作，更优。</em>/</p><p>②   时间复杂度：最好、最坏、平均情况都是O(n²)。</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：不稳定排序，{3， 3， 2}。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static void Sort(int[] a)&#123;</span><br><span class="line">  int min;</span><br><span class="line">  for(int i=0;i&lt;a.length-1;i++)   //假设有n个元素，需要确定的下标有0到n-1。最后一个元素无需比较</span><br><span class="line">  &#123;   min=i;</span><br><span class="line">   for(int j=i+1;j&lt;a.length;j++)&#123;  </span><br><span class="line">           if(a[j]&lt;a[min])      //使min总是指向最小的元素</span><br><span class="line">            min=j;</span><br><span class="line">   &#125;</span><br><span class="line">          if(min!=i)&#123;             //min有移动过</span><br><span class="line">           int temp =a[i];</span><br><span class="line">           a[i]=a[min];</span><br><span class="line">           a[min]=temp;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>7、堆排序</p><p>①   思想：把待排序记录的关键字存放在数组r[1…n]中，将r看成是一刻完全二叉树的顺序表示，每个节点表示一个记录，第一个记录r[1]作为二叉树的根，一下个记录r[2…n]依次逐层从左到右顺序排列，任意节点r[i]的左孩子是r[2i]，右孩子是r[2i+1]，双亲是r[i/2向下取整]。然后对这棵完全二叉树进行调整建堆。</p><blockquote><p>设有一个关键字集合，按完全二叉树的顺序存储方式存放在一个一维数组中。若满足<br>Ki &lt;= K2i              Ki &gt;= K2i<br>Ki &lt;= K2i+1    或    Ki &gt;= K2i+1<br>则称该关键字集合构成一个堆；<br>前者成为小顶堆，后者称为大顶堆。其中二叉树的根结点称为堆顶。<br>i 和  （2i和2i+1）比较<br>存储结构:数组<br>对应逻辑结构： 二叉树</p></blockquote><p>②   时间复杂度：T(n) = O(n㏒n)。(平均、最好、最坏情况都是)</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：不稳定排序。{5， 5， 3}</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line"> public static void heapSort(int[] array) &#123;</span><br><span class="line">  if (array == null || array.length &lt;= 1) &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buildMaxHeap(array); // 建立大顶堆</span><br><span class="line"></span><br><span class="line">  for (int i = array.length - 1; i &gt;= 1; i--) &#123;</span><br><span class="line">   ArrayUtils.exchangeElements(array, 0, i); // 输出堆顶元素和堆底元素交换</span><br><span class="line"></span><br><span class="line">   maxHeap(array, i, 0);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private static void buildMaxHeap(int[] array) &#123;</span><br><span class="line">  if (array == null || array.length &lt;= 1) &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int half = array.length / 2; // 从i=[n/2]---1反复调整堆</span><br><span class="line">  for (int i = half; i &gt;= 0; i--) &#123;</span><br><span class="line">   maxHeap(array, array.length, i);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private static void maxHeap(int[] array, int heapSize, int index) &#123;</span><br><span class="line">  int left = index * 2 + 1; // 调整元素</span><br><span class="line">  int right = index * 2 + 2;</span><br><span class="line"></span><br><span class="line">  int largest = index;</span><br><span class="line">  if (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;</span><br><span class="line">   largest = left;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">   largest = right;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (index != largest) &#123;</span><br><span class="line">   ArrayUtils.exchangeElements(array, index, largest);</span><br><span class="line"></span><br><span class="line">   maxHeap(array, heapSize, largest);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  int[] array = &#123; 60, 45, 30, 14, 2, 85, 42, 30 &#125;;</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;Before heap:&quot;);</span><br><span class="line">  ArrayUtils.printArray(array);</span><br><span class="line"></span><br><span class="line">  heapSort(array);</span><br><span class="line"></span><br><span class="line">  System.out.println(&quot;After heap sort:&quot;);</span><br><span class="line">  ArrayUtils.printArray(array);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、归并排序<br>①   思想：假设初始序列右n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2向上取整 个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列。在此基础上，在对长度为2的有序子序列进行两两归并，得到若干个长度为4的有序子序列。如此重复，直至得到一个长度为n的有序序列为止。将两个或两个以上的有序表组合成一个新的有序表</p><p>②   时间复杂度：T(n) = O(n㏒n)。(平均、最坏、最好情况都是)</p><p>③   空间复杂度：S(n) = O(n)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line"> /**</span><br><span class="line">  * 归并排序</span><br><span class="line">  * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列</span><br><span class="line">  * 时间复杂度为O(nlogn)</span><br><span class="line">  * 稳定排序方式</span><br><span class="line">  * @param nums 待排序数组</span><br><span class="line">  * @return 输出有序数组</span><br><span class="line">  */</span><br><span class="line"> public static int[] sort(int[] nums, int low, int high) &#123;</span><br><span class="line">  int mid = (low + high) / 2;        //先分一半</span><br><span class="line">  if (low &lt; high) &#123;</span><br><span class="line">   // 左边</span><br><span class="line">   sort(nums, low, mid);</span><br><span class="line">   // 右边</span><br><span class="line">   sort(nums, mid + 1, high);</span><br><span class="line">   // 左右归并</span><br><span class="line">   merge(nums, low, mid, high);</span><br><span class="line">  &#125;</span><br><span class="line">  return nums;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public static void merge(int[] nums, int low, int mid, int high) &#123;</span><br><span class="line">  int[] temp = new int[high - low + 1];</span><br><span class="line">  int i = low;// 左指针</span><br><span class="line">  int j = mid + 1;// 右指针</span><br><span class="line">  int k = 0;</span><br><span class="line"></span><br><span class="line">  // 把较小的数先移到新数组中</span><br><span class="line">  while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">   if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">    temp[k++] = nums[i++];</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">    temp[k++] = nums[j++];</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 把左边剩余的数移入数组</span><br><span class="line">  while (i &lt;= mid) &#123;</span><br><span class="line">   temp[k++] = nums[i++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 把右边边剩余的数移入数组</span><br><span class="line">  while (j &lt;= high) &#123;</span><br><span class="line">   temp[k++] = nums[j++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 把新数组中的数覆盖nums数组</span><br><span class="line">  for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">   nums[k2 + low] = temp[k2];</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> // 归并排序的实现</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">  int[] nums = &#123;5,2,95,48,32,45,11,97,48&#125;;</span><br><span class="line"></span><br><span class="line">  MergeSort.sort(nums, 0, nums.length-1);</span><br><span class="line">  ArrayUtils.printArray(nums);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、分配类排序</p><p>一、多关键字的排序</p><ul><li>高位优先法</li><li>划分子序列的思想</li><li>低位优先法</li><li>分配再收集的思想</li></ul><p>二、链式基数排序<br>①   思想：先分配，再收集，就是先按照一个次关键字收集一下，然后进行收集（第一个排序），然后再换一个关键字把新序列分配一下，然后再收集起来，又完成一次排序，这样所有关键字分配收集完后，就完成了排序。</p><p>②   时间复杂度：T(n) = O( d ( n + rd ) )。</p><p>③   空间复杂度：S(n) = O(rd)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><p>10、 总结：</p><p>（1）简单排序法一般只用于n较小的情况（例如n&lt;30）。当序列的记录“基本有序”时，直接插入排序是最佳的排序方法。如果记录中的数据较多，则应采用移动次数较少的简单选择排序法。</p><p>（2）快速排序、堆排序和归并排序的平均时间复杂度均为O(n㏒n)，但实验结果表明，就平均时间性能而言，快速排序是所有排序方法中最好的。遗憾的是，快速排序在最坏情况下的时间性能为O(n²)。堆排序和归并排序的最坏时间复杂度仍为O(n㏒n)，当n较大时，归并排序的时间性能优于堆排序，但它所需的辅助空间最多。</p><p>（3）可以将简单排序法与性能较好的排序方法结合使用。例如，在快速排序中，当划分子区间的长度小于某值时，可以转而调用直接插入排序法；或者先将待排序序列划分成若干子序列，分别进行直接插入排序，然后再利用归并排序法，将有序子序列合并成一个完整的有序序列。</p><p>（4）基数排序的时间复杂度可以写成O(d·n)。因此，它最适合于n值很大而关键字的位数d较小的序列。当d远小于n时，其时间复杂度接近O(n)。</p><p>（5）从排序的稳定性上来看，在所有简单排序法中，简单选择排序是不稳定的，其他各种简单排序法都是稳定的。然而，在那些时间性能较好的排序方法中，希尔排序、快速排序、堆排序都是不稳定的，只有归并排序、基数排序是稳定的。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的java（三）</title>
      <link href="/2017/07/16/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2017/07/16/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java基础第二天打卡：每天都过一点java基础，这些看似可以忽略的往往最不可以忽略。</p><a id="more"></a><p>在 Java 程序中，通过类的定义只能实现 单 重继承，但通过接口的定义可以实现 多 重继承关系。</p><h5 id="关于继承">关于继承</h5><p>在java中，子类构造器会默认调用super()(无论构造器中是否写有super（）),用于初始化父类成员，同时当父类中存在有参构造器时，必须提供无参构造器，子类构造器中并不会自动继承有参构造器，仍然默认调用super()，使用无参构造器。因此，一个类想要被继承必须提供无参构造器。</p><p>通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。</p><p>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p><hr> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void waitForSignal()</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = new Object();</span><br><span class="line">    synchronized(Thread.currentThread())</span><br><span class="line">    &#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">        obj.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题有两个错误的地方，第一个错误是 wait() 方法要以 try/catch 包覆，或是掷出 InterruptedException 才行<br>因此答案就是因为缺少例外捕捉的   InterruptedException<br>第二个错误的地方是， synchronized 的目标与 wait() 方法的物件不相同，会有 IllegalMonitorStateException ，不过 InterruptedException 会先出现，所以这不是答案<br>最后正确的程式码应该是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitForSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">         <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">obj.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">obj.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="java程序的种类">java程序的种类</h5><p>Java程序的种类有：<br>（a）内嵌于Web文件中，由浏览器来观看的_Applet<br>（b）可独立运行的 Application<br>（c）服务器端的 Servlets</p><p>Serverlets的工作是：<br>读入用户发来的数据（通常在web页的form中）<br>找出隐含在https请求中的其他请求信息（如浏览器功能细节、请求端主机名等。<br>产生结果(调用其他程序、访问数据库、直接计算)<br>格式化结果（网页）<br>设置https response参数(如告诉浏览器返回文档格式)<br>将文档返回给客户端。</p><h5 id="方法通常存储在进程中的代码区">方法通常存储在进程中的代码区</h5><p><a href="https://www.cnblogs.com/liulipeng/archive/2013/09/13/3319675.html" target="_blank" rel="noopener">参考链接</a></p><h5 id="开发java程序的三个步骤">开发JAVA程序的三个步骤</h5><ol><li>编写JAVA的源程序</li><li>编译程序生成字节码.class文件(java是高级语言，不会直接生成机器语言)</li><li>通过JVM解释执行（通过jvm解释为特定的操作系统如Windows、Linux等能理解的机器码，最终JAVA程序得以执行）</li></ol><h5 id="jsp内置对象有">JSP内置对象有</h5><p>jsp九大内置对象：</p><p>request,response,  session,out,page,application,exception,pagecontext,config</p><h5 id="基本类型四类八种-其余全是引用类型">基本类型四类八种 其余全是引用类型</h5><p>四类八种：<br>整数（byte short int long)<br>浮点数(float double)<br>字符型(char)<br>逻辑性(boolean)<br>注意大小写，大写的是封装基本类型的引用类型。<br>byte - Byte<br>short - Short<br>int - Integer<br>long - Long<br>float - Float<br>double - Double<br>char - Charactor<br>boolean - Boolean</p><h5 id="构造方法">构造方法</h5><ol><li>定义：</li></ol><ul><li>使用关键字new实例化一个新对象的时候默认调用的方法</li><li>构造方法所完成的主要工作是对新创建对象的数据成员赋初值</li></ul><ol start="2"><li>使用时需注意:</li></ol><ul><li>构造方法名称和其所属的类名必须保持一致</li><li>构造方法没有返回值，也不可以使用void</li><li>构造方法也可以像普通方法一样被重载</li><li>构造方法不能被static和final修饰</li><li>构造方法不能被继承，子类使用父类的构造方法需要使用super关键字</li></ul><h5 id="类构造方法中调用父类构造方法用super-调用本类其他的构造方法用this-super和this都只能位于类构造方法的第一行-不能同时存在">类构造方法中调用父类构造方法用super，调用本类其他的构造方法用this。 super和this都只能位于类构造方法的第一行，不能同时存在</h5><h4 id="以下输出结果是">以下输出结果是</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    String str = new String(&quot;good&quot;);</span><br><span class="line">    char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Example ex = new Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + &quot; and &quot;);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void change(String str, char ch[])      </span><br><span class="line">   &#123;</span><br><span class="line">        str = &quot;test ok&quot;;</span><br><span class="line">        ch[0] = &apos;g&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>good and gbc</p></blockquote><p>说法一：</p><ol><li>概念：</li></ol><p>java传参只有按值传递（也就是把实参的值拷贝给形参，这个值可以是普通的数值，也可以是地址值），java中的对象只能通过指向它的引用来操作，这个引用本身也是变量，不要与C/C++中的传值与传址混淆了，java中没有显式的指针。</p><p>分析：change函数被调用时，第一个形参str接收了类的成员变量str的值（虽然名称都是str，但是却是两个独立的String类型的引用变量），注意这两个str自身都是变量且都指向了堆内存中的String对象&quot;good&quot;，当我们在change函数内部将str指向了另一个String对象&quot;test ok&quot;后，类的成员变量str仍然保持指向&quot;good&quot;，所以最终打印出来就是&quot;good&quot;；对于第二个形参ch，它也是接收了类的成员变量ch的值拷贝，这一点和str没有差别，即两个ch都指向了字符数组{ ‘a’, ‘b’, ‘c’ }的首地址，但是ch[0]表示的是字符数组中’a’的地址，修改了它也就修改了字符数组的第一个元素，这个改变在change函数返回之后也会存在。所以本题中两个形参传参的本质区别在于，修改str只是将形参指向了新的对象，对外部的实参没有任何影响，而修改ch[0]是实实在在的修改了字符数组的首元素。</p><ol start="2"><li>拓展</li></ol><ul><li>可以试验一下，在Example中再定义一个字符数组char[] ch2={‘d’};然后在change函数中把ch[0] = ‘g’;这句改成ch=ch2;，那么就会和str传参一样的，change函数返回后不会对类的成员ch有任何影响。</li><li>本题和“String类是一个final类，不能被继承”以及“String底层的字符数组被声明为private final char value[];所以其值不能被修改”这些String的特性无关。</li><li>我们平时交换数组中的两个元素时，一般定义swap方法为 void swap(int[] a, int i, int j)，想想看为什么能达到目的？如果不使用数组，能实现交换吗？数组中存放的不是基本类型变量而是引用类型变量呢？</li></ul><p>说法二:</p><p>其实都是引用传递，只是因为String是个特殊的final类，所以每次对String的更改都会重新创建内存地址并存储（也可能是在字符串常量池中创建内存地址并存入对应的字符串内容），但是因为这里String是作为参数传递的，在方法体内会产生新的字符串而不会对方法体外的字符串产生影响。</p><h5 id="关于string">关于String</h5><blockquote><p>String str1 = “hello”;<br>String str2 = “he” + new String(“llo”);<br>System.err.println(str1 == str2);</p></blockquote><p>解释：String str1 = “hello”;这里的str1指的是方法区的字符串常量池中的“hello”，编译时期就知道的； String str2 = “he” + new String(“llo”);这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”，所以这两个引用是不一样的。<br>如果用str1.equal(str2)，那么返回的是True；因为两个字符串的内容一样。</p><h5 id="自动拆装箱">自动拆装箱</h5><ol><li>基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；</li><li>两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。</li><li>两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true</li><li>基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</li></ol><p>解释：</p><blockquote><p>int a=257;<br>Integer b=257;<br>Integer c=257;<br>Integer b2=57;<br>Integer c2=57;<br>System.out.println(a==b);<br><a href="//System.out.println">//System.out.println</a>(a.equals(b));  编译出错，基本型不能调用equals()<br>System.out.println(b.equals(257.0));<br>System.out.println(b==c);<br>System.out.println(b2==c2);</p></blockquote><p>因此上面的代码的结果因此为 true, false, false, true</p><h5 id="java多线程间的通讯之等待唤醒机制">java多线程间的通讯之等待唤醒机制</h5><h5 id="1-wait-notify-和notifyall-是-object类-中的方法">1. wait()、notify()和notifyAll()是 Object类 中的方法</h5><ol><li>wait()、notify()和notifyAll()是 Object类 中的方法</li><li>调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）</li><li>调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程</li><li>调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；</li></ol><ul><li>wait()方法被某个对像调用时，相当于让当前线程交出此对象的monitor，然后进入等待状态，<br>等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从<br>而让其他线程有机会继续执行，但它并不释放对象锁）；</li><li>notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象<br>的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。<br>同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用<br>notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。</li><li>nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。</li></ul><h5 id="condition是在java-1-5中才出现的-它用来替代传统的object的wait-notify-实现线程间的协作-相比使用object的wait-notify-使用condition1的await-signal-这种方式实现线程间协作更加安全和高效-因此通常来说比较推荐使用condition-在阻塞队列那一篇博文中就讲述到了-阻塞队列实际上是使用了condition来模拟线程间协作">Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作</h5><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll()</li></ul><h5 id="一个选择题教你学方法重写">一个选择题教你学方法重写</h5><p>如果一个接口Cow有个方法drink()，有个类Calf实现接口Cow，则在类Calf中正确的是？  ©</p><ul><li>A. void drink() { …}</li><li>B. protected void drink() { …}</li><li>C. public void drink() { …}</li><li>D. 以上语句都可以用在类Calf中</li></ul><h5 id="假设-a-类有如下定义-设-a-是-a-类的一个实例-下列语句调用哪个是错误的？">假设 A 类有如下定义，设 a 是 A 类的一个实例，下列语句调用哪个是错误的？（）</h5><blockquote><p>Class A<br>{<br>Int i;<br>Static String s;<br>Void method1(){}<br>Static void method2(){}<br>}</p></blockquote><p>解析：静态成员和静态方法，可以直接通过类名进行调用；其他的成员和方法则需要进行实例化成对象之后，通过对象来调用。<br>所以a.method1();(对)、A.method2();(对)、 A.method1();(错)</p><h5 id="java-多态">java 多态</h5><p>抽象类或者接口根本无法实例化</p><h5 id="哪些情况可以终止当前线程的运行">哪些情况可以终止当前线程的运行?</h5><ul><li>优先级高的并不一定会马上执行。</li><li>sleep方法会阻塞一个线程并不会终止</li><li>创建一个新的线程时也不会终止另一个线程</li><li>当抛出一个异常后程序会结束，所以线程也会被终止</li></ul><h5 id="java不允许单独的方法-过程或函数存在-需要隶属于某一类中-java语言中的方法属于对象的成员-而不是类的成员-不过-其中静态方法属于类的成员">java不允许单独的方法，过程或函数存在,需要隶属于某一类中; java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员</h5><h5 id="equals-和-的区别">equals()和==的区别</h5><blockquote><p>String s1=“abc”+“def”;//1<br>String s2=new String（s1);//2<br>if(s1.equals(s2))//3<br>System.out.println(&quot;.equals succeeded&quot;);//4<br>if(s1==s2)//5<br>System.out.println(&quot;==succeeded&quot;);//6</p></blockquote><p>equals（）比较的是字符串的内容，==比较的是内存地址值</p><p>s1存放在常量池中 s2存放在堆区中  内存地址值是不一样的</p><h5 id="垃圾回收机制-如题">垃圾回收机制，如题</h5><blockquote><p>static String str0=“0123456789”;<br>static String str1=“0123456789”;<br>String str2=str1.substring(5);<br>String str3=new String(str2);<br>String str4=new String(str3.toCharArray());<br>str0=null;<br>假定str0,…,str4后序代码都是只读引用。<br>Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）</p></blockquote><p>垃圾回收主要针对的是堆区的回收，因为栈区的内存是随着线程而释放的。<br>堆区分为三个区：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。<br>年轻代：对象被创建时（new）的对象通常被放在Young（除了一些占据内存比较大的对象）,经过一定的Minor GC（针对年轻代的内存回收）还活着的对象会被移动到年老代（一些具体的移动细节省略）。年老代：就是上述年轻代移动过来的和一些比较大的对象。Minor GC(FullGC)是针对年老代的回收<br>永久代：存储的是final常量，static变量，常量池。<br>str3,str4都是直接new的对象，而substring的源代码其实也是new一个string对象返回，如下图：<br>经过fullgc之后，年老区的内存回收，则年轻区的占了15个，不算PermGen。所以答案为15。</p><h5 id="java设计模式之单例模式">java设计模式之单例模式</h5><p>参考博客(<a href="https://blog.csdn.net/jason0539/article/details/23297037/" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/23297037/</a>)</p><h5 id="java-stack-和heap-的区别">java stack 和heap 的区别</h5><p>参考博客(<a href="https://blog.csdn.net/wl_ldy/article/details/5935528" target="_blank" rel="noopener">https://blog.csdn.net/wl_ldy/article/details/5935528</a>)</p><h5 id="关于iterator-迭代器">关于iterator(迭代器)</h5><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<br>Java中的Iterator功能比较简单，并且只能单向移动：</p><ol><li>使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li><li>使用next()获得序列中的下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器新返回的元素删除。</li></ol><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><p>迭代器应用：</p><blockquote><p>list<string> l = new ArrayList<string>();<br>l.add(“aa”);<br>l.add(“bb”);<br>l.add(“cc”);<br>for (Iterator iter = l.iterator(); iter.hasNext()<img class="emoji" draggable="false" alt="😉" src="https://twemoji.maxcdn.com/2/72x72/1f609.png"> {<br>String str = (String)iter.next();<br>System.out.println(str);<br>}<br>//迭代器用于while循环<br>Iterator<string> iter = l.iterator();<br>while(iter.hasNext()){<br>String str = (String) iter.next();<br>System.out.println(str);<br>if(str.equals(“aa”)){<br>System.out.println(&quot;----------------------&quot;);<br>iter.remove();<br>System.out.println(l.toString);<br>}<br>}<br>输出结果：<br>aa<br>bb<br>cc</string></string></string></p></blockquote><hr><p>[bb, cc]</p><p>下面给出一个例题:</p><blockquote><p>Iterator it = list.iterator();<br>int index = 0;<br>while (it.hasNext())<br>{<br>Object obj = it.next();<br>if (needDelete(obj))  //needDelete返回boolean，决定是否要删除<br>{<br>//如何在这里可以，在Iterator遍历的过程中正确并安全的删除一个list中保存的对象<br>}<br>index ++;<br>}</p></blockquote><p>答案：it.remove();</p><p>解释：<br>如果在循环的过程中调用集合的remove()方法，例如：</p><blockquote><p>for(int i=0;i&lt;list.size();i++){<br>list.remove(…);<br>}</p></blockquote><p>循环过程中list.size()的大小变化了，就会导致导list中的元素删除不完全。<br>所以，如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。</p><h5 id="spring-支持-7-种事务传播行为">Spring 支持 7 种事务传播行为</h5><ul><li>PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</li><li>PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li></ul><h5 id="集合小结">集合小结</h5><ol><li>List（有序、可重复）<br>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</li><li>Set（无序、不能重复）<br>Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。</li><li>Map（键值对、键唯一、值不唯一）<br>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。</li></ol><p>集合类汇总(<a href="https://www.cnblogs.com/leeplogs/p/5891861.html" target="_blank" rel="noopener">https://www.cnblogs.com/leeplogs/p/5891861.html</a>)</p><h5 id="replaceall-方法">replaceAll() 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String[] args) &#123;</span><br><span class="line">    String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;;</span><br><span class="line">    System.out.println(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：///////MyClass.class</p></blockquote><p>由于replaceAll方法的第一个参数是一个正则表达式，而&quot;.“在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/&quot;。如果想替换的只是&quot;.&quot;，那么久要写成&quot;\.&quot;.</p><h5 id="对象序列化的描述">对象序列化的描述</h5><p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.</p><p>声明为static和transient类型的成员数据不能被串行化。因为static代表类的状态， transient代表对象的临时数据。</p><p>在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。</p><h5 id="jsp中静态include和动态include的区别">jsp中静态include和动态include的区别</h5><ol><li><p>动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=“included.jsp” flush=“true” /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。</p></li><li><p>静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=“included.htm” %&gt; 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相同的变量。</p></li><li><p>两者的区别:</p><p>一: 执行时间上 :</p><p>&lt;%@ include file=“relativeURI”%&gt; 是在翻译阶段执行<br>&lt;jsp:include page=“relativeURI” flush=“true” /&gt; 在请求处理阶段执行 .</p><p>二: 引入内容的不同 :</p><p>&lt;%@ include file=“relativeURI”%&gt;<br>引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 .<br>&lt;jsp:include page=“relativeURI” flush=“true” /&gt; 引入执行页面或 servlet 所生成的应答文本 .</p></li></ol><h5 id="变量引用">变量引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Replaces &#123;</span><br><span class="line">       public int x;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  System. out. println(&quot;Value is&quot; + x);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正：实例化Replaces 或 public static int  x;</p><p>原因：非静态成员只能被类的实例化对象引用，因此这里在静态方法中访问x会造成编译出错</p><h5 id="aop和oop">AOP和OOP</h5><p>AOP 和 OOP的区别：</p><ol><li>面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。</li><li>面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。<br>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</li></ol><h5 id="类的初始化顺序">类的初始化顺序</h5><p>静态优先，父类优先</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class HelloA&#123;</span><br><span class="line">public HelloA()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I’m A class &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(&quot;static A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HelloB extends HelloA&#123;</span><br><span class="line">    public HelloB()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I’m B class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;static B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">        new HelloB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：static A static B I’m A class I’m B class</p></blockquote><h5 id="resultset中记录行的第一列索引为1">ResultSet中记录行的第一列索引为1</h5><h5 id="jsp">JSP</h5><p>A JSP脚本(Scriptlet)，是Java代码块。</p><p>C JSP表达式(expression)，表达式是一个有返回值的式子，它返回的结果将由out.print()进行输出。</p><p>所以jsp表达式写法：<br>&lt;%= expression %&gt;</p><p>c语言&amp;&amp;和||的短路性质分析：<br>(<a href="https://blog.csdn.net/yhj110911119/article/details/52436085" target="_blank" rel="noopener">https://blog.csdn.net/yhj110911119/article/details/52436085</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的Java（二）</title>
      <link href="/2017/07/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/07/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>好几天的java基础知识都写在了前两篇里，感觉有些多和杂，今天再写新的一篇，每天做30道java的题目，感觉自己的基础知识就得好好巩固一下。</p><a id="more"></a><h5 id="java的跨平台特性">java的跨平台特性</h5><p>我们编译好的文件是以.java后缀保存的，编译器会自动帮我们生成一个标准的.class字节码文件，JVM运行该文件。JVM也是一个软件，不同的系统平台JVM不同，但都可以实现标准的.class字节码文件。</p><h5 id="数据库事务的隔离级别">数据库事务的隔离级别</h5><p>4个。由低到高依次为Read uncommitted(未授权读取、读未提交)、Read committed（授权读取、读提交）、Repeatable read（可重复读取）、Serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题</p><pre><code>                     √: 可能出现    ×: 不会出现</code></pre><table><thead><tr><th></th><th style="text-align:center">脏读</th><th style="text-align:right">不可重复读</th><th style="text-align:right">幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td style="text-align:center">√</td><td style="text-align:right">√</td><td style="text-align:right">√</td></tr><tr><td>Read committed</td><td style="text-align:center">×</td><td style="text-align:right">√</td><td style="text-align:right">√</td></tr><tr><td>Repeatable read</td><td style="text-align:center">×</td><td style="text-align:right">×</td><td style="text-align:right">√</td></tr><tr><td>Serializable</td><td style="text-align:center">×</td><td style="text-align:right">×</td><td style="text-align:right">×</td></tr></tbody></table><h5 id="关于instanceof">关于instanceof</h5><p>instanceof 用来在运行时指出对象是否是特定类的一个实例，instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</p><h5 id="异常">异常</h5><p>checked exception：指的是编译时异常，该类异常需要本函数必须处理的，用try和catch处理，或者用throws抛出异常，然后交给调用者去处理异常。</p><p>runtime exception：指的是运行时异常，该类异常不必须本函数必须处理，当然也可以处理。<br>Thread.sleep()抛出的InterruptException属于checked exception；IllegalArgumentException属于Runtime exception;</p><h5 id="java语言的下面几种数组复制方法中-哪个效率最高？">java语言的下面几种数组复制方法中，哪个效率最高？</h5><p>效率：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环<br>A：for循环，效率最低，随便写个程序验证一下，效率慢的不是一点…我测试的时候比clone和System.arraycopy差了100多倍</p><p>B：System.arraycopy：原型是<br>public static native void arraycopy(Object src,  int  srcPos , Object dest, int destPos, int length);</p><p>C：Arrays.copyOf底层调用了上面的System.copyOf效率比上面两个低。</p><p>D：clone()的完整定义：protected native Object clone() throws CloneNotSupportedException;</p><h5 id="java多线程的叙述正确的是">JAVA多线程的叙述正确的是</h5><p>Callable类的call()方法可以返回值和抛出异常</p><p>#####　以下将打印出</p><blockquote><p>public static void main(String args[]) {<br>List  Listlist1 = new ArrayList();<br>Listlist1.add(0);<br>List Listlist2 = Listlist1;<br>System.out.println(Listlist1.get(0) instanceof Integer);<br>System.out.println(Listlist2.get(0) instanceof Integer);<br>}</p></blockquote><blockquote><p>true  true</p></blockquote><p>解析 :<br>collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据，该题中装入了0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。</p><p>将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)</p><h5 id="如果希望监听tcp端口9000-应该怎样创建socket">如果希望监听TCP端口9000，应该怎样创建socket?</h5><blockquote><p>new ServerSocket(9000);</p></blockquote><h5 id="抽象类-abstract-class-和接口-interface-的区别">抽象类(abstract class)和接口(interface)的区别</h5><ol><li>含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</li><li>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br>下面比较一下两者的语法区别：</li></ol><ul><li>抽象类可以有构造方法，接口中不能有构造方法</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li><li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</li><li>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态方法，接口中不能包含静态方法</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ul><p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，</p><p>例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码.</p><h5 id="ant和maven">Ant和Maven</h5><p>Ant和Maven都是基于Java的构建(build)工具。理论上来说，有些类似于（Unix）C中的make ，但没有make的缺陷。Ant是软件构建工具，Maven的定位是软件项目管理和理解工具。</p><ol><li>Ant特点 <br>没有一个约定的目录结构 必须明确让ant做什么，什么时候做，然后编译，打包 没有生命周期，必须定义目标及其实现的任务序列 没有集成依赖管理</li><li>Maven特点<br>拥有约定，知道你的代码在哪里，放到哪里去 拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮你处理其他事情 拥有依赖管理，仓库管理</li></ol><h5 id="强制转换">强制转换</h5><p>byte和short型在计算时会自动转换为int型计算，结果也是int 型<br>低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte=char=short&lt;int&lt;long&lt;float&lt;double<br>byte,short,char是同级别的，不能自动转换</p><h5 id="finally-关键字">finally 关键字</h5><ol><li>选项在 final 定义的方法里，不是必须要用 final 定义变量。</li><li>final 定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化。</li><li>正确，final修饰方法，不能被子类重写，但是可以被重载。</li><li>final 定义变量，可以用 static</li></ol><p>final修饰的类不能被继承， final 修饰的方法不能被重写，final修饰的属性在第一次被赋值后不可再更改值。</p><h5 id="以下程序输出结果">以下程序输出结果</h5><blockquote><p>class HasStatic{<br>private static int x=100;<br>public static void main (String args[]){<br>HasStatic hs1=new HasStatic();<br>hs1.x++;<br>HasStatic hs2=new HasStatic();<br>hs2.x++;<br>hs1=new HasStatic();<br>hs1.x++;<br>HasStatic.x–;<br>System.out.println(“x=” +x);<br>}<br>}</p></blockquote><p>因为x的 修饰符为 static 所以x为类变量，即对于所有的实例来说，他们访问的x为同一个x，类变量存储在方法区，不属于每个实例的私有，</p><p>刚开始x=100</p><p>调用hs1.x++   x为101;</p><p>调用hs2.x++   x为102;</p><p>调用hs1.x++   x为103 (此时hs1指向了一个新的HasStatic实例，但是依然访问的是同一个X)</p><p>调用HasStatic.x--  x为102</p><p>所以结果为D</p><h5 id="java-中的-wait-方法和-sleep-方法的区别">java 中的 wait()方法和 sleep()方法的区别</h5><ol><li>这两个方法来自不同的类分别是Thread和Object</li><li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。</li><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在<br>任何地方使用<br>synchronized(x){<br>x.notify()<br>//或者wait()<br>}</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li></ol><h5 id="java-object类">java Object类</h5><p>一共有11个： equals . getClass . hashCode . toString . notify .notifyAll .<br>wait . finalize . clone</p><h5 id="一个小题">一个小题</h5><blockquote><p>public class TestClass {<br>private static void testMethod(){<br>System.out.println(“testMethod”);<br>}<br>public static void main(String[] args) {<br>((TestClass)null).testMethod();<br>}<br>}</p></blockquote><p>我来总结下大家的分析。<br>1）此处是类对方法的调用，不是对象对方法的调用。<br>2）方法是static静态方法，直接使用&quot;类.方法&quot;即可，因为静态方法使用不依赖对象是否被创建。<br>null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。<br>3）非静态的方法用&quot;对象.方法&quot;的方式，必须依赖对象被创建后才能使用，若将testMethod()方法前的static去掉，则会报 空指针异常 。此处也验证了2）的观点<br>当然，不管是否静态方法，都是已经存在的，只是访问方式不同。</p><h5 id="线程安全的集合类">线程安全的集合类</h5><p>简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration</p><p>java1.8实测，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default</p><h5 id="webservice">webService</h5><p>Webservice是跨平台，跨语言的远程调用技术</p><p>它的通信机制实质就是xml数据交换;</p><p>它采用了soap协议（简单对象协议）进行通信</p><h5 id="super关键字">super关键字</h5><p>super是java提供的一个关键字，super用于限定该对象调用它从父类继承得到的Field或方法。super关键字不能出现在static修饰的方法中，因为static修饰的方法是属于类的。如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的field，而不是该类自己定义的field。需要注意的是，super关键字只能指代直接父类，不能指代父类的父类。（需要好好理解）</p><h5 id="java垃圾回收机制">java垃圾回收机制</h5><p>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。<br>当对象的引用变量被赋值为null，可能被当成垃圾。</p><p>对于“程序可明确地标识某个局部变量的引用不再被使用”说法错误</p><p>因为，局部变量存放在栈上，栈上的垃圾回收，由finalize()来实现。</p><p>参考(<a href="https://www.importnew.com/19085.html" target="_blank" rel="noopener">https://www.importnew.com/19085.html</a>)</p><h5 id="重要的知识-可以自己实测">重要的知识，可以自己实测</h5><p>静态内部类可以访问外围类的静态数据，包括（静态）私有数据，但不能访问非静态数据；<br>非静态内部类可以直接访问外围类的数据，包括私有数据</p><h5 id="final修饰变量">final修饰变量</h5><p>一、final修饰变量</p><ol><li>final可以修饰成员变量，也可以修饰局部变量、形参。final变量一旦获得初始值之后，final的变量就不能被重新赋值。</li></ol><p>成员变量是随类初始化或对象初始化而初始化的，当执行静态初始化块时候可以对类属性进行赋初始值，当执行普通初始化块或者构造器的时候可以对实例属性赋初始值。因此成员变量的初始值可以在定义的时候赋值或者在初始化块、构造器中指定。</p><p>对于final修饰的成员变量而言，一旦有了初始值之后，就不能被重新赋值，因此不可以在普通方法中对成员变量赋值。要么在定义的时候赋值，要么在方法块和构造器中赋值。<br>final成员变量，必须由程序员显示初始化，系统不会对final成员进行隐式初始化。</p><ol start="2"><li>final修饰局部变量时既可以在定义时候指定默认值，也可以不指定，在后面指定，但只能一次。</li><li>final修饰基本类型的时候 变量不能改变</li><li>final修饰引用类型变量，final只保证这个引用的地址不变，即一直引用同一对象。但这个对象可以改变。</li></ol><h5 id="java-构造函数使用方法总结">java 构造函数使用方法总结</h5><p>使用构造器时需要记住：</p><ol><li>构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个、1个或1个以上的参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作一起调用</li></ol><p>使用super调用父类构造器的语句必须是子类构造器的第一条语句</p><p>如果子类构造器没有显式地调用父类的构造器，则将自动调用父类的默认（没有参数）的构造器。如果父类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用父类的构造器，则java编译器将报告错误</p><h5 id="jvm中垃圾回收分为scanvenge-gc和full-gc-其中full-gc触发的条件可能有哪些">jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些</h5><ol><li>新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。</li><li>老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。</li><li>持久代：持久代如果满了，将触发Full GC。，System.gc是有可能触发full gc的</li></ol><h5 id="关于string-stringbuilder以及stringbuffer">关于String，StringBuilder以及StringBuffer</h5><p>A. java中的字符串存储在字符串常量区，不会改变，发生改变是会新创建一个对象<br>B. StringBuffer是线程安全的StringBuilder<br>C. StringBuilder跟StringBuffer功能相同，区别是StringBuilder不是线程安全的<br>D. StringBuilder和StringBuffer底层都是以字符数组存放的，可以修改内容</p><h5 id="jdk提供的用于并发编程的同步器有哪些">JDK提供的用于并发编程的同步器有哪些</h5><p>A. Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>B. CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>C. 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p><h5 id="jre-判断程序是否执行结束的标准是">jre 判断程序是否执行结束的标准是（）</h5><p>所有的前台线程执行完毕</p><p>#####　经过强制类型转换以后，变量a, b的值分别为（ ）short a = 128; byte b = (byte) a;<br>128  -128</p><p>解析：byte在内存中占一个字节，范围是 -128到127之间。<br>将128强制类型转换为byte型，就超出了byte型的范围，<br>128的二进制存储是 1000 0000 转换为byte型后，最高位是符号位，值是-128</p><h5 id="java异常类">JAVA异常类</h5><p>参考(<a href="https://www.cnblogs.com/sargeles/p/6691383.html" target="_blank" rel="noopener">https://www.cnblogs.com/sargeles/p/6691383.html</a>)</p><h5 id="有关jvm内存">有关JVM内存</h5><p>运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器<br>虚拟机栈区 ：也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。<br>堆区 ， JAVA 堆，也称 GC 堆，所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。<br>方法区 ：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。<br>程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。</p><h5 id="hashmap跟hashtable的区别">hashMap跟hashTable的区别</h5><p>①继承不同。</p><blockquote><p>public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map</p></blockquote><p>②<br>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br>③<br>Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>④两个遍历方式的内部实现上不同。<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>⑤<br>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>⑥<br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><h5 id="下列说法">下列说法</h5><p>A. ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized;<br>B. HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Cllectio<br>C. Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；<br>D. SimpleDateFormat是线程不安全的</p><h5 id="对于以下程序-输出">对于以下程序 输出</h5><blockquote><p>public class StringDemo{<br>private static final String MESSAGE=“taobao”;<br>public static void main(String [] args) {<br>String a =“tao”+“bao”;<br>String b=“tao”;<br>String c=“bao”;<br>System.out.println(a==MESSAGE);<br>System.out.println((b+c)==MESSAGE);<br>}<br>}<br>true false</p></blockquote><p>要注意两个问题：<br>1，字符串在java中存储在字符串常量区中<br>2，==判断的是对象引用是否是同一个引用，判断字符串相等要用equals方法<br>首先判断a==MESSAGE 同一份字符串常量在内存中只有一份，因此是同一地址，返回true<br>再次比较(b+c)==MESSAGE 这相当于 new String(b+c)==MESSAGE 这里new了一个String对象，所以返回false</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的Java（一）</title>
      <link href="/2017/07/09/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/07/09/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>关于java基础的一些概念性、理论性的东西，好久没碰了，现在回过头来看看，有助于自己更深层次的提高，所以在此总结一下。</p><a id="more"></a><h5 id="方法的重写">方法的重写</h5><ol><li>概念：子父类出了同名的函数，这个我们就称作为方法的重写。</li><li>方法重写的前提： 必须要存在继承的关系。</li><li>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</li><li>方法重写要注意的事项：(“两同两小一大”)</li></ol><ul><li>方法重写时，方法名与形参列表必须一致。(“两同”)</li><li>方法重写时，子类的返回值类型必须要小于或者等于父类的返回值类型(“小”)</li><li>方法重写时，子类抛出的异常类型要小于或者等于父类抛出的异常类型(“小”)</li><li>方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符(“一大”)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception(最坏)</span><br><span class="line">RuntimeException(小坏)</span><br></pre></td></tr></table></figure><h5 id="方法的重载">方法的重载</h5><ol><li>概念：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</li><li>方法重载的要求</li></ol><ul><li>函数名要一致</li><li>形参列表不一致（形参个数或形参的类型不一致）</li><li>与返回值类型无关</li></ul><h5 id="java运算符优先级助记口诀">java运算符优先级助记口诀</h5><p>单目乘除为关系，逻辑三目后赋值。</p><ul><li>单目：单目运算符+ –(负数) ++ – 等</li><li>乘除：算数运算符* / % + -</li><li>为：位移运算符&lt;&lt; &gt;&gt;</li><li>关系：关系运算符&gt; &lt; &gt;= &lt;= == !=</li><li>逻辑：逻辑运算符&amp;&amp; || &amp; | ^</li><li>三目：三目运算符A &gt; B ? X : Y</li><li>后：无意义，仅仅为了凑字数</li><li>赋值：赋值=</li></ul><h5 id="java的四种访问权限">java的四种访问权限</h5><table><thead><tr><th></th><th style="text-align:center">public</th><th style="text-align:right">protected</th><th style="text-align:right">default(包权限)</th><th style="text-align:right">private</th></tr></thead><tbody><tr><td>同一类中的成员</td><td style="text-align:center">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td></tr><tr><td>同一包中的成员</td><td style="text-align:center">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td><td style="text-align:right">否</td></tr><tr><td>不同包的子类</td><td style="text-align:center">是</td><td style="text-align:right">是</td><td style="text-align:right">否</td><td style="text-align:right">否</td></tr><tr><td>不同包的非子类</td><td style="text-align:center">是</td><td style="text-align:right">否</td><td style="text-align:right">否</td><td style="text-align:right">否</td></tr></tbody></table><p>protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类(即有继承关系)。<br>表格解释:</p><ol><li>public：任何地方均可访问；</li><li>private：只限类的内部访问；</li><li>protected：受保护的，类的内部可访问；同一个包下的不管是否有继承关系均可访问；不同包下只有有继承关系的才可访问；</li><li>默认（default）：类的内部可访问；同一个包下不管是否有继承关系均可访问；不同包下不管有没有继承关系都不能访问。</li></ol><h5 id="java并发之原子性-可见性与有序性">java并发之原子性、可见性与有序性</h5><ol><li>原子性<br>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。Java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</li><li>可见性<br>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就这这个操作同样存在线程安全问题。</li><li>有序性<br>volatile。JVM规定，在volatile之前的操作，不能重排序到volatile之后。</li></ol><p>synchronized。同步代码块对于不同线程来说串行进入的。</p><h5 id="线程的创建方式">线程的创建方式</h5><ol><li>继承Thread类，重写run()方法，该run方法的方法体，代表了线程需要完成的任务</li><li>实现Runnable接口，重写该接口的run()方法，run()方法也为线程执行体</li></ol><h5 id="其他小知识">其他小知识</h5><p>在java7中下列说法：<br>(1)Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。</p><p>(2) ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全。</p><p>(3)抽象类和接口都不能实例化；抽象类可以不包含抽象方法，但是包含了抽象方法一定要声明为抽象类；抽象类可以继承抽象类</p><p>(4) Spring Framework是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，Spring中包含的关键特性:<br>1.强大的基于JavaBeans的采用控制翻转（Inversion of Control，IoC）原则的配置管理，使得应用程序的组建更加快捷简易。<br>2.一个可用于从applet到Java EE等不同运行环境的核心Bean工厂。<br>数据库事务的一般化抽象层，允许声明式（Declarative）事务管理器，简化事务的划分使之与底层无关。<br>3.内建的针对JTA和单个JDBC数据源的一般化策略，使Spring的事务支持不要求Java EE环境，这与一般的JTA或者EJB CMT相反。<br>4.JDBC 抽象层提供了有针对性的异常等级（不再从SQL异常中提取原始代码），简化了错误处理，大大减少了程序员的编码量。再次利用JDBC时，你无需再写出另一个’终止’（finally）模块。并且面向JDBC的异常与Spring通用数据访问对象（Data Access Object）异常等级相一致。<br>5.以资源容器，DAO实现和事务策略等形式与Hibernate，JDO和iBATIS SQL Maps集成。利用众多的翻转控制方便特性来全面支持，解决了许多典型的Hibernate集成问题。所有这些全部遵从Spring通用事务处理和通用数据访问对象异常等级规范。<br>6.灵活的基于核心Spring功能的MVC网页应用程序框架。开发者通过策略接口将拥有对该框架的高度控制，因而该框架将适应于多种呈现（View）技术，例如JSP、FreeMarker、Velocity、Tiles、iText以及POI。值得注意的是，Spring中间层可以轻易地结合于任何基于MVC框架的网页层，例如Struts、WebWork或Tapestry。<br>7.提供诸如事务管理等服务的面向方面编程框架。</p><p>另外，Spring并没有提供日志系统，我们需要使用AOP（面向方面编程）的方式，借助Spring与日志系统log4j实现我们自己的日志系统。</p><p>(5)SpringMVC的原理：<br>SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。<br>DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。<br>实现业务操作时在service层</p><p>(6) java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有<br>private  protected</p><p>(7)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer s=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">Integer t=<span class="keyword">new</span> Integer(<span class="number">9</span>);</span><br><span class="line">Long u=<span class="keyword">new</span> Long(<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>(s==t) ， s 是指向一个 9 的引用，而 t 也是一个指向 9 的引用，虽然都是指向 9 ，但却是指向不同的 9 ，即是两个不同的引用。因此 == 比较返回的是假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(s.equals(t)) ， Integer 的 equals 方法如下：</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (obj instanceof Integer) &#123;</span><br><span class="line">            return value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        return false ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是 Integer 的实例且 value 值也相等的情况下返回真，其他返回假。<br>在这里， s 和 t 都是 Integer 类型且值都为 9 ，因此结果为真。</p><p>(s.equals(9)) , 在进行 equals 比较之前，会对 9 调用 Integer.valueOf 方法，进行自动装箱 , 由于 IntegerCache 中已经存在 9 ，所以，直接返回其引用，引用相同， equals 就自然相同了。所以结果为真</p><p>(s.equals( new Integer(9)) ，直接创建了一个新的 Integer 实例，但且值也为 9 ，所以，满足条件，返回真。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的Android</title>
      <link href="/2017/07/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Android/"/>
      <url>/2017/07/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Android/</url>
      <content type="html"><![CDATA[<h5 id="android的动画分为3种-具体如下所示：">Android的动画分为3种，具体如下所示：</h5><ul><li>帧动画：也就是我们说的 Frame 动画。 Frame 动画是一系列图片按照一定的顺序展示的过程，<br>和放电影的机制相似，它的原理是在一定的时间段内切换多张有细微差异的图片从而达到动画的<br>效果。由于是一帧一帧加载，所以需要较多的图片。从而增大 APK 的大小，不过 Frame 动画<br>可以实现一些比较难的效果，例如：等待的环形进度。所涉及到的Java对象有：AnimationDrawable。<a id="more"></a></li><li>补间动画：也就是 Tween 动画，是操作某一个控件让其展现出旋转、渐变、移动、缩放的一种转换<br>过程。是一种视觉上的变化，不是真正位置上的变化。只能运用在 View 对象上，并且功能相对来说<br>较为局限。例如：旋转动画只能够在 x 、y 轴进行，而不能在z 轴放心进行旋转。因此，补间动画<br>通常用于执行一些比较简单的动画。所涉及到的Java对象有：AlphaAnimation（渐变动画）、<br>ScaleAnimation（缩放动画）、TranslateAnimation（位移动画）、RotateAnimation（旋转动画）。</li><li>属性动画：是 Android 3.0 之后推出的，其机制不再是针对 View 来设计的，也不限于只能实现<br>移动、缩放、旋转和淡入这几种简单的动画操作，同时也不再只是一种视觉上的动画效果。属性动画<br>实际上是一种在一定时间段内不断修改某个对象的某个属性值的机制。所涉及到的Java对象有：<br>ValueAnimator、ObjectAnimator。</li></ul><h5 id="apk程序的两种模式：-调试模式-debug-mode-和发布模式-release-mode">APK程序的两种模式：　调试模式(debug mode)和发布模式(release mode)</h5><ol><li>调试模式(debug mode) ：在调试模式下， ADT会自动的使用debug密钥为应用程序签名，因此我们可以直接运行程序。</li><li>发布模式(release mode)：当要发布程序时，开发者就需要使用自己的数字证书给apk包签名</li></ol><hr><p>ContentResolver和 ContentProvider是一对。一个运行在提供数据端(provider),一个运行在调用端(resolver)。使用的时候利用resolver来调用provider的方法(query,insert,update等)，然后provider再进行数据查询</p><hr><p>在android 中主线程是ui线程一切的界面操作都是在主线中完成的，如果在非主线程中操作ui将会报错。<br>B 同时执行多个AsyncTask默认是串行执行的。<br>C AsyncTask必须在UI线程中创建。<br>D 内部默认的线程是由 SerialExecutor创建 。</p><hr><ol><li>BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件</li><li>每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完时销毁</li><li>定义广播接收器类需要继承BroadcastReceiver基类，并且必须要重写onReceive()方法</li></ol><hr><p>NotificationManager 清除消息的方法是:cancel,cancelAll</p><hr><ol><li>应用运行时，Main线程进行了耗时操作  产生ANR，程序没有响应，有可能程序会再次响应</li><li>应用运行时抛出了OutOfMemoryError  程序抛出异常，会强制退出</li><li>应用运行时抛出了RuntimeException  程序抛出异常，会强制退出</li><li>应用运行时，用户操作过于频繁  产生ANR，程序没有响应，有可能程序会再次响应</li></ol><hr><p>在Android中，如果需要对数据进行存储，则可以使用（ ）方式<br>sharedpreference  \数据库\文件\Content Provider</p><hr><p>A. Message提供了消息池，有静态方法Obtain从消息池中取对象；<br>B. Thread默认不提供资源池，除非使用线程池ThreadPool管理；<br>C. AsynTask是线程池改造的，池里 默认提供（核数+1）个线程进行并发操作，最大支持（核数  * 2 + 1）个线程，超过后会丢弃其他任务；<br>D. Looper，每个Looper创建时创建一个消息队列和线程对象，也不是资源池；</p><hr><p>下面关于Android中定义style和theme的描述正确的是？<br>style可以作用在Activity上<br>官方解释：A style is a collection of properties that specify the look and format for a View or window<br>A theme is a style applied to an entire Activity or application<br>补充一句：style和theme本质上就是同一个东西，xml格式完全相同，只是我用在activity上我就叫他theme，我用在view上我就叫他style。唯一的区别就是style里头控制的各个属性了，某些属性是只有针对Activity才能生效的（你view有标题栏嘛有状态栏有导航栏吗嘛？但是反过来Activity内部却有一个继承自View的Decorview） 。所以style可以作用在activity上，但是theme却不能反过来作用在view上</p><hr><p>在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画</p><ul><li>AlphaAnimation 透明度渐变</li><li>ScaleAnimation 透明度渐变</li><li>TranslateAnimation 坐标变化</li><li>RotateAnimation 旋转变换</li></ul><hr><p>前台进程是Android系统中最重要的进程，在Andriod系统中包含</p><ul><li>Activity正在与用户进行交互</li><li>进程服务正在执行声明中的回调函数</li><li>进程的BroadCastRecevier在执行onRecevie()函数</li></ul><p>activity被遮挡时属于可见进程，可见进程的优先级在前台进程之下。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dao层、Service层、Controller层、View层</title>
      <link href="/2017/07/03/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E3%80%81Controller%E5%B1%82%E3%80%81View%E5%B1%82/"/>
      <url>/2017/07/03/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E3%80%81Controller%E5%B1%82%E3%80%81View%E5%B1%82/</url>
      <content type="html"><![CDATA[<ol><li>DAO层：DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</li><li>Service层：Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。</li></ol><a id="more"></a><ol start="3"><li>Controller层:Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。</li><li>View层 此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示</li><li>DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势，Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看作一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。<br></li><li>DAO设计的总体规划需要和设计的表，和实现类之间一一对应。</li><li>DAO层所定义的接口里的方法都大同小异，这是由我们在DAO层对数据库访问的操作来决定的，对数据库的操作，我们基本要用到的就是新增，更新，删除，查询等方法。因而DAO层里面基本上都应该要涵盖这些方法对应的操作。除此之外，可以定义一些自定义的特殊的对数据库访问的方法。</li><li>Service逻辑层设计</li><li>Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</li><li>在DAO层定义的一些方法，在Service层并没有使用，那为什么还要在DAO层进行定义呢？这是由我们定义的需求逻辑所决定的。DAO层的操作 经过抽象后基本上都是通用的，因而我们在定义DAO层的时候可以将相关的方法定义完毕，这样的好处是在对Service进行扩展的时候不需要再对DAO层进行修改，提高了程序的可扩展性。<br><br>小链接：ajax相关 (<a href="https://blog.csdn.net/cwj649956781/article/details/22414533" target="_blank" rel="noopener">https://blog.csdn.net/cwj649956781/article/details/22414533</a>)<br><br><br>(<a href="https://zhidao.baidu.com/question/745652997728018212.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/745652997728018212.html</a>)<br><br><br>(<a href="https://www.cnblogs.com/sdya/p/4624578.html" target="_blank" rel="noopener">https://www.cnblogs.com/sdya/p/4624578.html</a>)</li></ol>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring常用注解</title>
      <link href="/2017/07/03/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2017/07/03/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="常用的是注解有如下几种：">常用的是注解有如下几种：</h3><p>@Controller<br><br>@Service<br><br>@Autowired<br><br>@RequestMapping<br><br>@RequestParam<br><br>@ModelAttribute<br></p><a id="more"></a><p>@Cacheable<br><br>@CacheFlush<br><br>@Resource<br><br>@PostConstruct<br><br>@PreDestroy<br><br>@Repository<br><br>@Component （不推荐使用）<br><br>@Scope<br><br>@SessionAttributes<br><br>@InitBinder<br><br>@Required<br><br>@Qualifier<br></p><h6 id="controller">@Controller</h6><ul><li>例如：@Controller<br><br>public class SoftCreateController extends SimpleBaseController {}</li><li>或者：@Controller<br><br>public class SoftCreateController extends SimpleBaseController {}</li><li>说明： @Controller<br><br>负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写</li></ul><h6 id="service">@Service</h6><p>• 例如：<br>@Service<br><br>public class SoftCreateServiceImpl implements ISoftCreateService {}</p><p>• 或者：<br><br>@Service(“softCreateServiceImpl”)</p><p>• 说明：<br><br>@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写</p><h6 id="autowired">@Autowired</h6><p>• 例如：<br>@Autowired<br>private ISoftPMService softPMService;</p><p>• 或者：</p><p>@Autowired(required=false)<br>private ISoftPMService softPMService = new SoftPMServiceImpl();</p><p>• 说明：</p><p>@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。</p><p>与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种<br>方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();</p><p>与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring<br>上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();</p><p>@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、<br>ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。</p><h6 id="requestmapping">@RequestMapping</h6><p>• 类：</p><p>@Controller<br>@RequestMapping(&quot;/bbtForum.do&quot;) IT学习者（<a href="http://www.itxxz.com" target="_blank" rel="noopener">www.itxxz.com</a>）<br>public class BbtForumController {<br>@RequestMapping(params = “method=listBoardTopic”)<br>public String listBoardTopic(int topicId,User user) {}<br>}</p><p>• 方法：</p><p>@RequestMapping(&quot;/softpg/downSoftPg.do&quot;)<br>@RequestMapping(value=&quot;/softpg/ajaxLoadSoftId.do&quot;,method = POST)<br>@RequestMapping(value = “/osu/product/detail.do”, params = { “modify=false” }, method =POST)<br>• 说明：<br>@RequestMapping 可以声明到类或方法上</p><p>• 参数绑定说明<br>如果我们使用以下的 URL 请求：<br><a href="https://localhost/itxxzSpring4?method=listBoardTopic&amp;topicId=1&amp;userId=10&amp;userName=tom" target="_blank" rel="noopener">https://localhost/itxxzSpring4?method=listBoardTopic&amp;topicId=1&amp;userId=10&amp;userName=tom</a><br>topicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的<br>userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。</p><h6 id="resource">@Resource</h6><ul><li>例如：<br>@Resource<br>private DataSource dataSource; // inject the bean named ‘dataSource’</li><li>或者：<br>@Resource(name=“dataSource”)<br>@Resource(type=DataSource.class)</li><li>说明：<br>@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找，<br>此时与@Autowired 类 似.<br><br>在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为&quot;&quot;)，否则注入失败；</li></ul><h6 id="scope">@Scope</h6><ul><li>例如<br>@Scope(“session”)<br>@Repository()<br>public class UserSessionBean implementsSerializable {}</li><li>说明</li></ul><p>在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，<br>同样可以通过@Scope 注解来完成<br></p><p>@Scope中可以指定如下值：<br>singleton:定义bean的范围为每个spring容器一个实例（默认值）<br>prototype:定义bean可以被多次实例化（使用一次就创建一次）<br>request:定义bean的范围是https请求（springMVC中有效）<br>session:定义bean的范围是https会话（springMVC中有效）<br>global-session:定义bean的范围是全局https会话（portlet中有效）<br><br><br>小链接：ssm配置(<a href="https://www.cnblogs.com/youyefly/p/5685509.html" target="_blank" rel="noopener">https://www.cnblogs.com/youyefly/p/5685509.html</a>),<br>(<a href="https://blog.csdn.net/xuejian0616/article/details/52259335" target="_blank" rel="noopener">https://blog.csdn.net/xuejian0616/article/details/52259335</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javaweb </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远方</title>
      <link href="/2017/06/24/%E8%BF%9C%E6%96%B9/"/>
      <url>/2017/06/24/%E8%BF%9C%E6%96%B9/</url>
      <content type="html"><![CDATA[<h3 id="热爱生命">《热爱生命》</h3><img src="http://qiniu.xueshiming.cn/%E8%BF%9C%E6%96%B9.jpg" width="600" hegiht="400" align="center"><p>我不去想是否能够成功<br>既然选择了远方<br>便只顾风雨兼程<br>我不去想能否赢得爱情<br>既然钟情于玫瑰<br>就勇敢地吐露真诚<br>我不去想身后会不会袭来寒风冷雨<br>既然目标是地平线<br>留给世界的只能是背影<br>我不去想未来是平坦还是泥泞<br>只要热爱生命<br>一切<br>都在意料之中</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ajax应用</title>
      <link href="/2017/04/03/Ajax%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/04/03/Ajax%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h6 id="一-ajax是什么-有什么作用？">一. ajax是什么，有什么作用？</h6><p>ajax分为同步请求和异步请求两种。<br>ajax的异步好处：用户在浏览网页同时点击一个ajax异步请求，这个时候用户无需等待、使用javascript脚本实现页面的动态局部刷新。<br>坏处就是post请求不能跨域，比如a.com请求b.com等<br>小链接：(<a href="https://blog.csdn.net/cwj649956781/article/details/22414533" target="_blank" rel="noopener">https://blog.csdn.net/cwj649956781/article/details/22414533</a>)</p><a id="more"></a><h6 id="二-ajax的使用-br">二.ajax的使用<br></h6><p>这里放一个小案例，仅供参考：<br>先导入包：【写到(/boday)的后面或(header)(/header)里都可以】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"jquery/jquery-3.1.1.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>下面的写到(body)与(/body)之间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">&lt;span id=&quot;a&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>下面这部分写到（/body）的后面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count=<span class="string">''</span>;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">   type:<span class="string">"get"</span>, <span class="comment">//写请求方式</span></span><br><span class="line">   url: <span class="string">"./findAllTicker"</span>,  <span class="comment">//写要跳转页面的Url</span></span><br><span class="line">   dataType:<span class="string">"json"</span>,  <span class="comment">//后台返回数据的格式为json</span></span><br><span class="line">   <span class="keyword">async</span>:<span class="literal">true</span>,  <span class="comment">//true为异步请求</span></span><br><span class="line">   success: <span class="function"><span class="keyword">function</span>(<span class="params">map</span>)</span>&#123;  <span class="comment">//map 为我自己写的接收后台返回的数据</span></span><br><span class="line">    $(<span class="string">"#a"</span>).html(map.count);  <span class="comment">//在页面上输出数据</span></span><br><span class="line">    <span class="comment">//$("#a")[0].innerHTML=map.count;  //在页面上输出数据</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h6 id="运行截图">运行截图</h6><p><img src="../images/ajax1.png" alt="ajax01"><br></p><p><img src="../images/ajax2.png" alt="ajax02"><br><br>小链接：(<a href="https://www.cnblogs.com/sdya/p/4624578.html" target="_blank" rel="noopener">https://www.cnblogs.com/sdya/p/4624578.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
