<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>神奇的reduce</title>
      <link href="/2019/08/25/%E7%A5%9E%E5%A5%87%E7%9A%84reduce/"/>
      <url>/2019/08/25/%E7%A5%9E%E5%A5%87%E7%9A%84reduce/</url>
      <content type="html"><![CDATA[<h5 id="none"></h5><blockquote><p>reduce ( ) 这个函数有些复杂，不知到怎么描述好，直接看例子吧：</p></blockquote><a id="more"></a><ul><li>func：接受4个参数得函数，<br>previous, current, index, array，之前值，当前值，索引，数组本身。func的返回值，会作为下一次迭代时previous的值。</li><li>initialValue：可选，表示初始值，如果指定initialValue，则作为初始时previous的值，如果缺省，数组得第一个元素为previous值，第二个元素为current。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3, 4, 5];</span><br><span class="line">var sum = arr.reduce(function(previous, current, index, array)&#123;</span><br><span class="line">return previous + current;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(sum); // 15</span><br><span class="line"></span><br><span class="line">过程展开如下：</span><br><span class="line">// 初始：</span><br><span class="line">previous = initialValue = 1, current = 2;</span><br><span class="line">// 第一次迭代 之后</span><br><span class="line">previous = 1 + 2 = 3, current = 3;//current 向后移动一个元素</span><br><span class="line">// 第二次迭代之后</span><br><span class="line">previous = 3 + 3 = 6, current = 4;</span><br><span class="line">// 第三次迭代之后</span><br><span class="line">previous = 6 + 4 = 10, current = 5;</span><br><span class="line">// 第四次迭代之后</span><br><span class="line">previous = 10 + 5 = 15 ,current = undefined// 没有了，退出，返回15；</span><br></pre></td></tr></table></figure><h4 id="拓展：reduceright">拓展：reduceRight()</h4><p>和reduce类似，只不过从数组结尾开始，从右向左迭代。</p><h4 id="应用：">应用：</h4><ul><li>json数组去重</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let arr = [&#123;</span><br><span class="line">    &quot;name&quot;: &quot;ZYTX&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;Y13xG_4wQnOWK1Qw&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;AAAAAA.doc&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    &quot;name&quot;: &quot;ZYTA&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;Y13xG_4wQnOWK1Qw&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;BBBBBB.doc&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    &quot;name&quot;: &quot;ZDTX&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;Y13xG_4wQnOWK1Qw&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;CCCCCC.doc&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    &quot;name&quot;: &quot;ZYTX&quot;,</span><br><span class="line">    &quot;age&quot;: &quot;Y13xG_4wQnOWK1Qw&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;AAAAAA.doc&quot;</span><br><span class="line">&#125;];</span><br><span class="line">let hash = &#123;&#125;;</span><br><span class="line">    arr = arr.reduce(function(item, next) &#123;</span><br><span class="line">        hash[next.name] ? &apos;&apos; : hash[next.name] = true &amp;&amp; item.push(next);</span><br><span class="line">        return item</span><br><span class="line">    &#125;, [])</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><ul><li>数组去重</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1,2,1,2,3,5,4,5,3,4,4,4,4];</span><br><span class="line">let result = arr.sort().reduce((init, current) =&gt; &#123;</span><br><span class="line">if(init.length === 0 || init[init.length-1] !== current) &#123;</span><br><span class="line">init.push(current);</span><br><span class="line">&#125;</span><br><span class="line">return init;</span><br><span class="line">&#125;, []);</span><br><span class="line">console.log(result); //[1,2,3,4,5]</span><br></pre></td></tr></table></figure><ul><li>reduce 实现 promise  串行执行</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function runPromiseInSequence(arr, input) &#123;</span><br><span class="line">return arr.reduce(</span><br><span class="line">(promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),</span><br><span class="line">Promise.resolve(input)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 1</span><br><span class="line">function p1(a) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">resolve(a * 5);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 2</span><br><span class="line">function p2(a) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">resolve(a * 2);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function 3  - will be wrapped in a resolved promise by .then()</span><br><span class="line">function f3(a) &#123;</span><br><span class="line">return a * 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// promise function 4</span><br><span class="line">function p4(a) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">resolve(a * 4);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const promiseArr = [p1, p2, f3, p4];</span><br><span class="line">runPromiseInSequence(promiseArr, 10)</span><br><span class="line">.then(console.log);</span><br></pre></td></tr></table></figure><p>拓展：更加简便的方法，使用异步函数来实现<br><code>runPromiseInSequence</code>可以简化为：Ï</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function runPromiseInSequence(myPromises) &#123;</span><br><span class="line">for (let value of myPromises) &#123;</span><br><span class="line">await value();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序常被忽略的知识</title>
      <link href="/2019/06/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/06/26/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A2%AB%E5%BF%BD%E7%95%A5%E7%9A%84%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<blockquote><p>在开发小程序的同时，也别忘记去理解一些原理性和细节性的问题，因为这是我们提升的关键。<strong>to be an engineer, not a coder.</strong></p></blockquote><a id="more"></a><h3 id="tips-先来一些干货">Tips: 先来一些干货</h3><h5 id="wx：key-不仅仅是唯一标识">wx：key  不仅仅是唯一标识</h5><p>列表数据发生改变重新出发页面渲染的时候，列表中的项目可以保持自身状态<br>比如在<code>input</code>组件里，输入了内容之后<br>在页面渲染之后，不希望<code>input</code> 内容发生改变，需要用此属性<br>这个属性，在页面重新渲染的时候，确保带有 <code>key</code> 的组件 会重新排序，而不是重新渲染，从而提高页面渲染性能的效率</p><p>另外：如不提供 <code>wx:key</code>，会报一个 <code>warning</code>， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。</p><h5 id="block是一个包装元素-不是组件-渲染之后页面看不出来">Block是一个包装元素，不是组件，渲染之后页面看不出来</h5><h5 id="wx：if-和hidden-区别">wx：if 和hidden 区别</h5><p><code>wx:if</code>在切换时有局部渲染的过程，从而保证条件块渲染时，可以销毁并重新渲染，有更高的切换消耗<br><code>hidden</code>始终渲染。可以控制视图上的显示和隐藏，有更高的初始化渲染消耗,<br>所以元素频繁切换的话，使用<code>hidden</code></p><h4 id="wxml支持文件引用">wxml支持文件引用</h4><p><code>import</code>： 只能引用我们定义模板文件的模板内容块</p><p><img src="http://qiniu.xueshiming.cn/1" alt=""><br>作用域的概念：只能引用目标文件定义的<code>template</code>模板，如果目标文件内嵌套了其他模板，是不会被引用的，避免了引用模板死循环的问题</p><p><img src="http://qiniu.xueshiming.cn/2" alt=""><br><code>include</code> : 把目标 文件内除了模板代码块外的 所有代码都引入，相当于拷贝到了<code>include</code>位置这里</p><p><img src="http://qiniu.xueshiming.cn/3" alt=""></p><h4 id="wxss和css对比">Wxss和css对比</h4><p><img src="http://qiniu.xueshiming.cn/4" alt=""></p><blockquote><p>尺寸单位rpx</p></blockquote><p>先了解几个概念：</p><p><img src="http://qiniu.xueshiming.cn/5" alt=""></p><ul><li><code>设备像素</code>： 设备能控制的显示的最小物理单位<br>这个最小物理单位是屏幕上一个个点，点是固定不变的</li><li><code>CSS像素</code>：外部编程的概念，css代码中使用的逻辑像素</li><li><code>PPI/DPI</code>：每英寸拥有的像素数目</li></ul><p><img src="http://qiniu.xueshiming.cn/6" alt=""></p><ul><li><code>DPR</code>：手机的某一方向上设备像素和css像素之比</li></ul><p>虽然<code>wxss</code>支持<code>rem</code>，但是我们知道<code>rem</code>是根据<code>html</code>根元素的<code>fontSize</code>大小来适配的，<br><code>wxss</code>不能直接操作<code>html</code>的样式属性，所以<code>rem</code>适配方案就失效了。<br><code>rpx</code>应运而生，规定屏幕宽度为<code>750rpx</code>，从而我们可以根据屏幕宽度来自适应，<code>rpx</code>和<code>rem</code>实现方式是相似的，而且<code>rpx</code>最终转换为<code>rem</code></p><blockquote><p>样式导入</p></blockquote><ul><li><p>外联样式引入：<code>@import ‘./ss.wxss’</code></p></li><li><p>内连样式引入：<code>style</code> 一般用来写动态的样式</p></li></ul><blockquote><p>选择器</p></blockquote><p><strong>优先级</strong></p><p><img src="http://qiniu.xueshiming.cn/7" alt=""><br>一般想要修改他人插件样式的时候使用<code>!import</code></p><hr><h3 id="小程序运行机制">小程序运行机制</h3><blockquote><p>小程序两种启动方式：冷启动，热启动</p></blockquote><ul><li>热启动：假如用户已经打开了某个小程序，在一定时间内再次打开小程序的话，这个时候我们就不再需要重新启动了，这需要把我们的后台打开的小程序切换到前台来使用。</li><li>冷启动：用户首次打开小程序或被微信主动销毁再次打开的情况，此时小程序需要重新加载启动。</li></ul><blockquote><p>小程序什么时候会主动销毁？</p></blockquote><ol><li>小程序在进入后台之后，客户端会帮我们在一定时间内维持我们的一个状态，超过五分钟后，会被微信主动销毁</li><li>当我们在短时间内连续两次收到系统告警的时候，微信就会主动销毁，短时间间隔是5s</li></ol><hr><h3 id="小程序更新机制：">小程序更新机制：</h3><p>小程序在冷启动的时候遇到版本更新，小程序会异步加载，帮我们下载最新版本的代码包，并同时使用微信本地版本的代码包启动，也就是说最新的代码包，将在小程序下次启动才去加载。如果偏要使用最新版本的代码包，我们可以使用api来处理</p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/base/update/wx.getUpdateManager.html" target="_blank" rel="noopener">wx.getUpdateManager</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const updateManager = wx.getUpdateManager()</span><br><span class="line"></span><br><span class="line">updateManager.onCheckForUpdate(function (res) &#123;</span><br><span class="line">  // 请求完新版本信息的回调</span><br><span class="line">  console.log(res.hasUpdate)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">updateManager.onUpdateReady(function () &#123;</span><br><span class="line">  wx.showModal(&#123;</span><br><span class="line">    title: &apos;更新提示&apos;,</span><br><span class="line">    content: &apos;新版本已经准备好，是否重启应用？&apos;,</span><br><span class="line">    success(res) &#123;</span><br><span class="line">      if (res.confirm) &#123;</span><br><span class="line">        // 新的版本已经下载好，调用 applyUpdate 应用新版本并重启</span><br><span class="line">        updateManager.applyUpdate()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">updateManager.onUpdateFailed(function () &#123;</span><br><span class="line">  // 新版本下载失败</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><h3 id="小程序加载机制：">小程序加载机制：</h3><p>小程序的启动流程图里面：</p><p><img src="http://qiniu.xueshiming.cn/8" alt=""><br>左侧的部分是在启动的时候，微信客户端里面的视图层和逻辑层一些交互逻辑以及数据缓存的存取操作，在小程序启动的时候，会向<code>cdn</code>请求最新代码包，第一次启动必须等到代码包下载完毕，注入到<code>webView</code>容器内执行之后，才能看到小程序页面，所以在网络不好的情况下，我们会感觉到页面打开比较慢，客户端会帮我们把代码包缓存到本地，当我们下一次启动的时候，我们会从 <code>cdn</code> 请求是否有最新版本的代码包。</p><hr><h3 id="小程序应用和页面的生命周期：">小程序应用和页面的生命周期：</h3><blockquote><p>小程序应用生命周期：onLaunch，onShow，onHide，onError</p></blockquote><p>首次进入小程序，从 <code>cdn</code> 或者小程序本地拿到代码包注入到运行环境，<br>微信客户端会给我们逻辑层<code>app.js</code>的<code>app</code>实例来派发<code>onLaunch</code>事件，<br>在逻辑层，<code>app.js</code>的 <code>app</code> 构造器的参数里面的<code>onLaunch</code>方法就会被调用。<br>当用户使用<code>home</code>件或者点击右上角小程序关闭按钮，来关闭小程序时，小程序是没有被直接销毁的，这时<code>app</code>构造器的参数里面的<code>onHiede</code>方法就会被调用，当我们再次打开小程序时，微信唤起小程序，<code>onShow</code>方法就会被调用，<br>当小程序脚本发现错误时，或<code>api</code>调用失败时，会调用<code>onError</code>。</p><blockquote><p>小程序页面的生命周期：onLoad，onShow，onReady，onHide，onUnload，</p></blockquote><p>页面未被销毁之前，<code>onLoad</code>只会调用一次，<br>页面显示之后，会调用page实例里面的<code>onShow</code><br>当页面初次渲染之后，<code>onReady</code>就会被调用，页面未被销毁之前，只会调用一次<br><code>onReady</code>触发之后，逻辑层和视图层进行交互，<br>当我们在当前页面打开新的页面之后，当前页面会触发<code>onHide</code>，<br>如果关闭当前页，会触发<code>onUnload</code></p><p>负责页面视图的<code>view</code>线程和处理数据的服务以及服务的服务线程，<code>AppService</code>，<br>协同完成生命周期周期调用</p><p><img src="http://qiniu.xueshiming.cn/9" alt=""></p><hr><h3 id="小程序事件模型">小程序事件模型</h3><p><img src="http://qiniu.xueshiming.cn/10" alt=""></p><h5 id="1-事件捕获阶段">1. 事件捕获阶段</h5><p>绑定的事件从最外层节点向下传递到目标节点元素，依次检查，所经过的节点是否绑定了同一事件类型的监听回调函数，如果有则执行对应的事件回调函数</p><h5 id="2-事件处理阶段">2. 事件处理阶段</h5><p>事件在到达目标节点之后，会触发目标节点所绑定的监听回调函数</p><h5 id="3-事件冒泡阶段">3. 事件冒泡阶段</h5><p>事件从目标节点，向上冒泡到最外层节点，依次检查经过的节点是否绑定了，同样事件类型的监听回调函数，如果有，会执行这个回调函数</p><p><code>target</code>属性： 触发事件的当前组件<br><code>currentTarget</code>属性： 触发事件的根源组件</p><p><code>eg:</code> 如果有外层<code>view</code>还有个里层<code>view</code>嵌套，都通过<code>bind</code>绑定了点击事件，<code>target</code>为外层<code>view</code>组件的事件对象,<code>currentTarget</code>为底层<code>view</code>组件的事件对象</p><p><img src="http://qiniu.xueshiming.cn/11" alt=""></p><ul><li><code>type</code> 触发事件的触发类型</li><li><code>timestamp</code> 触发事件的时间戳</li><li><code>target</code> 触发事件的根源组件，包括触发事件根源组件的id自定义属性的集合</li><li><code>currenTarget</code> 事件绑定额当前组件 ，包括当前组件的<code>id</code>，类型，<code>data</code>自定义属性的集合</li><li><code>touches</code> 是一个数组，每一个元素都是一个<code>touc</code>h对象 ，标识当前停留在屏幕上的触摸点和信息</li><li><code>changedTouches</code> 是一个数据，标识有变化的 触摸点，即当前触摸点从有到无或从无到有的变化</li><li><code>detail</code>  标识各个事件带有的数据，点击事件： ‘触摸点距离文档左上角的距离’<br>媒体事件，触发事件的时候播放状态，以及时间戳</li></ul><hr><h3 id="小程序运行环境：">小程序运行环境：</h3><blockquote><p>在不同环境下的<code>javascript</code>脚本运行环境是不同的，微信小程序运行在三端<code>：iOS（iPhone/iPad）</code>、<code>Android</code> 和 用于调试的开发者工具。</p></blockquote><p><strong>三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：</strong></p><ul><li><p>在 <code>iOS</code> 上，小程序逻辑层的 <code>javascript</code> 代码运行在 <code>JavaScriptCore</code> 中，视图层是由 <code>WKWebView</code> 来渲染的，环境有 <code>iOS8</code>、<code>iOS9</code>、<code>iOS10</code>；</p></li><li><p>在 <code>Android</code> 上，</p><ul><li>旧版本，小程序逻辑层的 <code>javascript</code> 代码运行中 <code>X5 JSCore</code> 中，视图层是由 <code>X5</code> 基于 <code>Mobile</code> <code>Chrome 57</code> 内核来渲染的</li><li>新版本，小程序逻辑层的 <code>javascript</code> 代码运行在 <code>V8</code> 中，视图层是由自研 <code>XWeb</code> 引擎基于 <code>Mobile Chrome 6 7</code> 内核来渲染的；</li></ul></li><li><p>在 开发工具上，小程序逻辑层的 <code>javascript</code> 代码是运行在 <code>NW.js</code> 中，视图层是由 <code>Chromium 60 Webview</code> 来渲染的。</p></li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>上手捣鼓linux命令系列(更新)</title>
      <link href="/2019/06/20/Linux/"/>
      <url>/2019/06/20/Linux/</url>
      <content type="html"><![CDATA[<blockquote><p>最近将博客换成了https协议，并将自己小程序后台部署到了我的ubuntu服务器上，期间学习到了很多东西，下面便一一悉知</p></blockquote><a id="more"></a><p><strong>tips：</strong></p><h4 id="nginx配置">nginx配置</h4><p>每次<code>nginx</code>配置完时，都需要<code>service nginx restart</code>或<code>service nginx start</code>来重启<code>nginx</code>服务</p><p>拓展：关于<code>nginx</code>更多的信息，updating…</p><h4 id="改写文件权限">改写文件权限</h4><p><code>sudo chmod 777 /etc/nginx/myssl</code>,在scp上传文件夹时候需要设置文件夹可写权限,</p><p>我干脆权限设置最高(有些粗暴哈哈😀，但是不可取)</p><p>拓展：updating…</p><h4 id="找端口杀进程">找端口杀进程</h4><p>这个问题我们经常遇到，但是想用的时候总是忘记，<code>lsof -i:9981</code>查找到 <code>9981</code> 端口对应的<br><code>pId: 22463</code>然后<code>kill -9 22463</code>就可以了。</p><p>拓展：updating…</p><h4 id="查看nginx的报错原因">查看nginx的报错原因</h4><p>查找<code>nginx</code>的日志文件,查看<code>log</code>文件获取报错信息<code>/var/log/nginx</code></p><h4 id="使项目持久运行在服务器上">使项目持久运行在服务器上</h4><p>用screen保持项目在服务器上长久运行<a href="https://www.jianshu.com/p/b24f597c0561" target="_blank" rel="noopener">戳这儿</a></p><p>拓展：updating…</p><h4 id="保持ssh连接不断开">保持ssh连接不断开</h4><p>经常遇到终端断开了ssh远程链接，然后终端卡顿，很是头疼<code>/etc/ssh/sshd_config</code>,添加：<br><code>ClientAliveInterva 120</code></p><p><code>ClientAliveCountMax 720</code></p><p>重启sshd服务：</p><p><code>systemctl restart sshd</code></p><blockquote><p>第一句意思是服务端每间隔120s会向客户端发送一个空数据包，第二句表示服务器最大会发送720次,120*720=24小时，24小时期间连接是不会断开的</p></blockquote><h4 id="2017-11-22-更新">2017-11-22 更新</h4><p>在windows下，下载<code>jdk-8u25-linux-64.tar.gz</code></p><p>使用<code>Xshell5p.exe</code>用来访问远程面板</p><ol><li>在windows下面下好 tar.gz</li><li>上传文件 rz</li><li>解压文件 tar -xzvf jdk-8u25-linux-x64.tar.gz</li><li>进入当前用户目录  cd home/fisherman</li><li>vi .bash -profile  编辑文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLASSPATH=&quot;$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib&quot;</span><br><span class="line">PATH=&quot;$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOMR/bin&quot;</span><br></pre></td></tr></table></figure><ol start="6"><li><p><code>:wq!</code>退出</p></li><li><p><code>source .bash_profile</code>命令生效</p></li><li><p><code>java -version</code> 查询java版本</p></li><li><p><code>tar zcvf secu.tar.gz tt</code>将文件压缩到tt目录</p></li><li><p>启动<code>linuxshell</code>的时候，<code>stdin</code>,<code>stdout</code>,<code>stderr</code>,三个文件描述符会自动打开，他们的值分别是：标准输入，标准输出、标准错误</p></li><li><p>为脚本程序添加执行权限的命令及参数：chmod a+x filename</p></li><li><p>用八进制表示权限：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r--4 w--2  x--1</span><br><span class="line">r--r--r--   444</span><br><span class="line">drw------   600</span><br></pre></td></tr></table></figure><h4 id="xshell-连到-远程服务器">xshell 连到 远程服务器</h4><p><img src="http://qiniu.xueshiming.cn/clipboard.png" alt="连接远程服务器"></p><ol><li>输入远程服务器的ip：</li></ol><p><img src="http://qiniu.xueshiming.cn/clipboard2.png" alt="服务器ip"></p><ol start="2"><li>输入用户名和密码，就登录成功了</li></ol><p><img src="http://qiniu.xueshiming.cn/clipboard3.png" alt="填写自己的用户名"></p><ol start="3"><li>然后可以修改用户名密码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd fisherman &amp;&amp; echo 123456 | passwd --stdin fisherman</span><br><span class="line">fisherman--自己的用户名：mark</span><br></pre></td></tr></table></figure><blockquote><p>每天一个linux命令：<a href="https://www.cnblogs.com/peida/archive/2012/12/05/2803591.html" target="_blank" rel="noopener">叮</a><br>对权限的参考: <a href="https://blog.csdn.net/sinat_35209943/article/details/52449743" target="_blank" rel="noopener">传送门</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端国际化探索(二)</title>
      <link href="/2019/03/10/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%BA%8C)/"/>
      <url>/2019/03/10/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%BA%8C)/</url>
      <content type="html"><![CDATA[<blockquote><p>在这里我继续思考整理汇总一下国际化方案，后续可以针对一些重要的点进行突破和落地。</p></blockquote><a id="more"></a><h3 id="国际化的目的">国际化的目的</h3><p>简单的说一个国外网站被你打开却以为是国内公司开的，那么这个网站的国际化就做的非常成功。</p><p>所以国际化的目的就是：让各个地区的人都能感受到这个网站像本地的网站一样，亲切、易用。</p><p>然而这个目标很难实现，在做调研的时候，亚马逊属于国际化比较好的网站，开设分站并在主要几个国家都有专门的运营团队等，然而让普通人打开这个中国亚马逊，还是能感受到与淘宝、京东的不同。</p><p>即便是无法完全实现目标，我们仍然可以用技术以较低成本来尽可能改善体验，因此还是有一定的价值来探索这个</p><h3 id="国际化的流程和步骤">国际化的流程和步骤</h3><p>一个其他地区的人访问我们的网页，然后最终得到一个国际化友好的网页，这个过程发生了什么？这个过程有哪些问题和解决方案？下面就来整条链路的梳理一下。</p><ul><li>入口 URL 附带相关参数。</li><li>通过 IP 地址进行判断。</li></ul><p>第一种方法适用于引导页进行跳转，使用范围比较小。<br>初次访问的判断方法最好是 IP 判断的方式进行。<br>后端也有相关接口，初次访问的人可以用这种方式进行粗略的定位，因为 IP 肯定会有误差。</p><h3 id="记录-cookie-并提供用户切换地区-语言的功能">记录 Cookie 并提供用户切换地区、语言的功能</h3><p>访问之后，我们可以粗略拿到该用户所在的地区，因此可以回写一个 Cookie 来保存当前用户的一些信息，通常比较重要的信息有：</p><ul><li>地区</li><li>语言</li><li>货币</li></ul><p>这几个信息组合就可以，共同确定唯一的一个信息，所以我起了个名字叫『唯一地区语言定位串』。但是目前缺乏一套一致的数据规范，因此会产生一些问题：</p><ul><li>地区是按国家维度区分还是按区域？香港是表示为 HK 还是 CN？</li><li>语言按照什么维度区分？用什么表示？繁体和简体都属于中文，只用中文区分？chinese 和 zh-cn 用哪种表示？</li></ul><p>这些信息如果没有一套规范和列表，很难进行统一和推广，如果没有在一开始就全集团统一确定下来，后期就会像 GBK、UTF-8 这样的编码问题一样，后患无穷。</p><h3 id="针对特定区域进行国际化处理">针对特定区域进行国际化处理</h3><p>获取信息只是第一步，下面轮到我们进行国际化处理了。</p><p>国际化的处理主要分为两部分：</p><ul><li>页面内容改变</li><li>页面交互样式改变<br>按照当地的习惯设计视觉、展示当地的语言的内容等，基本就是国际化处理的核心。这块也是最复杂最有挑战性的部分。</li></ul><h3 id="文本内容改变">文本内容改变</h3><p>固定文案的处理比较简单，最常见的方法就是创建一个映射表，用一个标记来表示该文案，然后不同区域下读取不同的文案内容即可。</p><p>现在市场上也有非常多类似的工具可以帮你简化这些操作，比如 i18next 等。</p><p>比较麻烦的是动态数据这块，就拿淘宝业务举例，就是各种商品数据，比如标题等信息。这些信息怎么进行本地化语言转换就是一个需要突破的问题。即便是看似最简单的繁简体转换，也没有那么简单。有些香港、台湾的惯用语等，并不是单个汉字转成繁体就可以的。更具体的细节可以点击这里。</p><p>由于目前在考虑做英文站，需要大量英文数据，后端也有考虑批量翻译商品数据直接存入数据库的方式来处理。但这种翻译不够完善，最大的缺陷在于无法对图片的内容翻译。一个淘宝商品详情承载最大信息量的不是商品标题等，而是商品的图片。卖家往往通过在商品图片上打字来介绍这个商品，所以这种批量转换只能在搜索和 SEO 方面能有所价值。对于真实成交和本地化的体验可能没有非常大的效果。</p><p>既然商品信息都是卖家提交的，那国际化的内容，能否让卖家自行提交、编辑？这或许是一个最好的突破口，提供给卖家多语言的编辑入口，赋能想要发展国外业务的卖家，在搜索排名上也会更倾向于这些本地化做的好的商家。这样既解决了本地化内容的问题，又促进了卖家的成交，还带给了买家愉快的购物体验。</p><p>更进一步，让淘宝真的只是作为一个交易平台，在当地推广，让本地人开店把商品卖给本地人，建立本地商品库，那是更好的一种方案了。</p><p>除了商品数据之外，还有一个非常重要不可忽视的就是价格信息。包括货币表示符号、货币单位、价格映射，也是一块比较大的挑战。而稍有差池则会引起强烈的不满。比如类似人民币的这种货币符号，跟日元等比较像，如果没有表述清楚可能会产生一些误解。</p><h3 id="图片内容改变">图片内容改变</h3><p>拿淘宝首页来举例。商品图片内容改变的挑战已经在在上面列出来了，所以不再赘述。本节所说的图片是由视觉做的，然后由我们进行控制的图片，比如首焦图：</p><p><img src="http://qiniu.xueshiming.cn/%E9%A6%96%E7%84%A6%E5%9B%BE.jpg" alt="首焦图"></p><p>这种图片的多语言、国际化我们应该怎么处理呢？马上就可以想到：让视觉在做的时候，把相关文案、视觉换一下，做成多张图片就好了，然后由技术进行定向切换图片地址实现。</p><p>但跟淘海外支持视觉讨论了下，并没有这么简单。如果要做好一个国际化的突破，是需要非常细致的做，并不是简单的文案转换即可，视觉都要有变化。对于十分重要的场景（双十一等）这样的投入也是值得的。而日常的一些需求，如果这样做就会十分的浪费资源，投入跟产出比比较低。</p><p>他介绍了一种更方便实现的思路，希望可以通过技术手段来解决掉这个问题。顺着他描述的需求的原型，我补充了一些更细节的技术实现思路，在这里简单介绍下。</p><p>首先活动图片其实是有一些共性的，比如下图：<br><img src="http://qiniu.xueshiming.cn/TB19dcGLVXXXXXYXXXXXXXXXXXX-578-384.jpg" alt="性冷淡风"><br>基本元素就几个：宣传文案、利益点、辅助图片等。其实很容易形成规范固定下来，比如设计时就放这几个元素，然后基于这几个元素设计一张底图，约定好几个文案元素的位置、大小、字体等，然后由运营填写文案。我们的技术工具可以自动把文案翻译并合并到图片上生成多张多语言的图片。然后当请求这个图片时，会自动根据地区进行返回。实在不行也可以手动填写进去，进行定向投放。</p><p>再到后面，甚至都不需要视觉资源。运营想要一个活动，利用现有的模板，从高质量图片库中取出辅助图片，放上去定下位置，填下文案就可以了。</p><p>这样就可以减少人力资源的投入，也可以很好的实现图片的国际化处理，极大的提高了效率。</p><h3 id="交互样式改变">交互样式改变</h3><p>对于样式、交互的国际化，马上想到的应该是通过给 body 加『唯一地区语言定位串』相关联的 class 来实现定制。这样也有问题，就是与浏览器强绑定，无法实现跨端复用。当你的内容用在 Native 或者没有 body 标签的地方，就没法用了。</p><p>如果用这样一套方案，有两个点需要着重考虑：</p><p>根据语系和习惯来定制 class，而不是语言。比如英文和德语都是字母，他们的样式个性化就有共通性，而不需要定义多个 class 重复编写规则，产生冗余代码。<br>样式是用来适配内容而不是约束内容。中文内容翻译成英文，长度势必会增长，从而产生错位。这就需要在视觉时就要思考到溢出要怎么处理。可以像响应式布局那样流动起来，样式用来适配内容，而不是固定死约束内容展示。<br>后端的处理在这里会有比较大的优势，就 Midway 而言，可以根据上面解析出来的『唯一地区语言定位串』直接映射到某个区域的 xtpl 模板，实现非常灵活的改变。</p><h3 id="国际化的部署服务器">国际化的部署服务器</h3><p>终于到了最后一步，服务器部署国际化。国内的网络都变幻莫测，更别提国外连到国内服务器的网速了。所以我们的服务器也要进行国际化部署。这样就依靠阿里云多造（租）点机房了。</p><p>但并不是所有应用都能迁移到国外，有些核心数据还是要在国内机房。那么这么远距离的链接、数据沟通、应用部署又带来非常多的、不可预知的挑战。</p><h3 id="最后">最后</h3><p>整个过程中，除了上面描述的那些问题和挑战，目前我能想到的还有两个：</p><ul><li>文件编码</li><li>内容不准确性的修正和个性化需要投入的人力成本</li></ul><p>目前淘宝由于历史原因还有一些应用是 GBK 编码，GBK 编码显然不能用于国际化、全球化，特殊语言的国家访问看下来全是『口口口口口口口口口口口口口口口口』。或许这也是一个契机，就像升级 https 那样，推动整个集团去 GBK。</p><p>内容和个性化始终需要人力，我们如何能利用技术进一步提高效率解决人力问题？这也是一个挑战。</p><h3 id="附：国际化方案探索脑图">附：国际化方案探索脑图</h3><p><img src="http://qiniu.xueshiming.cn/%E5%9B%BD%E9%99%85%E5%8C%96%E8%84%91%E5%9B%BE.jpg" alt="国际化探索脑图"></p><p>摘自：<a href="https://taobaofed.org/blog/2016/03/21/internationalization/" target="_blank" rel="noopener">国际化探索</a></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端国际化探索(一)</title>
      <link href="/2019/01/20/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%B8%80)/"/>
      <url>/2019/01/20/%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96%E6%96%B9%E6%A1%88%E6%8E%A2%E7%B4%A2(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<blockquote><p>对于海外的业务需求，我们期望能让客户有一个良好的用户体验，因此前端需要适配国际化。</p></blockquote><a id="more"></a><h3 id="面临的挑战">面临的挑战</h3><p>乍一听，这个海外项目需求并没有什么特别的地方，似乎就多了一个国际化适配。但细细一想，事情可没这么简单，前端开发面临了很多新的问题。下面梳理一下国际化开发中通常会面临的挑战：</p><ul><li><p>页面文案全部可配置 需要配置的文案大致有四种：label、placeholder、字段校验提示信息、超链接。<br><img src="http://qiniu.xueshiming.cn/%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%981" alt="页面文案配置"></p></li><li><p>页面文案样式处理 文案样式需要特别注意，不同语言的文字，可能会有不同的表现。例如下面两张图所示：</p><ul><li>英语（页面样式正常）<br><img src="http://qiniu.xueshiming.cn/%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%982" alt="英文"></li><li>土耳其语（页面样式异常）<br><img src="http://qiniu.xueshiming.cn/%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%983" alt="土耳其语"></li></ul></li><li><p>日期、数字格式处理 页面上展示日期或数量的地方，也是需要做国际化适配。</p></li><li><p>LTR／RTL 很多中东国家的语言习惯都是 RTL，可以尝试使用 direction 和 transform 来解决。</p></li><li><p>图片（banner）国际化 如果你想把国际化做的足够精细，那么图片国际化也是需要考虑的。</p></li><li><p>第三方 UI 组件 如果使用了第三方 UI 组件，如：elementUI、ant design UI 等，这些 UI 框架通常都宣称支持国际化，但支持的国际化语言数量有限，并不一定能满足业务需求。</p></li><li><p>前端开发工作量和后期维护成本激增 大量的文案需要被提取出来，被提取出来的文案最终会被合并到一个文件中去，如：en-US.json。这些工作如果通过手工完成，那么工作量会是非常巨大的。</p></li></ul><h3 id="国际化文案的处理思路">国际化文案的处理思路</h3><p>以上列举出了很多挑战，但实际上“页面文案处理”才是最主要的矛盾，因为它直接导致前端开发工作量和维护成本的激增。<br>下面我们重点来讨论文案处理思路，其实从实现国际化的角度来看，jQuery、Vue、React 等都只是载体而已，实现思路都是相通的，因此国际化文案处理与具体的技术框架并不耦合。</p><p>一般我们会使用两种比较流行的国际化方案：<a href="https://github.com/yahoo/react-intl" target="_blank" rel="noopener">react-intl</a>、<a href="https://github.com/alibaba/react-intl-universal" target="_blank" rel="noopener">react-intl-universal</a>，下面，我来做一个对比：</p><table><thead><tr><th></th><th style="text-align:center">react-intl</th><th style="text-align:center">react-intl-universal</th></tr></thead><tbody><tr><td>切换不刷新页面</td><td style="text-align:center">优</td><td style="text-align:center">劣</td></tr><tr><td>js文件支持(重要)</td><td style="text-align:center">劣</td><td style="text-align:center">优</td></tr><tr><td>名词单双数，默认值，html</td><td style="text-align:center">优</td><td style="text-align:center">优</td></tr><tr><td>无破坏性</td><td style="text-align:center">劣(装饰器的代码实现会改变ref)</td><td style="text-align:center">优</td></tr></tbody></table><p>react-intl只支持在jsx文件的内容中使用，但是由于项目配置化编程的缘故，很多中文是写在js对象中的。react-intl不支持在普通js对象中使用，很不方便。而且他的装饰器实现会改变组件的ref。他唯一的好处是他的切换不需要刷新页面，不过这种低频的操作刷新页面倒也无妨。</p><p>接下来将会抛出几种国际化文案处理思路，每种思路对生产力和生产关系的要求有高有低，姑且将其分别对应为石器时期、青铜时期、黄金时期。</p><h4 id="石器时期">石器时期</h4><p>传统的国际化开发流程：前端开发到一定阶段，将文案提取到资源文件（通常为 en-US.json），然后将资源文件发送给翻译团队，翻译团队翻译出各国语言版本的文案，每种语言对应一个资源文件，最后将这些资源文件发回给前端开发人员，前端开发人员更新到自己本地。如下图所示：<br><img src="http://qiniu.xueshiming.cn/%E7%9F%B3%E5%99%A8%E6%97%B6%E4%BB%A31" alt=""></p><ul><li>适用场景</li></ul><ol><li>页面上要提取的文案不多</li><li>支持的国际化语言较少，比如：只需要支持中文和英文</li><li>项目需求较固定，后期只做简单维护，不会新增大的需求</li></ol><ul><li><p>分析<br>这是国际化开发的基本流程，“前端开发”和“翻译团队”是必不可少的两个节点，但它们相互之间依赖的太重。“提取文案”的过程本质上是在重复劳动，因此可以考虑由程序来完成。</p></li><li><p>代码示例</p><p>App.js</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; IntlProvider, FormattedMessage &#125; from &apos;react-intl&apos;;</span><br><span class="line">import qs from &apos;querystring&apos;;</span><br><span class="line"></span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import DEFAULT_MESSAGES from &apos;./i18n/en-US.json&apos;;</span><br><span class="line"></span><br><span class="line">const DEFAULT_LOCALE = &apos;en-US&apos;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">messages: DEFAULT_MESSAGES,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">const search = window.location.search.slice(1);</span><br><span class="line">const params = qs.parse(search);</span><br><span class="line">const locale = params.locale || DEFAULT_LOCALE;</span><br><span class="line">const messages = require(`./i18n/$&#123;locale&#125;.json`);</span><br><span class="line">debugger;</span><br><span class="line">this.setState(&#123;</span><br><span class="line">  messages,</span><br><span class="line">&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">const &#123; messages &#125; = this.state;</span><br><span class="line">return (</span><br><span class="line">  &lt;IntlProvider locale=&quot;en&quot; messages=&#123;messages&#125;&gt;</span><br><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">  &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">&lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;FormattedMessage</span><br><span class="line">id=&quot;welcome&quot;</span><br><span class="line">defaultMessage=&#123;`Hello world!`&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;a</span><br><span class="line">  className=&quot;App-link&quot;</span><br><span class="line">  href=&quot;/?locale=zh-CN&quot;</span><br><span class="line">  rel=&quot;noopener noreferrer&quot;</span><br><span class="line">&gt;</span><br><span class="line">  zh-CN</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;a</span><br><span class="line">  className=&quot;App-link&quot;</span><br><span class="line">  href=&quot;/?locale=en-US&quot;</span><br><span class="line">  rel=&quot;noopener noreferrer&quot;</span><br><span class="line">&gt;</span><br><span class="line">  en-US</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  &lt;/IntlProvider&gt;</span><br><span class="line">);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>en-US.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;welcome&quot;: &quot;Hello world!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="青铜时期">青铜时期</h4><p>前面分析了“提取文案”的过程本质上是在重复劳动，那我们看看有没有办法进行改进。我们可以先对比一下“无国际化需求”和“有国际化需求”时的前端开发流程。如图所示：</p><p><img src="http://qiniu.xueshiming.cn/%E9%9D%92%E9%93%9C%E6%97%B6%E6%9C%9F1" alt=""></p><p>可以看出右边多了三个过程：</p><ol><li>将文案提取为变量</li><li>为变量命名，要合乎其场景</li><li>将变量和文案信息存到资源文件</li></ol><p>这里我们提出一个期望或愿景：希望能像开发普通业务一样去开发有国际化需求的业务！</p><p>为了达成这一愿景，我们需要有一个工具：它能够扫描指定的文件，并能识别出文件中的字符串，然后能根据字符串的含义生成变量名，并用变量表达式替换掉原来的字符串，最后能够将提取出来的变量自动追加到资源文件中。</p><p>如何实现这样的工具？我们可以用 Babel 将js文件解析为一颗语法树，然后遍历并找出字符串节点，接下来调用 Google Cloud Translation API 将字符串翻译为英文，并以此作为变量名得到变量表达式，最后用变量表达式替换掉原来的文本即可。如下图所示：</p><p><img src="http://qiniu.xueshiming.cn/%E9%9D%92%E9%93%9C%E6%97%B6%E6%9C%9F2" alt=""></p><p>幸运的是，<a href="https://github.com/ProtoTeam/i18n-pick" target="_blank" rel="noopener">i18n-pick</a> 已经有那么点味道了~</p><p><img src="http://qiniu.xueshiming.cn/%E9%9D%92%E9%93%9C%E6%97%B6%E6%9C%9F3" alt=""></p><ul><li>分析 这是站在开发层面，对前端开发体验和开发效率提出的改进办法，<strong>将重复的事情交给程序去完成。</strong></li></ul><h4 id="黄金时期">黄金时期</h4><p>有了石器时期的生产方式作为铺垫，我们可以在此基础上继续做改进。既然“前端开发”和“翻译团队”之间依赖的太重，那我们可以在中间加一个节点“文案配置平台”。前端将提取的文案直接上传到“文案配置平台”，翻译团队直接在“文案配置平台”上进行文案翻译，前端直接从“文案配置平台”获取翻译后的最新文案。</p><p><img src="http://qiniu.xueshiming.cn/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3" alt=""></p><ul><li><p>文案配置平台应当具备的基本能力</p><ol><li>面向前端开发人员：文案录入、输出</li><li>面向翻译团队：文案翻译、发布</li><li>其他：文案版本控制</li></ol></li><li><p>适用场景</p><ol><li>有大量的国际化业务需求</li><li>希望将其沉淀为通用能力平台，提升业务开发效率</li></ol></li><li><p>分析<br>这是从架构层面对国际化开发方式进行优化和提效，一般大的互联网公司因为其自身业务的复杂度，都早已沉淀出很多的通用能力平台。</p></li></ul><h3 id="总结">总结</h3><p>以上每种思路都有各自适用的场景，实际生产中需要从开发成本、开发体验、后期维护、能力沉淀等多维度进行考虑。这篇文章旨在抛砖引玉打开思路，各位看官可以将自己的思路抛出来一起讨论。</p><h3 id="参考">参考</h3><ul><li><a href="https://www.w3.org/standards/webdesign/i18n" target="_blank" rel="noopener">Internationalization</a></li><li><a href="https://zhuanlan.zhihu.com/p/47864242" target="_blank" rel="noopener">国际化 - 通用 LTR/RTL 布局解决方案</a></li><li><a href="https://github.com/ProtoTeam/i18n-pick" target="_blank" rel="noopener">i18n-pick</a></li><li><a href="https://github.com/brigand/babel-plugin-handbook/blob/master/translations/zh-Hans/README.md#visitors" target="_blank" rel="noopener">Babel 插件开发指南</a></li><li><a href="https://github.com/googleapis/nodejs-translate" target="_blank" rel="noopener">Google Cloud Translation API: Node.js Client</a></li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React生命周期管理</title>
      <link href="/2018/10/31/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/"/>
      <url>/2018/10/31/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<blockquote><p>你有没有遇到过这样的问题: setState应该写在哪里？我们应该什么时候去获取后台的数据？怎样减少页面不必要的渲染？带着问题我们一起来回顾一下React生命周期那些知识点</p></blockquote><a id="more"></a><h3 id="生命周期">生命周期</h3><p>我们先看下下面的图建立一个React组件生命周期的直观认识，图为React 16的生命周期，总的来说React组件的生命周期分为三个部分: <code>装载期间(Mounting)</code> ，<code>更新期间(Updating)</code> 和 <code>卸载期间(Unmounting)</code> ，React16多出来一个componentDidCatch() 函数用于捕捉错误。知道什么时候去使用哪些生命周期函数对于掌握和理解React是非常重要的，你可以看到这些生命周期函数有一定的规律，比如在某件事情发生之前调用的会用xxxWillxxx，而在这之后发生的会用xxxDidxxx。</p><p><img src="http://qiniu.xueshiming.cn/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="code"></p><p>接下来我们就这三个阶段分别介绍一下各个生命周期函数，详细的生命周期函数解释可以看官方文档  <a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="noopener">React.Component</a></p><h3 id="装载期间">装载期间</h3><p>组件被实例化并挂载在到DOM树这一过程称为装载，在装载期调用的生命周期函数依次为</p><ul><li><a href="https://reactjs.org/docs/react-component.html#constructor" target="_blank" rel="noopener">constructor()</a></li><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops" target="_blank" rel="noopener">getDerivedStateFromProps()</a></li><li><a href="https://reactjs.org/docs/react-component.html#render" target="_blank" rel="noopener">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidmount" target="_blank" rel="noopener">componentDidMount()</a></li></ul><p>上图中还有一些函数比如<code>getDefaultProps</code>, <code>getInitialState</code>等是在你不是用ES6的class创建组件而是用<code>createReactClass</code>函数创建函数时暴露的方法，分别用于定义属性和设置初始状态，详见<a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">React-without-es6</a>，这里我们不再赘述。</p><p>通常推荐使用继承组件类的方式进行组件创建，即<code>class Analysis extends Component{}</code></p><h4 id="constructor-props">constructor(props)</h4><p>构造函数，和java class的构造函数一样，用于初始化这个组件的一些状态和操作，如果你是通过继承<code>React.Component</code>子类来创建React的组件的，那么你应当首先调用<code>super(props)</code>初始化父类。</p><p>在contructor函数中，你可以<b>初始化state</b>，比如<code>this.state = {xxx};</code>，不要在构造函数中使用setState()函数，强行使用的话React会报错。其次你可以在构造函数中<b>进行函数bind</b>，如:</p><p><code>this.handleClick = this.handleClick.bind(this);</code></p><p>一个示例contructor实现如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    color: &apos;#fff&apos;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.handleClick = this.handleClick.bind(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你不需要初始化状态也不需要绑定handle函数的this，那么你可以不实现constructor函数，由默认实现代替。</p><h4 id="getderivedstatefromprops">getDerivedStateFromProps()</h4><p>这个函数会在render函数被调用之前调用，包括第一次的初始化组件以及后续的更新过程中，每次接收新的props之后都会返回一个对象作为新的state，返回null则说明不需要更新state。</p><p>该方法主要用来替代componentWillReceiveProps方法，willReceiveProps经常被误用，导致了一些问题，因此在新版本中被标记为unsafe。以<a href="https://juejin.im/post/5abf4a09f265da237719899d" target="_blank" rel="noopener">掘金</a>上的🌰为例，componentWillReceiveProps的常见用法如下，根据传进来的属性值判断是否要load新的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class ExampleComponent extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: false,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    if (this.props.currentRow !== nextProps.currentRow) &#123;</span><br><span class="line"></span><br><span class="line">      &lt;!-- 检测到变化后更新状态、并请求数据 --&gt;</span><br><span class="line"></span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        isScrollingDown: nextProps.currentRow &gt; this.props.currentRow,</span><br><span class="line">      &#125;);</span><br><span class="line">      this.loadAsyncData()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadAsyncData() &#123;/* ... */&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个方法的一个问题是外部组件多次频繁更新传入多次不同的 props，而该组件将这些更新 batch 后仅仅触发单次自己的更新，这种写法会导致不必要的异步请求，相比下来getDerivedStateFromProps配合componentDidUpdate的写法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class ExampleComponent extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isScrollingDown: false,</span><br><span class="line">    lastRow: null,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 不再提供 prevProps 的获取方式 --&gt;</span><br><span class="line"></span><br><span class="line">    if (nextProps.currentRow !== prevState.lastRow) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        isScrollingDown: nextProps.currentRow &gt; prevState.lastRow,</span><br><span class="line">        lastRow: nextProps.currentRow,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认不改动 state --&gt;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line"></span><br><span class="line">     &lt;!-- 仅在更新触发后请求数据 --&gt;</span><br><span class="line"></span><br><span class="line">    this.loadAsyncData()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  loadAsyncData() &#123;/* ... */&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式只在更新触发后请求数据，相比下来更节省资源。</p><blockquote><p>注意getDerivedStateFromProps是一个static方法，意味着拿不到实例的this</p></blockquote><h4 id="render">render()</h4><blockquote><p>该方法在一个React组件中是必须实现的，你可以看成是一个java interface的接口</p></blockquote><p>这是React组件的核心方法，用于根据状态state和属性props渲染一个React组件。我们应该保持该方法的纯洁性，这会让我们的组件更易于理解，只要state和props不变，每次调用render返回的结果应当相同，所以<br><b>请不要在render方法中改变组件状态，也不要在在这个方法中和浏览器直接交互。</b></p><h4 id="componentdidmount">componentDidMount()</h4><p>componentDidMount方法会在render方法之后立即被调用，该方法在整个React生命周期中<code>只会被调用一次</code>。React的组件树是一个树形结构，此时你可以认为这个组件以及他下面的所有子组件都已经渲染完了，所以在这个方法中你可以调用和真实DOM相关的操作了。</p><p>有些组件的启动工作是依赖 DOM 的，例如动画的启动，而 <code>componentWillMount</code> 的时候组件还没挂载完成，所以没法进行这些启动工作，这时候就可以把这些操作放在 <code>componentDidMount</code> 当中。</p><p>我们推荐可以在这个函数中<code>发送异步请求</code>，在回调函数中调用setState()设置state，等数据到达后触发重新渲染。但注意尽量<b>不要在这个函数中直接调用setState()</b>设置状态，这会触发一次额外的重新渲染，可能造成性能问题。</p><p>下面的代码演示了如何在componentDidMount加载数据并设置状态:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">   console.log(&apos;componentDidMount&apos;);</span><br><span class="line">   fetch(&quot;https://api.github.com/search/repositories?q=language:java&amp;sort=stars&quot;)</span><br><span class="line">     .then(res =&gt; res.json())</span><br><span class="line">     .then((result) =&gt; &#123;</span><br><span class="line">         this.setState(&#123; // 触发render</span><br><span class="line">           items: result.items</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125;)</span><br><span class="line">     .catch((error) =&gt; &#123; console.log(error)&#125;);</span><br><span class="line">   // this.setState(&#123;color: xxx&#125;) // 不要这样做</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="更新期间">更新期间</h3><p>当组件的状态或属性变化时会触发更新，更新过程中会依次调用以下方法:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#static-getderivedstatefromprops" target="_blank" rel="noopener">getDerivedStateFromProps()</a>  上文已描述，不赘述</li><li><a href="https://reactjs.org/docs/react-component.html#unsafe_componentwillupdate" target="_blank" rel="noopener">componentWillUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#render" target="_blank" rel="noopener">render()</a></li><li><a href="https://reactjs.org/docs/react-component.html#getsnapshotbeforeupdate" target="_blank" rel="noopener">getSnapshotBeforeUpdate()</a></li><li><a href="https://reactjs.org/docs/react-component.html#componentdidupdate" target="_blank" rel="noopener">componentDidUpdate()</a></li></ul><h4 id="shouldcomponentupdate-nextprops-nextstate">shouldComponentUpdate(nextProps, nextState)</h4><p>你可以用这个方法来告诉React是否要进行下一次render()，默认这个函数放回true，即每次更新状态和属性的时候都进行组件更新。注意这个函数如果返回false并不会导致子组件也不更新。</p><p>这个钩子函数一般不需要实现, 如果你的组件性能比较差或者渲染比较耗时，你可以考虑使React.PureComponent 重新实现该组件，PureComponent默认实现了一个版本的shouldComponentUpdate会进行state和props的比较。当然如果你有自信，可以自己实现比较nextProps和nextState是否发生了改变。</p><p>该函数通常是优化性能的紧急出口，是个大招，不要轻易用，如果要用可以参考<a href="https://github.com/camsong/blog/issues/3" target="_blank" rel="noopener">Immutable 详解及 React 中实践</a> .</p><h4 id="getsnapshotbeforeupdate">getSnapshotBeforeUpdate()</h4><p>该方法的触发时间为update发生的时候，在render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数。该函数与 componentDidUpdate 一起使用可以取代 componentWillUpdate 的所有功能，比如以下是官方的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    // Are we adding new items to the list?</span><br><span class="line">    // Capture the scroll position so we can adjust scroll later.</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    // If we have a snapshot value, we&apos;ve just added new items.</span><br><span class="line">    // Adjust scroll so these new items don&apos;t push the old ones out of view.</span><br><span class="line">    // (snapshot here is the value returned from getSnapshotBeforeUpdate)</span><br><span class="line">    if (snapshot !== null) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="componentdidupdate-prevprops-prevstate-snapshot">componentDidUpdate(prevProps, prevState, snapshot)</h4><p>该方法会在更新完成后被立即调用，你可以在这个方法中进行<b>DOM操作</b>，或者做一些<b>异步调用</b>。这个和首次装载过程后调用componentDidMount是类似的，不一样的是你可能需要判断下属性是否变化了再发起网络请求，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps) &#123; // 来自网络</span><br><span class="line">  if(prevProps.myProps !== this.props.myProp) &#123;</span><br><span class="line">    // this.props.myProp has a different value</span><br><span class="line">    // we can perform any operations that would</span><br><span class="line">    // need the new value and/or cause side-effects</span><br><span class="line">    // like AJAX calls with the new value - this.props.myProp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="卸载期间">卸载期间</h3><p>卸载期间是指组件被从DOM树中移除时，调用的相关方法为:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentwillunmount" target="_blank" rel="noopener">componentWillUnmount()</a></li></ul><h4 id="componentwillunmount">componentWillUnmount()</h4><p>该方法会在组件被卸载之前被调用，如果你学过C++，那么这玩意和析构函数差不多，在方法里清理内存之类的，当然如果你用java请不用在意。如上所述，你可以在这个函数中进行相关清理工作，比如删除定时器之类的。<br>下面给个示例代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    console.log(&apos;componentWillUnmount&apos;);</span><br><span class="line"></span><br><span class="line">    // 清除timer</span><br><span class="line">    clearInterval(this.timerID1);</span><br><span class="line">    clearTimeout(this.timerID2);</span><br><span class="line"></span><br><span class="line">    // 关闭socket</span><br><span class="line">    this.myWebsocket.close();</span><br><span class="line"></span><br><span class="line">    // 取消消息订阅...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="错误捕获">错误捕获</h3><p>React16中新增了一个生命周期函数:</p><ul><li><a href="https://reactjs.org/docs/react-component.html#componentdidcatch" target="_blank" rel="noopener">componentDidCatch()</a></li></ul><h4 id="componentdidcatch-error-info">componentDidCatch(error, info)</h4><p>在react组件中如果产生的错误没有被捕获会被抛给上层组件，如果上层也不处理的话就会抛到顶层导致浏览器白屏错误，在React16中我们可以实现这个方法来捕获子组件产生的错误，然后在父组件中妥善处理，比如搞个弹层通知用户网页崩溃等。</p><p>在这个函数中请只进行错误恢复相关的处理，不要做其他流程控制方面的操作。比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidCatch(error, info) &#123; // from react.org</span><br><span class="line">    // Display fallback UI</span><br><span class="line">    this.setState(&#123; hasError: true &#125;);</span><br><span class="line">    // You can also log the error to an error reporting service</span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="react16中的生命周期函数变化">React16中的生命周期函数变化</h3><p>componentWillMount，componentWillUpdate, componentWillReceiveProps等生命周期方法在下个主版本中会被废弃?<br>根据这份<a href="https://github.com/reactjs/rfcs/blob/master/text/0006-static-lifecycle-methods.md" target="_blank" rel="noopener">RFC</a>，是的，这些生命周期方法被认为是不安全的，在React16中被重命名为UNSAFE_componentWillMount，UNSAFE_componentWillUpdate，UNSAFE_componentWillReceiveProps，而在更下个大版本中他们会被废弃。详见<a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html" target="_blank" rel="noopener">React 16.3版本发布公告</a>。</p><h3 id="总结">总结</h3><p>总结一下，以上讲的这些生命周期都有自己存在的意义，但在React使用过程中我们最常用到的生命周期函数是如下几个:</p><ul><li>constructor: 初始化状态，进行函数绑定</li><li>componentDidMount: 进行DOM操作，进行异步调用初始化页面</li><li>componentWillReceiveProps: 根据props更新状态</li><li>componentWillUnmount: 清理组件定时器，网络请求或者相关订阅等<br>其他的逻辑一般和用户的操作有关(各种handleClickXXXX），当然需要用到其他生命周期函数可以按需正确使用。如果阅读文章过程中遇到问题欢迎评论进行修正。</li></ul><blockquote><p>本文引用自<a href="https://www.yuque.com/fe9/select/fon761#lwhpkf" target="_blank" rel="noopener">九部知识库-精选集</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小程序探险指南（一）</title>
      <link href="/2018/10/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A2%E9%99%A9%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/10/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%A2%E9%99%A9%E6%8C%87%E5%8D%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote><p>终于有时间去详细了解一下小程序了，下面我们就从HelloWorld开始，走近小程序，一探究竟。</p></blockquote><a id="more"></a><h3 id="准备工作">准备工作</h3><ul><li><p>注册小程序账号<br>要想开始开发小程序我们需要完成以下流程：</p><p><img src="http://qiniu.xueshiming.cn/%E7%94%B3%E8%AF%B7%E8%B4%A6%E5%8F%B7.png" alt="开发前准备工作"></p></li><li><p>安装微信开发者工具<br>包含</p><p>Windows 64位 / Windows 32位 / Mac OS</p><blockquote><p>Windows 仅支持 Windows 7 及以上版本。</p></blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener">安装地址请戳</a></p></li></ul><p><img src="http://qiniu.xueshiming.cn/%E5%AE%89%E8%A3%85.png" alt="开发工具安装"></p><ul><li>使用微信开发者工具</li></ul><p>初始界面：</p><p><img src="http://qiniu.xueshiming.cn/useTool.png" alt="使用开发工具"></p><p>编译器界面：<br>分为一下几栏：<br><code>模拟器</code>：<br>微信开发者工具是支持实时调试的，左边就相当于模拟器，可以看到代码最新的效果，很方便。</p><p><code>代码编辑区</code>：<br>当然是在这个编写小程序代码啦。</p><p><code>调试区</code>：<br>十分像chrom浏览器的调试栏，调试程序，查看网络请求等。</p><p><code>远程调试</code>：<br>这是微信小程序开发者最喜欢的一个功能，直接可以在真机上模拟效果。</p><p><img src="http://qiniu.xueshiming.cn/%E7%BC%96%E8%AF%91%E5%99%A8%E7%95%8C%E9%9D%A2.png" alt="使用开发工具"></p><ul><li>小程序版本<br>从最初的开发到最后小程序发布上线，我们需要经历一下几个版本：</li></ul><p><img src="http://qiniu.xueshiming.cn/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%89%88%E6%9C%AC.png" alt="小程序版本"></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Symbol对象</title>
      <link href="/2018/09/19/Symbol%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/09/19/Symbol%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>称符号对象，是es2015(也就是es6)中新添加的数据类型。通过Symbol()可以得到一个唯一的值，所以这个值很适合做标识符。</p></blockquote><a id="more"></a><h3 id="概念">概念</h3><p>Symbol() function 返回一个类型为symbol的值，Symbol有静态属性，原型上也有methods，但是缺少constructor，所以你不能<code>new Symbol()</code>来执行；</p><blockquote><p>引用官方翻译，符号是一种特殊的、不可变的数据类型，它可以作为对象属性的标识符使用。符号对象是一个对的符号原始数据类型的隐式对象包装器。</p></blockquote><ul><li>类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(); // Symbol中参数为字符串，用来描述。</span><br><span class="line">console.log(typeof sym); //&quot;symbol&quot;</span><br></pre></td></tr></table></figure><ul><li>唯一性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;abc&apos;);</span><br><span class="line">const sym2 = Symbol(&apos;cba&apos;);</span><br><span class="line">console.log(sym1,sym2); //Symbol(abc) Symbol(cba)</span><br><span class="line">//参数的作用就是描述，便于调试</span><br><span class="line">console.log(sym1.toString()) //&apos;Symbol(abc)&apos;</span><br></pre></td></tr></table></figure><ul><li>new关键字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sym = new Symbol(); // TypeError</span><br></pre></td></tr></table></figure><h3 id="获取symbol类型值的三种方式">获取symbol类型值的三种方式</h3><ul><li>通过Symbol对象</li></ul><blockquote><p>也就是前面说的  let sym = Symbol();得到一个为一个的symbol值</p></blockquote><ul><li>Symbol.for(string)</li></ul><blockquote><p>可以注册一个symbol，再次调用Symbol.for(string)会得到这个symbol值，区别于Symbol()是唯一的</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&apos;abc&apos;);</span><br><span class="line">const sym1 = Symbol.for(&apos;abc&apos;);</span><br><span class="line">console.log(sym === sym1); //false</span><br><span class="line">console.log(sym1 === Symbol.for(&apos;abc&apos;)); //true</span><br></pre></td></tr></table></figure><p>-Symbol.iterator</p><blockquote><p>这个比较特别，得到的也是symbol类型的值，是es6中提出用到对象中，被for…of遍历所用，下面将进行详细介绍。</p></blockquote><p>由于这个值是标准规范提出，用于每个object中，所以应该是固定的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol.iterator === Symbol.iterator); //true</span><br></pre></td></tr></table></figure><h3 id="用途">用途</h3><blockquote><p>在我看来，symbol更多是应用于es6规范中，由于它的值唯一的特性，可以解决变量名，属性名冲突的问题，并切Symbol提出了一些属性和方法，用于过渡以及实现一些特殊的用途，比如对象的迭代器，instanceof的拓展等等。</p></blockquote><ul><li>栗子。像我们项目中大量的使用常量定义字符串，尤其是react+redux的项目中，我觉得用Symbol就不错。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const GETLIST_SUCCESS = Symbol(&apos;get-list-success&apos;);</span><br><span class="line"></span><br><span class="line">const getList = () =&gt; dispatch(&#123;</span><br><span class="line">   type: GETLIST_SUCCESS</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line">const list = function(state = &#123;&#125;, action) &#123;</span><br><span class="line">  switch(action.type):</span><br><span class="line">    case GETLIST_SUCCESS:</span><br><span class="line">      // code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我这里只是举一个例子，这种标识性的Symbol可以用的地方。大家可以不必关注redux。</p></blockquote><ul><li>另外，Symbol值可以做为对象的key值，这样就能保证不会出现同名的属性名，防止对象属性被覆盖。下面我们将介绍Symbol作为属性名的写法。</li></ul><h3 id="作为对象的key">作为对象的key</h3><ul><li>对象[]方括号的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">const sym = Symbol();</span><br><span class="line">obj[sym] = &apos;syj&apos;;</span><br></pre></td></tr></table></figure><ul><li>对象内部定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  [sym]: &apos;syj&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Object.defineProperty定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line">const obj = Object.defineProperty(&#123;&#125;, sym, &#123;</span><br><span class="line">  enumerable: true, //可枚举</span><br><span class="line">  writable: true,  //可赋值运算符改变</span><br><span class="line">  configurable: true, //可改变，可删除</span><br><span class="line">  value: &apos;syj&apos;</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，symbol作为属性名不能通过 . 的形式添加。</p></blockquote><p>通过上述三种方式，我们就可以向对象添加key不会重复的symbol值了。意味着我们可以创建非字符串类型的属性名称，以防止使用常规手段来探查这些名称。</p><ul><li>symbol类型的key的遍历</li></ul><blockquote><p>当我们用symbol设置了对象的key以后，他是不会被之前的for…in，Object.keys()遍历出来的，需要用Object.getOwnPropertySymbols()获取，得到一个所有这个对象中的symbol属性名的数组。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sym1 = Symbol(&apos;1&apos;);</span><br><span class="line">const sym2 = Symbol(&apos;2&apos;);</span><br><span class="line">const obj = &#123;</span><br><span class="line">  [sym1]: &apos;syj&apos;,</span><br><span class="line">  [sym2]: &apos;fy&apos;</span><br><span class="line">&#125;</span><br><span class="line">const ary = Object.getOwnPropertySymbols(obj);</span><br><span class="line">console.log(ary); //[ Symbol(1), Symbol(2) ]</span><br></pre></td></tr></table></figure><h3 id="内置的symbol值">内置的Symbol值</h3><ul><li>对象[]方括号的形式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;</span><br><span class="line">const sym = Symbol();</span><br><span class="line">obj[sym] = &apos;syj&apos;;</span><br></pre></td></tr></table></figure><ul><li>对象内部定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  [sym]: &apos;syj&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过Object.defineProperty定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const sym = Symbol();</span><br><span class="line">const obj = Object.defineProperty(&#123;&#125;, sym, &#123;</span><br><span class="line">  enumerable: true, //可枚举</span><br><span class="line">  writable: true,  //可赋值运算符改变</span><br><span class="line">  configurable: true, //可改变，可删除</span><br><span class="line">  value: &apos;syj&apos;</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>注意，symbol作为属性名不能通过 <figure class="highlight plain"><figcaption><span>``` 的形式添加。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">通过上述三种方式，我们就可以向对象添加key不会重复的symbol值了。意味着我们可以创建非字符串类型的属性名称，以防止使用常规手段来探查这些名称。</span><br><span class="line"></span><br><span class="line">- symbol类型的key的遍历</span><br><span class="line"></span><br><span class="line">&gt;当我们用symbol设置了对象的key以后，他是不会被之前的for...in，Object.keys()遍历出来的，需要用Object.getOwnPropertySymbols()获取，得到一个所有这个对象中的symbol属性名的数组。</span><br></pre></td></tr></table></figure></p></blockquote><p>const sym1 = Symbol(‘1’);<br>const sym2 = Symbol(‘2’);<br>const obj = {<br>[sym1]: ‘syj’,<br>[sym2]: ‘fy’<br>}<br>const ary = Object.getOwnPropertySymbols(obj);<br>console.log(ary); //[ Symbol(1), Symbol(2) ]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 内置的Symbol值</span><br><span class="line"></span><br><span class="line">&gt;JavaScript内建的一些在 ECMAScript 5 之前没有暴露给开发者的符号，它们代表语言的内部行为。</span><br><span class="line"></span><br><span class="line">- Symbol.iterator属性</span><br><span class="line"></span><br><span class="line">我觉得是最重要的属性，它的提出使对象可以使用迭代器遍历，之前只有Array,String等，这种内置Symbol.iterator属性的可以使用迭代器。ECMAScript旨在使JS中使用一种方法,比如for...of就可以遍历序列数据，不需要关注它内部的数据结构。其实就是JS往C,JAVA语言靠拢的趋势吧。</span><br><span class="line">为了避免此部分过于重，我们后面会专门研究迭代器和生成器。</span><br><span class="line"></span><br><span class="line">- Symbol.hasInstance</span><br><span class="line"></span><br><span class="line">&gt;之前我们用instanceof的时候，比如```a instaceof A```其实就是调用的A对象中的Symbol.hasInstance属性，它指向一个内部方法，现在es6拓展出来，我们可以自己定义啦。</span><br><span class="line"></span><br><span class="line">先看看下面的代码，猜想输出什么？</span><br></pre></td></tr></table></figure><p>class MyClass{<br>static <a href="num">Symbol.hasInstance</a> {<br>return num % 2 === 0<br>}</p><p><a href="num">Symbol.hasInstance</a> {<br>return num % 2 === 0<br>}<br>}<br>console.log(1 instanceof MyClass); // 序号(1)<br>console.log(2 instanceof MyClass); // 序号(2)<br>console.log(2 instanceof new MyClass()); // 序号(3)</p><p>const obj = {<br><a href="obj">Symbol.hasInstance</a> {<br>return num % 2 === 0<br>}<br>}<br>console.log(1 instanceof obj);// 序号(4)</p><pre><code>序号(1) MyClass类上有静态方法[Symbol.hasInstance], 1被当做参数传入function，返回结果false。 序号(2)同理,true。序号(3) 后面是实例化的对象，通过原型链查找到原型上[Symbol.hasInstance]，然后传入2执行，true。序号(4)是普通对象内部存在这个方法，执行返回false。</code></pre>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React高阶组件(repost)</title>
      <link href="/2018/08/23/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6(repost)/"/>
      <url>/2018/08/23/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6(repost)/</url>
      <content type="html"><![CDATA[<h3 id="前言">前言</h3><blockquote><p>本文代码浅显易懂，思想深入实用。此属于react进阶用法，如果还不是很了解react，建议从文档开始看起。</p></blockquote><a id="more"></a><p>我们都知道高阶函数是什么, 高阶组件其实是差不多的用法，只不过传入的参数变成了react组件，并返回一个新的组件.</p><blockquote><p>A higher-order component is a function that takes a component and returns a new component.</p></blockquote><p>形如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent = higherOrderComponent(WrappedComponent);</span><br></pre></td></tr></table></figure><p>高阶组件是react应用中很重要的一部分，最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。<br>如果你用过redux，那你就一定接触过高阶组件，因为react-redux中的connect<br>就是一个高阶组件。</p><p>另外本次demo代码都放在 <a href="https://github.com/sunyongjian/hoc-demo" target="_blank" rel="noopener">hoc-demo</a></p><h3 id="引入">引入</h3><p>先来一个最简单的高阶组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import simpleHoc from &apos;./simple-hoc&apos;;</span><br><span class="line"></span><br><span class="line">class Usual extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.props, &apos;props&apos;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default simpleHoc(Usual);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const simpleHoc = WrappedComponent =&gt; &#123;</span><br><span class="line">  console.log(&apos;simpleHoc&apos;);</span><br><span class="line">  return class extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent &#123;...this.props&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default simpleHoc;</span><br></pre></td></tr></table></figure><p>组件Usual通过simpleHoc的包装，打了一个log… 那么形如simpleHoc就是一个高阶组件了，通过接收一个组件class Usual，并返回一个组件class。 其实我们可以看到，在这个函数里，我们可以做很多操作。 而且return的组件同样有自己的生命周期，function，另外，我们看到也可以把props传给WrappedComponent(被包装的组件)。 高阶组件的定义我都是用箭头函数去写的，如有不适请参照<br><a href="https://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">arrow function</a></p><h3 id="装饰器模式">装饰器模式</h3><p>高阶组件可以看做是装饰器模式(Decorator Pattern)在React的实现。即允许向一个现有的对象添加新的功能，同时又不改变其结构，属于包装模式(Wrapper Pattern)的一种</p><p>ES7中添加了一个decorator的属性，使用@符表示，可以更精简的书写。那上面的例子就可以改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import simpleHoc from &apos;./simple-hoc&apos;;</span><br><span class="line"></span><br><span class="line">@simpleHoc</span><br><span class="line">export default class Usual extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Usual</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是同样的效果。<br>当然兼容性是存在问题的，通常都是通过babel去编译的。 babel提供了plugin，高阶组件用的是类装饰器，所以用 <code>transform-decorators-legacy</code></p><h2 id="两种形式">两种形式</h2><h3 id="属性代理">属性代理</h3><p>引入里我们写的最简单的形式，就是属性代理(Props Proxy)的形式。通过hoc包装wrappedComponent，也就是例子中的Usual，本来传给Usual的props，都在hoc中接受到了，也就是props proxy。 由此我们可以做一些操作</p><ul><li>操作props<br>最直观的就是接受到props，我们可以做任何读取，编辑，删除的很多自定义操作。包括hoc中定义的自定义事件，都可以通过props再传下去。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const propsProxyHoc = WrappedComponent =&gt; class extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;WrappedComponent</span><br><span class="line">      &#123;...this.props&#125;</span><br><span class="line">      handleClick=&#123;this.handleClick&#125;</span><br><span class="line">    /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default propsProxyHoc;</span><br></pre></td></tr></table></figure><p>然后我们的Usual组件render的时候, console.log(this.props) 会得到handleClick。</p><ul><li>refs获取组件实例<br>当我们包装Usual的时候，想获取到它的实例怎么办，可以通过引用(ref),在Usual组件挂载的时候，会执行ref的回调函数，在hoc中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const refHoc = WrappedComponent =&gt; class extends Component &#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(this.instanceComponent, &apos;instanceComponent&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;WrappedComponent</span><br><span class="line">      &#123;...this.props&#125;</span><br><span class="line">      ref=&#123;instanceComponent =&gt; this.instanceComponent = instanceComponent&#125;</span><br><span class="line">    /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default refHoc;</span><br></pre></td></tr></table></figure><ul><li>这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递   给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件<a href="https://reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener">文档</a>，即把input都做成受控的，改变value的时候，用onChange事件同步到state中。当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较。看一下代码就知道怎么回事了：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 普通组件Login</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import formCreate from &apos;./form-create&apos;;</span><br><span class="line"></span><br><span class="line">@formCreate</span><br><span class="line">export default class Login extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label id=&quot;username&quot;&gt;</span><br><span class="line">            账户</span><br><span class="line">          &lt;/label&gt;</span><br><span class="line">          &lt;input name=&quot;username&quot; &#123;...this.props.getField(&apos;username&apos;)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;label id=&quot;password&quot;&gt;</span><br><span class="line">            密码</span><br><span class="line">          &lt;/label&gt;</span><br><span class="line">          &lt;input name=&quot;password&quot; &#123;...this.props.getField(&apos;password&apos;)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div onClick=&#123;this.props.handleSubmit&#125;&gt;提交&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;other content&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//HOC</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const formCreate = WrappedComponent =&gt; class extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      fields: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onChange = key =&gt; e =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      fields: &#123;</span><br><span class="line">        ...this.state.fields,</span><br><span class="line">        [key]: e.target.value,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(this.state.fields);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getField = fieldName =&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      onChange: this.onChange(fieldName),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleSubmit: this.handleSubmit,</span><br><span class="line">      getField: this.getField,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (&lt;WrappedComponent</span><br><span class="line">      &#123;...props&#125;</span><br><span class="line">    /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default formCreate;</span><br></pre></td></tr></table></figure><p>这里我们把state，onChange等方法都放到HOC里，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。</p><h3 id="反向继承">反向继承</h3><p>反向继承(Inheritance Inversion)，简称II，本来我是叫继承反转的…因为有个模式叫控制反转嘛…<br>跟属性代理的方式不同的是，II采用通过 去继承WrappedComponent，本来是一种嵌套的关系，结果II返回的组件却继承了WrappedComponent，这看起来是一种反转的关系。<br>通过继承WrappedComponent，除了一些静态方法，包括生命周期，state，各种function，我们都可以得到。上栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// usual</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import iiHoc from &apos;./ii-hoc&apos;;</span><br><span class="line"></span><br><span class="line">@iiHoc</span><br><span class="line">export default class Usual extends Component &#123;</span><br><span class="line"></span><br><span class="line"> constructor() &#123;</span><br><span class="line">   super();</span><br><span class="line">   this.state = &#123;</span><br><span class="line">     usual: &apos;usual&apos;,</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">   console.log(&apos;didMount&apos;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> render() &#123;</span><br><span class="line">   return (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">       Usual</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//IIHOC</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const iiHoc = WrappedComponent =&gt; class extends WrappedComponent &#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">     console.log(this.state, &apos;state&apos;);</span><br><span class="line">     return super.render();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default iiHoc;</span><br></pre></td></tr></table></figure><p>iiHoc return的组件通过继承，拥有了Usual的生命周期及属性，所以didMount会打印，state也通过constructor执行，得到state.usual。<br>其实，你还可以通过II：</p><ul><li>渲染劫持<br>这里HOC里定义的组件继承了WrappedComponent的render(渲染)，我们可以以此进行hijack(劫持)，也就是控制它的render函数。栗子：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//hijack-hoc</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const hijackRenderHoc = config =&gt; WrappedComponent =&gt; class extends WrappedComponent &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; style = &#123;&#125; &#125; = config;</span><br><span class="line">    const elementsTree = super.render();</span><br><span class="line">    console.log(elementsTree, &apos;elementsTree&apos;);</span><br><span class="line">    if (config.type === &apos;add-style&apos;) &#123;</span><br><span class="line">      return &lt;div style=&#123;&#123;...style&#125;&#125;&gt;</span><br><span class="line">        &#123;elementsTree&#125;</span><br><span class="line">      &lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    return elementsTree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default hijackRenderHoc;</span><br><span class="line">//usual</span><br><span class="line">@hijackRenderHoc(&#123;type: &apos;add-style&apos;, style: &#123; color: &apos;red&apos;&#125;&#125;)</span><br><span class="line">class Usual extends Component &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里通过二阶函数，把config参数预制进HOC， 算是一种柯理化的思想。<br>栗子很简单，这个hoc就是添加样式的功能。但是它暴露出来的信息却不少。首先我们可以通过config参数进行逻辑判断，有条件的渲染，当然这个参数的作用很多，react-redux中的connect不就是传入了props-key 嘛。再就是我们还可以拿到WrappedComponent的元素树，可以进行修改操作。最后就是我们通过div包裹，设置了style。但其实具体如何操作还是根据业务逻辑去处理的…<br><img src="http://qiniu.xueshiming.cn/%E5%85%83%E7%B4%A0%E6%A0%91.png" alt="元素树"></p><h3 id="我的应用场景">我的应用场景</h3><ul><li><p>通常我会通过高阶组件去优化之前老项目写的不好的地方，比如两个页面UI几乎一样，功能几乎相同，仅仅几个操作不太一样，却写了两个耦合很多的页面级组件。当我去维护它的时候，由于它的耦合性过多，经常会添加一个功能(这两个组件都要添加)，我要去改完第一个的时候，还要改第二个。而且有时候由于我的记性不好，会忘掉第二个… 就会出现bug再返工。更重要的是由于个人比较懒，不想去重构这部分的代码，因为东西太多了，花费太多时间。所以加新功能的时候，我会写一个高阶组件，往HOC里添加方法，把那两个组件包装一下，也就是属性代理。这样新代码就不会再出现耦合，旧的逻辑并不会改变，说不定哪天心情好就会抽离一部分功能到HOC里，直到理想的状态。</p></li><li><p>另一种情况就是之前写过一个组件A，做完上线，之后产品加了一个新需求，很奇怪要做的组件B跟A几乎一模一样，但稍微有区别。那我可能就通过II的方式去继承之前的组件A，比如它在didMount去fetch请求，需要的数据是一样的。不同的地方我就会放到HOC里，存储新的state这样，再通过劫持渲染，把不同的地方，添加的地方进行处理。但其实这算Hack的一种方式，能快速解决问题，也反映了组件设计规划之初有所不足(原因比较多)。</p></li><li><p>Container解决不了的时候甚至不太优雅的时候。其实大部分时候包一层Container组件也能做到差不多的效果，比如操作props，渲染劫持。但其实还是有很大区别的。比如我们现在有两个功能的container，添加样式和添加处理函数的，对Usual进行包装。栗子：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//usual</span><br><span class="line">class Usual extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.props, &apos;props&apos;);</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      Usual</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">export default Usual;</span><br><span class="line">//console - Object &#123;handleClick: function&#125;  &quot;props&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Usual from &apos;./usual&apos;;</span><br><span class="line"></span><br><span class="line">class StyleContainer extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;div style=&#123;&#123; color: &apos;#76d0a3&apos; &#125;&#125;&gt;</span><br><span class="line">      &lt;div&gt;container&lt;/div&gt;</span><br><span class="line">      &lt;Usual &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default StyleContainer;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import StyleContainer from &apos;./container-add-style&apos;;</span><br><span class="line"></span><br><span class="line">class FuncContainer extends Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: this.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    return (&lt;StyleContainer &#123;...props&#125; /&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default FuncContainer;</span><br></pre></td></tr></table></figure><p>外层Container必须要引入内层Container，进行包装，还有props的传递，同样要注意包装的顺序。当然你可以把所有的处理都放到一个Container里。那用HOC怎么处理呢，相信大家有清晰的答案了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const addFunc = WrappedComponent =&gt; class extends Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;click&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const props = &#123;</span><br><span class="line">      ...this.props,</span><br><span class="line">      handleClick: this.handleClick,</span><br><span class="line">    &#125;;</span><br><span class="line">    return &lt;WrappedComponent &#123;...props&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const addStyle = WrappedComponent =&gt; class extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (&lt;div style=&#123;&#123; color: &apos;#76d0a3&apos; &#125;&#125;&gt;</span><br><span class="line">      &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line">class WrappedUsual extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(this.props, &apos;props&apos;);</span><br><span class="line">    return (&lt;div&gt;</span><br><span class="line">      &lt;WrappedComponent /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然HOC是更优雅一些的，每个HOC都定义自己独有的处理逻辑，需要的时候只需要去包装你的组件。相较于Container的方式，HOC耦合性更低，灵活性更高，可以自由组合，更适合应付复杂的业务。当然当你的需求很简单的时候，还是用Container去自由组合，应用场景需要你清楚。</p><h3 id="注意点-约束">注意点(约束)</h3><p>其实官网有很多，简单介绍一下。</p><ul><li><p>最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数</p></li><li><p>要给hoc添加class名，便于debugger。我上面的好多栗子组件都没写class 名，请不要学我，因为我实在想不出叫什么名了… 当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。<br><img src="http://qiniu.xueshiming.cn/WrappedUsual.png" alt="WrappedUsual"></p></li><li><p>静态方法要复制<br>无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。</p></li><li><p>refs不会传递。 意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。</p></li><li><p>不要在render方法内部使用高阶组件。简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。也就是如果你每次返回的结果都不是一个引用，react以为发生了变化，去更替这个组件会导致之前组件的状态丢失。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// HOC不要放到render函数里面</span><br><span class="line"></span><br><span class="line"> class WrappedUsual extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const WrappenComponent = addStyle(addFunc(Usual));</span><br><span class="line"></span><br><span class="line">    console.log(this.props, &apos;props&apos;);</span><br><span class="line">    return (&lt;div&gt;</span><br><span class="line">      &lt;WrappedComponent /&gt;</span><br><span class="line">    &lt;/div&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用compose组合HOC。函数式编程的套路… 例如应用redux中的middleware以增强功能。redux-middleware解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const addFuncHOC = ...</span><br><span class="line">const addStyleHOC = ...//省略</span><br><span class="line"></span><br><span class="line">const compose = (...funcs) =&gt; component =&gt; &#123;</span><br><span class="line">  if (funcs.lenght === 0) &#123;</span><br><span class="line">    return component;</span><br><span class="line">  &#125;</span><br><span class="line">  const last = funcs[funcs.length - 1];</span><br><span class="line">  return funcs.reduceRight((res, cur) =&gt; cur(res), last(component));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const WrappedComponent = compose(addFuncHOC, addStyleHOC)(Usual);</span><br></pre></td></tr></table></figure><p>关于注意点，官网有所介绍，不再赘述。链接：<a href="https://reactjs.org/docs/higher-order-components.html#dont-mutate-the-original-component.-use-composition." target="_blank" rel="noopener">reactjs.org</a></p><h3 id="总结">总结</h3><p>高阶组件最大的好处就是解耦和灵活性，在react的开发中还是很有用的。<br>当然这不可能是高阶组件的全部用法。掌握了它的一些技巧，还有一些限制，你可以结合你的应用场景，发散思维，尝试一些不同的用法。</p><p>原文转自：<a href="https://github.com/sunyongjian/blog/issues/25" target="_blank" rel="noopener">blog</a></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Say Hi</title>
      <link href="/2018/07/01/Say%20Hi/"/>
      <url>/2018/07/01/Say%20Hi/</url>
      <content type="html"><![CDATA[<img src="http://qiniu.xueshiming.cn/weget.jpg" width="600" hegiht="400" align="center">Say hi<!-- .emoji{  height: 1.2em;} --><a id="more"></a><p>2018年已经过去一半了<br></p><p>过去的六个月还是很幸运，很美好<br></p><p>和老兄继续并肩作战 <img class="emoji" draggable="false" alt="💯" src="https://twemoji.maxcdn.com/2/72x72/1f4af.png"><br></p><p>遇到了Ta <img class="emoji" draggable="false" alt="👹" src="https://twemoji.maxcdn.com/2/72x72/1f479.png"><br></p><p>工作，继续磨锤子<br></p><p>摄影，买一台单反<br></p><p>健身，首先的有肌肉<br></p><p>烧菜，从番茄炒蛋开始，已经算入门选手了，emm<br></p><p>        继续进阶<br></p><p>读书，读完10本书<br></p><p>旅行 <img class="emoji" draggable="false" alt="🌱" src="https://twemoji.maxcdn.com/2/72x72/1f331.png"> ，黄山-&gt;三亚-&gt;下一站在哪里</p>]]></content>
      
      <categories>
          
          <category> 展望 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>思忖</title>
      <link href="/2018/06/14/%E6%80%9D%E5%BF%96/"/>
      <url>/2018/06/14/%E6%80%9D%E5%BF%96/</url>
      <content type="html"><![CDATA[<img src="http://qiniu.xueshiming.cn/%E6%80%9D%E5%BF%96.jpg" width="600" hegiht="400" align="center"><p>思忖</p><a id="more"></a><p>这是在黄山等待日出的那一个瞬间<br><br>每个人都在期待着日出<br><br>每个人都想看到这一个美好的瞬间<br></p><!-- 在经历了漫长的寒夜<br/>终于等到日出的那一刻<br/>我的心暖了，所有人的心都暖了<br/>就像遇到一个人，之前的黑夜攒足了力气<br/>就是为了遇到一个像太阳一样的你<br/>就像，太阳期待人们<br/>等它出现在地平线上<br/>人们，也同样期待着太阳<br/>温暖我们的胸膛<br/>然后我们踏着光芒，走向前方 -->]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React和Redux数据流向</title>
      <link href="/2018/03/10/React%E5%92%8CRedux%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91/"/>
      <url>/2018/03/10/React%E5%92%8CRedux%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91/</url>
      <content type="html"><![CDATA[<blockquote><p>简单描述一下action 、reducer、store 三者的关系：</p></blockquote><a id="more"></a><p>使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。<br>store 就是把它们联系到一起的对象<br>用  this.props.dispath  (在页面.jsx文件中)去找一个action(在  Action.jsx  ) ，然后在这个<br>action中包含请求的请求方式:</p><ul><li>查询请求action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export const getSelectDdata = (data) =&gt; ActionCreator(API_INIT_POST_MODEL,</span><br><span class="line">&apos;/api/rcslmodelcascade/propertylist$&#123;queryData(data)&#125;&apos;,&apos;GET&apos;)()</span><br></pre></td></tr></table></figure><ul><li>修改请求action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const editPersional = (data) =&gt; ActionCreator(API_UPDATE_PERSONAL_LIMIT, &apos;/api/rcslmodelprivate&apos;, &apos;PUT&apos;, data)();</span><br></pre></td></tr></table></figure><ul><li>删除请求action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const detelePersionalLimit = (data) =&gt; ActionCreator(API_DELETE_PERSIONAL_MODEL, &apos;/api/rcslmodelprivate/$&#123;data&#125;&apos;, &apos;DELETE&apos;)();</span><br></pre></td></tr></table></figure><ul><li>添加请求action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const addPersionalLimit = (data) =&gt; ActionCreator(API_POST_PERSIONAL_MODEL, &apos;/api/rcslmodelprivate&apos;, &apos;POST&apos;, data)();</span><br></pre></td></tr></table></figure><p>这时，我们还需要添加一个action Type，来表示用户完成任务的动作。于是在<br><code>ActionType.jsx</code>中就有好多形如：<code>export const API_INIT_POST_MODEL = ['REQUEST', 'POST_MODEL_SUCCESS', 'FAILURE'];</code></p><p>然后到reducer  , reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。在reducer里，你可以<br>用switch定义数据的形式，用来和后台对接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">case API_INIT_POST_MODEL[1]:</span><br><span class="line">  return &#123;</span><br><span class="line">      ...state,</span><br><span class="line">      selectData:</span><br><span class="line">       ＿.map(actions.data, (v, k) =&gt; &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        value: v.value.map((v, k) =&gt; &#123;</span><br><span class="line">                            return &#123;</span><br><span class="line">                                labelName: v.name,</span><br><span class="line">                                optionVal: v.value.map(data =&gt; &#123;</span><br><span class="line">                                    return &#123;value: data.code, name: data.name&#125;</span><br><span class="line">                                &#125;),</span><br><span class="line">                                key: v.code,</span><br><span class="line">                                type: &apos;select&apos;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;),</span><br><span class="line">                        name: v.name,</span><br><span class="line">                        code: v.code,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;),</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>然后返回新的state给store,在store.jsx文件中，<br>根据已有的 reducer 来创建 store 是非常容易的。我们使用combineReducers() 将多个 reducer 合并成为一个。并通过中间件applyMiddleware 创建store。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const finalCreateStore=composeWithDevTools(applyMiddleware(promiseMiddleware))(createStore)</span><br></pre></td></tr></table></figure><p>Redux store 保存了根 reducer 返回的完整 state 树。然后返回给</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactDom.render(</span><br><span class="line"> &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Router history=&#123;history&#125; &gt;</span><br><span class="line">      &#123;routes&#125;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">）,document.getElementById(&apos;content&apos;)</span><br></pre></td></tr></table></figure><p>根节点，然后重新渲染数据</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>升级Webpack4.0.1</title>
      <link href="/2018/03/04/Webpack4.0%E5%8D%87%E7%BA%A7/"/>
      <url>/2018/03/04/Webpack4.0%E5%8D%87%E7%BA%A7/</url>
      <content type="html"><![CDATA[<h3 id="webpack-4介绍：">Webpack 4介绍：</h3><p>Webpack 4 正式版已发布，Webpack 是一个现代 JavaScript 应用程序的模块打包器 (module bundler) 。<br>当 Webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，<br>然后将所有这些模块打包成少量的 bundle - 通常只有一个，由浏览器加载。</p><h5 id="更新点包括：">更新点包括：</h5><ol><li>Environment</li></ol><ul><li>不再支持 Node.js 4</li></ul><ol start="2"><li>Usage</li></ol><ul><li>现在可以在两种模式中选择 (mode or --mode) : 生产模式或开发模式</li></ul><ol start="3"><li>Syntax</li></ol><ul><li>import() 总是返回一个命名空间对象。CommonJS 模块被封装到默认导出中</li></ul><a id="more"></a><ol start="4"><li>Configuration</li></ol><ul><li>NoEmitOnErrorsPlugin -&gt; optimization.noEmitOnErrors (生产模式下默认开启)</li><li>ModuleConcatenationPlugin -&gt; optimization.concatenateModules (开发模式下默认开启)</li><li>NamedModulesPlugin -&gt; optimization.namedModules (开发模式下默认开启)</li><li>CommonsChunkPlugin 已被移除 -&gt; optimization.splitChunks, optimization.runtimeChun</li></ul><ol start="5"><li>JSON</li></ol><ul><li>webpack 现在能原生地处理 JSON</li><li>允许通过 ESM 语法导入 JSON</li></ul><ol start="6"><li>Optimization</li></ol><ul><li>更新 uglifyjs-webpack-plugin 至 v1 版本，以支持 ES15</li></ul><p>注： 详细更新请看 <a href="https://juejin.im/post/5a951bf851882524d842ec8b" target="_blank" rel="noopener">webpack更新日志</a></p><h3 id="升级过程如下：">升级过程如下：</h3><ol><li>首先卸载原来的webpack版本，安装最新4.0.1版本</li></ol><ul><li>卸载命令<code>npm uninstall webpack -g</code></li><li>安装命令<code>npm install webpack@4.0.1 -g</code> 或者<code>yarn add webpack@4.0.1</code></li></ul><ol start="2"><li>添加optimization,这时会报错： Cannot find module ‘webpack/bin/config-yargs’</li></ol><ul><li>需要安装<code>webpack-dev-server</code></li><li>首先卸载<code>npm uninstall webpack-dev-server -g</code></li><li>然后再安装<code>yarn add webpack-dev-server@3.0.1-beta.0</code></li></ul><ol start="3"><li>启动项目 <code>yarn run dev</code></li></ol><ul><li>发现提示需要安装<code>webpack-cli</code> (用来启动webpack)</li><li>安装<code>yarn add webpack-cli -D</code></li></ul><ol start="4"><li>然后启动项目你会发现错误信息:<code>...please use config.optimization.splitChunks instead</code>和<br><img src="http://qiniu.xueshiming.cn/instead.png" alt="错误信息"></li></ol><p><code>compilation.mainTemplate.applyPluginsWaterfall is not a function</code></p><p>此时需要,在webpack.config中添加<code>optimization</code></p><p><img src="http://qiniu.xueshiming.cn/optimization.png" alt="optimization"></p><p>运行命令： <code>yarn add webpack-contrib/html-webpack-plugin -D</code></p><ol start="5"><li>然后启动项目会出现编译警告:<code>The mode option has not been set...</code>,<br><img src="http://qiniu.xueshiming.cn/mode.png" alt="错误信息"></li></ol><ul><li>需要在 <code>package.json</code> 里&quot;dev&quot;和&quot;build&quot;添加<br><code>--mode development</code><br><code>--mode production</code></li></ul><ol start="6"><li><code>yarn run dev</code> 启动项目</li></ol><h3 id="参考">参考:</h3><p><a href="https://doc.webpack-china.org/concepts/" target="_blank" rel="noopener">webpack中文文档</a></p><p><a href="https://doc.webpack-china.org/plugins" target="_blank" rel="noopener">以及插件列表</a></p><h3 id="升级效果：">升级效果：</h3><ul><li>升级前<br><img src="http://qiniu.xueshiming.cn/%E5%8D%87%E7%BA%A7%E5%89%8D.png" alt="升级前"></li><li>升级后<br><img src="http://qiniu.xueshiming.cn/%E5%8D%87%E7%BA%A7%E5%90%8E.png" alt="升级后"><br>风控限额项目由原来的webpack3.10.0升级到4.0.1,</li></ul><p>打包速度由原来的 41424ms 提升到 36396ms,减少了5秒</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>新建分支并提交到远程分支</title>
      <link href="/2018/02/28/%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/"/>
      <url>/2018/02/28/%E6%96%B0%E5%BB%BA%E5%88%86%E6%94%AF%E5%B9%B6%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</url>
      <content type="html"><![CDATA[<h5 id="新建分支并提交到远程分支">新建分支并提交到远程分支</h5><ol><li><code>git checkout -b phase</code> 新建分支phase 并切换到phase</li><li><code>git push origin phase:phase</code> 推送到远程分支</li><li><code>git branch</code> 查看本地分支</li><li><code>git branch -r</code> 查看远程分支<br>如果远程分支上有phase，说明提交成功，就可以在分支上开发了!</li></ol><a id="more"></a><hr><p>在master分支上：</p><ol><li><code>git fetch</code> 远程跟踪分支已更新(Git术语叫做commit)，需要将这些更新取回本地</li><li><code>git status</code> 查询一下状态</li><li>若提示落后于<code>origin/master</code></li><li><code>git merge origin/master</code> 将远端master分支的代码merge进本地分支</li><li><code>git status</code> 再次确认</li><li><code>git checkout -b test</code> 新建分支test 并且换到test</li></ol><p>其他git命令：</p><p><code>git reset –hard origin/master</code> 将本地的状态回退到和远程的一样</p><p><code>git rest</code> 在git的一般使用中，如果发现错误的将不想暂存的文件被git add进入索引之后，</p><p>想回退取消，则可以使用命令： <code>git reset HEAD &lt;file&gt;</code></p><p><code>git reset [--hard|soft|mixed|merge|keep] [&lt;commit&gt;或HEAD]</code>：</p><p>将当前的分支重设<code>(reset)</code>到指定的<code>&lt;commit&gt;</code>或者<code>HEAD</code>(默认，如果不显示指定<code>&lt;commit&gt;</code>，默认是<code>HEAD</code>，即最新的一次提交)，</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git（二）</title>
      <link href="/2017/12/26/Git%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/12/26/Git%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>最近在开发项目的过程中，我所在一个叫dev的分支开发，正开发到一半，头儿让我去master分支<br>修改一个bug，所以我必须先把正在改的代码暂存起来或者提交，才可以去切换分支开发。<br>在这个场景下：有三种方法去解决：</p><h5 id="及时commit代码">及时commit代码</h5><p>在dev分支上把已经开发完成的部分代码commit掉,不push，然后切换到master分支上修改代码,<br>做完了commit,所有分支互不影响，当然勤commit是一个好习惯。</p><a id="more"></a><h5 id="使用git-stash">使用git stash</h5><p>在dev分支上，我可以</p><blockquote><p>git stash或者 git stash save “修改的信息&quot;</p></blockquote><p>这样的话，你的代码就回到上一个commit了,直接git stash也行，git stash 栈会给你一个hash值作为版本的说明，但我觉得最好自己写说明比较明朗。然后你到master分支之后，完成了头二交给的任务，你就可以回到dev分支，然后输入：</p><blockquote><p>git stash pop或git stash list</p></blockquote><p>就可以回到刚才修改时候的版本了。这就相当于，压栈出栈的过程，将旧版本代码压栈，然后<br>切换分支开发，然后回到原先分支，出栈获得之前正在修改的代码。<br>而</p><blockquote><p>git stash apply stash@{0}</p></blockquote><p>的作用是可以指定栈中的一个版本，<br>通过</p><blockquote><p>git stash list 可以看到所有的版本信息:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: On master: Uncommitted changes before rebase</span><br><span class="line">stash@&#123;1&#125;: On master: Uncommitted changes before Checkout</span><br></pre></td></tr></table></figure><p>然后你可以选择一个你需要的版本执行：</p><blockquote><p>git stash apply stash@{0}</p></blockquote><p>然后你的代码就回来了。</p><h5 id="用ide工具的shelve的功能">用IDE工具的shelve的功能</h5><p>我用的webStorm有shelve功能，shelve的意思是“将…搁在一边”，即把还没写完的代码先搁在一边。</p><p>首先在IDE的底部找到<code>Version Control</code>，点开会有local的选项卡，选中你要搁置的代码，点击右键，选择“Shelve Changes”，在提交的输入框中输入你的注释，以便回来的时候识别你需要的版本，点击“Shelve Changes”键即可。这时选项卡上会多一个“Shelf”的选项卡，里面就有你搁置的代码。</p><p>这时候你可以去master分支修改代码，改完了之后回到dev分支，到“Shelf”选项卡下选择你要恢复的代码或者版本，点击右键选择“Unshelve Changes”，你的搁置的代码就回来了。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React组件间通信</title>
      <link href="/2017/12/10/React%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2017/12/10/React%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      <content type="html"><![CDATA[<blockquote><p>处理 React 组件之间的交流方式，主要取决于组件之间的关系，<br>下面我们根据不同情况，来讲讲React的组件通信。</p></blockquote>  <a id="more"></a><ul><li>【父组件】向【子组件】传值；</li><li>【子组件】向【父组件】传值；</li><li>没有任何嵌套关系的组件之间传值（PS：比如：兄弟组件之间的传值）</li></ul><h3 id="父子传值：">父子传值：</h3><hr><h4 id="父向子传">父向子传</h4><p><code>父组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange = e =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value: this.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是parent</span><br><span class="line">        &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Child value=&#123;this.state.value&#125; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; value &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是Child，得到传下来的值：&#123;value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件做的就是定义好 state ，定义好事件函数，在input onChange 的时候，去缓存 value 值，然后点击 button 的时候，改变 state , 子组件只负责展示 value 。</p><h4 id="子向父传">子向父传</h4><p>child 组件通知 parent 组件， 主要是依靠 parent 传下来的 callback 函数执行，改变 parent 组件的状态，或者把 child 自己的 state 通知 parent 。分两种情况：</p><ul><li>state 定义在 parent 组件<br><code>父组件：</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Parent extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = value =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是parent, Value是：&#123;this.state.value&#125;&lt;/div&gt;</span><br><span class="line">        &lt;Child setValue=&#123;this.setValue&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleChange = e =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    const &#123; setValue &#125; = this.props;</span><br><span class="line">    setValue(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是Child</span><br><span class="line">        &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">          state 定义在 parent</span><br><span class="line">          &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">          &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parent 组件把改变 state 的 setValue 函数传给 child ，child 组件自己处理内部的状态（这里是表单的value值），当 child 组件分发消息的时候， 执行 parent 的 setValue 函数，从而改变了 parent 的 state，state发生变化， parent 组件执行 re-render</p><ul><li>state 定义在 child 组件</li></ul><p><code>父组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line"></span><br><span class="line">  onChange = value =&gt; &#123;</span><br><span class="line">    console.log(value, &apos;来自 child 的 value 变化&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;我是parent</span><br><span class="line">        &lt;Child onChange=&#123;this.onChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Child extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      childValue: &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  childValChange = e =&gt; &#123;</span><br><span class="line">    this.childVal = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  childValDispatch = () =&gt; &#123;</span><br><span class="line">    const &#123; onChange &#125; = this.props;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      childValue: this.childVal,</span><br><span class="line">    &#125;, () =&gt; &#123; onChange(this.state.childValue) &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是Child</span><br><span class="line">        &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">          state 定义在 child</span><br><span class="line">          &lt;input onChange=&#123;this.childValChange&#125; /&gt;</span><br><span class="line">          &lt;div className=&quot;button&quot; onClick=&#123;this.childValDispatch&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候 state 是需要定义在 child 组件的，比如弹窗， CheckBox 这种开关性质的，逻辑是重复的，state 定义在组件内部更好维护， 复用性更好。但是 child 的 state 是需要告知我的 parent 组件的， 同样还是执行 parent 传下来的 change 函数。</p><h3 id="兄弟组件：">兄弟组件：</h3><hr><p>有时候可能出现页面中的某两部分通信，比如省市的级联选择，点击 button 改变颜色等等，组件并不是父子级，没有嵌套关系的时候。这种时候通常是依赖共有的顶级 Container 处理或者第三方的状态管理器。其实原理都是相通的，兄弟 A 的 value 发生变化，分发的时候把 value 值告诉一个中间者 C ，C 会自动告知 B，实现 B 的自动render 。</p><h4 id="利用共有的container">利用共有的Container</h4><p><code>container</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Container extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = value =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;A setValue=&#123;this.setValue&#125;/&gt;</span><br><span class="line">        &lt;B value=&#123;this.state.value&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>兄弟A：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class A extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    const &#123; setValue &#125; = this.props;</span><br><span class="line">    setValue(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">        我是Brother A, &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>兄弟B：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const B = props =&gt; (</span><br><span class="line">  &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">    我是Brother B, value是：</span><br><span class="line">    &#123;props.value&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line">export default B;</span><br></pre></td></tr></table></figure><p>组件 A 中的表单 value 值，告知了父级 Container 组件（通过 setValue 函数改变 state），组件 B 依赖于 Container 传下来的 state，会做出同步更新。这里的中间者是 Container。</p><h4 id="利用context">利用Context</h4><p>上面的方式，如果嵌套少还可以，如果嵌套特别多，比如一级导航栏下的二级导航栏下的某个按钮，要改变页面中 content 区域的 table 里的某个列的值…他们同属于一个 page 。这样传递 props 就会很痛苦，每一层组件都要传递一次。</p><p><code>顶级公共组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Context extends Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;&apos;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setValue = value =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123; // 必需</span><br><span class="line">    return &#123;</span><br><span class="line">      value: this.state.value,</span><br><span class="line">      setValue: this.setValue,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;AParent /&gt;</span><br><span class="line">        &lt;BParent /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必需</span><br><span class="line">Context.childContextTypes = &#123;</span><br><span class="line">  value: PropTypes.string,</span><br><span class="line">  setValue: PropTypes.func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>A 的 parent：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class AParent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">        &lt;A /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// A</span><br><span class="line">class A extends Component &#123;</span><br><span class="line"></span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    this.value = e.target.value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    const &#123; setValue &#125; = this.context;</span><br><span class="line">    setValue(this.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是parentA 下的 A, &lt;input onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;button&quot; onClick=&#123;this.handleClick&#125;&gt;通知&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 必需</span><br><span class="line">A.contextTypes = &#123;</span><br><span class="line">  setValue: PropTypes.func,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>B 的 parent：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class BParent extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;card&quot;&gt;</span><br><span class="line">        &lt;B /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// B</span><br><span class="line">class B extends Component &#123;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        我是parentB 下的 B, value是：</span><br><span class="line">        &#123;this.context.value&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B.contextTypes = &#123;</span><br><span class="line">  value: PropTypes.string,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>组件 A 仍是 消息的发送者，组件 B 是接收者， 中间者是 Context 公有 Container 组件。context是官方文档的一个 API ，通过 getChildContext 函数定义 context 中的值，并且还要求 childContextTypes 是必需的。这样属于这个 Container 组件的子组件，通过 <code>this.context</code> 就可以取到定义的值，并且起到跟 state 同样的效果。中间者其实还是 Container，只不过利用了上下文这样的 API ，省去了 props 的传递。另外：这个功能是实验性的，未来可能会有所改动。</p><p>Context 也存在自己的问题。如果你用过 context，你可能会发现一个问题，当 context 发生改变的时候，比如数据流向是从 Container(context 定义) -&gt; A -&gt; B -&gt; C(接收 context)，组件 A, B 也会发生 render，这样 C 组件才能拿到更新后的 context。万一你在 A, B 使用 shouldComponentUpdate: false 拦截了，或者某个组件是 PureComponent，context 发生变化，C 没有重新渲染，故拿不到最新的 context。</p><p>针对这种情况，我们要做的不是想方设法让 A，B render，而是通过其他手段，来实现 C 的重新渲染。通常是使用 context 做依赖注入，即 context 只注入一次，后续不会发生变化，这样各种无视组件层级透传属性。context 里面的数据进行改造，添加 subscribe 这样的函数，然后当某个数据变化的时候做 patch。子组件可能会加这样的代码：</p><p><code>子组件：</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.context.theme.subscribe(() =&gt; this.forceUpdate())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思想可以安全的使用 context，事实上 react-redux 也是这样做的。Provider 提供 context，connect 去做订阅。</p><h3 id="redux-mobx">Redux || Mobx</h3><p>Redux 或者 Mobx 是第三方的状态管理器，是这里我们通信的中间者。大型项目最直接的就是上库… 更方便，更不容易出错。 但其实小项目就没什么必要了。东西比较多，这里不再阐述它们的实现和做了什么。</p><h3 id="总结">总结</h3><p>react 特殊的自上而下的单向数据流，和 state 的特性，造就以这样的思想实现组件通信。除去发布订阅和 Redux 等，其他的都是 props 自上而下传递的理念，子组件需要的总是通过父组件传递下来的，关于 state 的定义，还是看具体的应用场景了。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git（三）</title>
      <link href="/2017/12/05/Git%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2017/12/05/Git%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h5 id="git小记">git小记</h5><pre><code> 最近遇到一个神奇的问题～ 平时推送到远程分支上用 git push 但发现了另一种方法，git push origin master 他们有什么区别呢？</code></pre><p>git push origin master 的意思就是，上传本地当前分支代码到master 分支，git push<br>是上传本地所有分支代码到远程对应分支上。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git（一）</title>
      <link href="/2017/12/01/Git%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/12/01/Git%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>提交如果遇到冲突的话，有两种解决方式，git merge和 git rebase。<br>首先来了解一下git pull：</p><p>将远程存储库中的更改合并到当前分支中。在默认模式下，git pull 是git fetch后跟git merge FETCH_HEAD的缩写。<br>更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。<br>也就是说git pull 分为两步，一步是git fetch，一步是git merge。</p><p>目前提交代码，先是git commit 到本地  然后 merge 或者 rebase。</p><a id="more"></a><h5 id="遇到冲突之git-base解决">遇到冲突之git base解决</h5><ol><li><p>首先查看所有分支：<br>git branch -r<br><img src="http://qiniu.xueshiming.cn/01.png" alt="查看所有分支"></p></li><li><p>检出一个分支：<br>git checkout -b root<br><img src="http://qiniu.xueshiming.cn/02.png" alt="检出分支"></p></li><li><p>当自己修改了本地分支之后<br>git push --set-upstream origin root<br>作用：推送当前分支并建立与远程上游的跟踪</p></li><li><p>试图去拉当前服务器上的分支,因为在要向服务器提交代码时，首先要拉服务器的代码<br>git pull<br>会有提示 ：（因为当时还没有commit到本地仓库）<br><img src="http://qiniu.xueshiming.cn/03.png" alt="提示"><br>提交到本地仓库：<br>git add .<br>git commit -m test<br><img src="http://qiniu.xueshiming.cn/04.png" alt="提交到本地仓库"></p></li><li><p>使用git pull --rebase</p></li></ol><p><img src="http://qiniu.xueshiming.cn/05.png" alt="rebase命令"></p><p><img src="http://qiniu.xueshiming.cn/06.png" alt="命令"></p><ol start="6"><li>使用git status 查看到哪一个文件有错误</li></ol><p><img src="http://qiniu.xueshiming.cn/07.png" alt="Routers.jsx报错"></p><ol start="7"><li>修改后(保留服务器的代码)：</li></ol><p><img src="http://qiniu.xueshiming.cn/08.png" alt="服务器代码"></p><p>其中&lt;&lt;&lt;&lt;HEAD 下 ====上是远程分支上的代码</p><p>====下  &gt;&gt;&gt;&gt;&gt;111 上是本地代码  （111是提交时候的注释）</p><h5 id="情况一：需要git-服务器上的代码">情况一：需要Git 服务器上的代码</h5><p><img src="http://qiniu.xueshiming.cn/09.png" alt="提交"></p><p>此处就不需要再git commit了，因为你所要提交的代码是和远程分支上一样的。</p><h5 id="情况二：保留本地代码">情况二：保留本地代码</h5><p>就需要git commit -m xxx</p><p>————&gt;我们这里演示的是保留远程分支上的代码：</p><p>所以执行 git rebase --continue  会出现以下情况：</p><p><img src="http://qiniu.xueshiming.cn/continue.png" alt="continue"></p><p>命令的作用是：  git会继续应用(apply)余下的补丁,因为已经git add .  过了<br>所以跳过此补丁</p><p>另外：在任何时候，都可以用git rebase --abort参数来终止rebase的行动，分支会回到rebase开始前的状态.</p><ol start="8"><li>最后根据提示来执行命令：<br><img src="http://qiniu.xueshiming.cn/11.png" alt="最后的命令"></li></ol><p>使用git需要养成的习惯～～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">经常commit，然后pull —reabase , 最后 push</span><br><span class="line"></span><br><span class="line">养成良好操作，尽量保持Master提交记录是一条线  利于code review</span><br></pre></td></tr></table></figure><p>git reabse 与git merge 区别<br>(<a href="https://www.cnblogs.com/kevingrace/p/5896706.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/5896706.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的React</title>
      <link href="/2017/11/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84React/"/>
      <url>/2017/11/22/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84React/</url>
      <content type="html"><![CDATA[<p>这几天正在学习React，有空记录一下！<br>比如：</p><h5 id="export和export-default">export和export default</h5><p>一般我们在定义了一个组件之后，为了复用，需要将它导出以提供给其他页面使用。<br>组件导出的关键字是:</p><blockquote><p>exprot default</p></blockquote><p>没有加default时，例如：</p><blockquote><p>export class Template{}</p></blockquote><p>当然，你可以在单个js文件里声明多个组件，例如Templates.js</p><blockquote><p>export class Template{}<br>export class AnotherTemplate{}</p></blockquote><p>这样在其他文件引用时，需要使用{}符号，且名称必须和class名称一样，like this：</p><blockquote><p>import {Template,AnotherTemplate} from ‘./components/Templates’;</p></blockquote><p>而加default时，例如：</p><a id="more"></a><blockquote><p>export default class Template{}</p></blockquote><p>然后在其他文件引用，像这样：</p><blockquote><p>import Template from ‘./components/Templates’;</p></blockquote><p>你也可以为这个组件另起一个别名，</p><blockquote><p>import TheTemplate from ‘./components/Templates’;</p></blockquote><p>但是每个文件里只能有一个default组件，可以包含其他非default组件：</p><blockquote><p>export default class Template{}<br>export class AnotherTemplate{}</p></blockquote><p>然后引用的时候，如下：</p><blockquote><p>import Template,{AnotherTemplate} from ‘./components/Templates’;</p></blockquote><p>总结：</p><ul><li>有default和没有default的区别在于：有default在引用时可以自定义名称，而没有default时需要使用{}括起来且名称必需和class名称一致</li><li>每个文件里只能有一个default组件，但可以有多个非default组件</li></ul><hr><h5 id="formitem">FormItem</h5><p>使用initValue 属性的时候，需要在提交“弹出框表单时”（CollectionCreateForm）</p><p>用form.resetFields() 方法重置表单数据，</p><p>如果缺少的话，点击修改某条数据是会回显上次表单修改后的值。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL中MAX函数与Group By一起使用的注意事项</title>
      <link href="/2017/10/27/MySQL%E4%B8%ADMAX%E5%87%BD%E6%95%B0%E4%B8%8EGroup%20By%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2017/10/27/MySQL%E4%B8%ADMAX%E5%87%BD%E6%95%B0%E4%B8%8EGroup%20By%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from  test;  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">| id | name  | age  | class |  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">|  1 | qiu   |   22 |     1 |   </span><br><span class="line">|  2 | liu   |   42 |     1 |   </span><br><span class="line">|  4 | zheng |   20 |     2 |   </span><br><span class="line">|  3 | qian  |   20 |     2 |   </span><br><span class="line">|  0 | wang  |   11 |     3 |   </span><br><span class="line">|  6 | li    |   33 |     3 |   </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果想找到每个Class里面的最大的Age，则需要使用roup by和max。<br>如下的Sql语句，则输出结果有错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select id,name,max(age),class from test group by class;  </span><br><span class="line">+----+-------+----------+-------+  </span><br><span class="line">| id | name  | max(age) | class |  </span><br><span class="line">+----+-------+----------+-------+  </span><br><span class="line">|  1 | qiu   |       42 |     1 |   </span><br><span class="line">|  4 | zheng |       20 |     2 |   </span><br><span class="line">|  0 | wang  |       33 |     3 |   </span><br><span class="line">+----+-------+----------+-------+  </span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>虽然找到的age是最大的age，但是与之匹配的用户信息却不是真实的信息，而是group by分组后的第一条记录的基本信息。<br>如果我使用以下的语句进行查找，则可以返回真实的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from (  </span><br><span class="line">    -&gt; select * from test order by age desc) as b  </span><br><span class="line">    -&gt; group by class;  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">| id | name  | age  | class |  </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">|  2 | liu   |   42 |     1 |   </span><br><span class="line">|  4 | zheng |   20 |     2 |   </span><br><span class="line">|  6 | li    |   33 |     3 |   </span><br><span class="line">+----+-------+------+-------+  </span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test t where t.age = (select max(age) from test where t.class = class) order by class;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Sleep和Wait的区别</title>
      <link href="/2017/10/19/Sleep%E5%92%8CWait%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/10/19/Sleep%E5%92%8CWait%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<ol><li>Java中sleep和wait的区别<br>① 这两个方法来自不同的类分别是，sleep来自Thread类，和wait来自Object类。<br>sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。</li></ol><a id="more"></a><p>② 锁: 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。<br>sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。<br>Thread.sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。<br>③ 使用范围：wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。</p><p>synchronized(x){<br>x.notify()<br>//或者wait()<br>}</p><p>java常见面试题(<a href="https://blog.csdn.net/shineflowers/article/details/40047479" target="_blank" rel="noopener">https://blog.csdn.net/shineflowers/article/details/40047479</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql获取当前日期并格式化</title>
      <link href="/2017/10/18/Mysql%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>/2017/10/18/Mysql%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%A5%E6%9C%9F%E5%B9%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>MYSQL 获取当前日期及日期格式话</p><a id="more"></a><p>获取系统日期： NOW()<br>格式化日期： DATE_FORMAT(date, format)<br>注： date：时间字段<br>format：日期格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回系统日期,输出 2009-12-25 14:38:59</span><br><span class="line">select now();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出 09-12-25</span><br><span class="line">select date_format(now(),&apos;%y-%m-%d&apos;);</span><br></pre></td></tr></table></figure><p>根据format字符串格式化date值:</p><ul><li>%U 周（0, 1, 52），其中Sunday 为周中的第一天</li><li>%u 周（0, 1, 52），其中Monday 为周中的第一天</li><li>%M 月名（January, February, …, December）</li><li>%b 缩写的月名（ January, February,…, December）</li><li>%m 两位数字表示的月份（01, 02, …, 12）</li><li>%c 数字表示的月份（1, 2, …, 12）</li><li>%Y 四位数字表示的年份</li><li>%y 两位数字表示的年份</li><li>%% 直接值“%”</li><li>%S, %s 两位数字形式的秒（ 00,01, …, 59）</li><li>%I, %i 两位数字形式的分（ 00,01, …, 59）</li><li>%H 两位数字形式的小时，24 小时（00,01, …, 23）</li><li>%h 两位数字形式的小时，12 小时（01,02, …, 12）</li><li>%k 数字形式的小时，24 小时（0,1, …, 23）</li><li>%l 数字形式的小时，12 小时（1, 2, …, 12）</li><li>%T 24 小时的时间形式（hh:mm:ss）</li><li>%r 12 小时的时间形式（hh:mm:ss AM 或hh:mm:ss PM）</li><li>%p AM或PM</li><li>%W 一周中每一天的名称（Sunday, Monday, …, Saturday）</li><li>%a 一周中每一天名称的缩写（Sun, Mon, …, Sat）</li><li>%d 两位数字表示月中的天数（00, 01,…, 31）</li><li>%e 数字形式表示月中的天数（1, 2， …, 31）</li><li>%D 英文后缀表示月中的天数（1st, 2nd, 3rd,…）</li><li>%w 以数字形式表示周中的天数（ 0 = Sunday, 1=Monday, …, 6=Saturday）</li><li>%j 以三位数字表示年中的天数（ 001, 002, …, 366）</li></ul><p>还有一些实现日期的函数，或者是返回月份中的最后一天 等<br>eg:MySQL last_day() 函数：返回月份中的最后一天。</p><p>详见：(<a href="https://blog.csdn.net/kangbrother/article/details/7030304" target="_blank" rel="noopener">https://blog.csdn.net/kangbrother/article/details/7030304</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql Decimal数据类型</title>
      <link href="/2017/10/17/Mysql%20Decimal%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2017/10/17/Mysql%20Decimal%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>最近忙着复习，更新的速度有些慢。在一次面试中，面试官问我，mysql里金额用什么存，我只用过普通的double，float，但回来一查，金额应该用Decimal 来存。受教了~</p><p>mysql里Decimal表示 128 位数据类型。double相比，decimal 类型具有更高的精度和更小的范围，它适合于财务和货币计</p><a id="more"></a><p>测试表，seller_cost字段定义为decimal(14,2)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_decimal` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `seller_cost` decimal(14,2) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><p>起初，表中内容为空:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><p>插入整数部分长度为14的数字，报超出列范围的错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,12345678901234);</span><br><span class="line">ERROR 1264 (22003): Out of range value for column &apos;seller_cost&apos; at row 1</span><br></pre></td></tr></table></figure><p>插入整数部分长度为12的数字，可以正确插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,123456789012);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><p>查询表，发现插入的整数值末尾被MySQL补了两位小数“.00”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>继续插入整数部分12位，小数部分5位的数字，可以成功插入，但是有警告，警告表明小数部分发生了截断，被截取成了两位小数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,123456789012.12345);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Level | Code | Message                                          |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Note  | 1265 | Data truncated for column &apos;seller_cost&apos; at row 1 |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">|  1 | 123456789012.12 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>缩小整数部分的长度为2，小数部分的长度继续保持为5，可以成功插入，但小数部分被截断为两位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql&gt; insert into test_decimal(id,seller_cost) values(1,12.12345);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show warnings;</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Level | Code | Message                                          |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">| Note  | 1265 | Data truncated for column &apos;seller_cost&apos; at row 1 |</span><br><span class="line">+-------+------+--------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">|  1 | 123456789012.12 |</span><br><span class="line">|  1 |           12.12 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>继续插入一个小数部分不足两位的数字，可正确插入，且小数部分被自动补全到两位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into test_decimal(id,seller_cost) values(1,12.1);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test_decimal;</span><br><span class="line">+----+-----------------+</span><br><span class="line">| id | seller_cost     |</span><br><span class="line">+----+-----------------+</span><br><span class="line">|  1 | 123456789012.00 |</span><br><span class="line">|  1 | 123456789012.12 |</span><br><span class="line">|  1 |           12.12 |</span><br><span class="line">|  1 |           12.10 |</span><br><span class="line">+----+-----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>综上所述，DECIMAL(N,M)中M值的是小数部分的位数，若插入的值未指定小数部分或者小数部分不足M位则会自动补到M位小数，若插入的值小数部分超过了M为则会发生截断，截取前M位小数。N值得是整数部分加小数部分的总长度，也即插入的数字整数部分不能超过N-M位，否则不能成功插入，会报超出范围的错误。</p><p>详解mysql int类型的长度值问题（<a href="https://www.cnblogs.com/echo-something/archive/2012/08/26/mysql_int.html" target="_blank" rel="noopener">https://www.cnblogs.com/echo-something/archive/2012/08/26/mysql_int.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>String s1 = new String(&quot;abc&quot;)和String s2 = &quot;abc&quot;的区别</title>
      <link href="/2017/10/15/String%E7%9B%B8%E5%85%B3/"/>
      <url>/2017/10/15/String%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h5 id="今天在看jvm的时候突然想到这样一个问题-即">今天在看JVM的时候突然想到这样一个问题，即</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = new String(&quot;abc&quot;);</span><br><span class="line">String s2 = &quot;abc&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);//答案是false</span><br></pre></td></tr></table></figure><p>问题有两个：</p><p>String s2 = “abc”时发生了什么？<br>String s1 = new String(“abc”）时又做了什么？<br>第二个问题是比较好回答的，根据官方文档的解释：</p><a id="more"></a><p>当我们在jdk1.6中讨论时，常量池放在方法区中。（jdk1.7中常量池放在堆内存中，jdk1.8放在元空间里面，和堆相对独立，所以导致string的intern方法因为以上变化在不同版本会有不同表现。）</p><blockquote><p>new String(“abc”);<br>Initializes a newly created String object so that it represents the same sequence of characters as the argument; in other words, the newly created string is a copy of the argument string. Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.</p></blockquote><p>简单解释一下：</p><blockquote><p>初始化一个新创建的String对象，换句话说，新创建的字符串是参数字符串的一个副本。除非确实需要一份副本，否则这种方法是不必要的，因为String是不可变的</p></blockquote><p>这句话实际上透露出两个意思，</p><p>在编译器编译的时候，当编译器注意到参数为字符串常量时，即将字符串作为常量放在class文件中的常量区，并在类加载时放入运行时常量池中。<br>在new操作符被调用时，在java堆中创建一个新的对象，然后对象的内容为常量池里面对应字符串的一个拷贝。<br>而在String s2 = “abc”被编译的时候，先检查class文件中是否包含该字符串常量，如果包含，直接返回常量池中的对象。</p><p>因此，在调用new操作时，对象始终存在于堆中，而直接字符串赋值时对象实际上是存在于常量池中的，<br>所以比较结果肯定是false</p><p>String s = new String(“hello”);</p><h5 id="generally-speaking">Generally speaking,</h5><ul><li>jdk1.6中: 首先&quot;hello&quot;字符串对象保存在 方法区的字符串常量池中， 在虚拟机栈中开辟空间 用来存放String 类型的变量s，在堆中开辟空间<br>存放 s 引用的对象，然后将常量池中的“hello” 拷贝一个副本给堆中的String。</li><li>jdk1.7中:首先&quot;hello&quot;字符串对象保存在堆内存的字符串常量池中<ul><li>1】在栈中开辟空间存放 s</li><li>2】在堆中开辟空间存放新建的String 对象&quot;hello&quot;</li><li>3】引用s指向堆中新建的String对象“hello”。</li></ul></li></ul><p>参考文章1、（<a href="https://blog.csdn.net/weixin_35663229/article/details/52796157?locationNum=15%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/weixin_35663229/article/details/52796157?locationNum=15）</a><br>参考文章2、（<a href="https://blog.csdn.net/u010644448/article/details/51980370%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/u010644448/article/details/51980370）</a></p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql decimal类型与decimal长度用法详解</title>
      <link href="/2017/10/15/Mysql%20decimal%E7%B1%BB%E5%9E%8B%E4%B8%8Edecimal%E9%95%BF%E5%BA%A6%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/10/15/Mysql%20decimal%E7%B1%BB%E5%9E%8B%E4%B8%8Edecimal%E9%95%BF%E5%BA%A6%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h5 id="float-double-decimal三者的区别介绍">float,double,decimal三者的区别介绍</h5><a id="more"></a><p>float:浮点型，含字节数为4，32bit，数值范围为-3.4E38~3.4E38（7个有效位）<br>double:双精度实型，含字节数为8，64bit数值范围-1.7E308~1.7E308（15个有效位）<br>decimal:数字型，128bit，不存在精度损失，常用于银行帐目计算。（28个有效位）</p><h5 id="按存储的范围进行排序">按存储的范围进行排序</h5><p>float（real）<br>double<br>decimal（numeric）</p><h5 id="decimal的详细介绍">decimal的详细介绍</h5><p>decimal(a,b)</p><h5 id="参数说明">参数说明</h5><p>a指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。<br>b指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从 0 到 a之间的值。默认小数位数是 0。</p><h5 id="备注">备注</h5><p>DECIMAL数据类型用于要求非常高的精确度的计算中，这些类型允许指定数值的精确度和计数方法作为选择参数。精确度在这里是指为这个值保存的有效数字的总个数，而计数方法表示小数点后数字的个数。例如，语句DECIMAL (5,2)规定了存储的值将不会超过5位数字，开且小数点后面有2位数字。</p><h5 id="实例">实例</h5><blockquote><p>float f = 345.98756f;–结果显示为345.9876，只显示7个有效位，对最后一位数四舍五入。<br>double d=345.975423578631442d;–结果显示为345.975423578631，只显示15个有效位，对最后一位四舍五入。<br>–注：float和double的相乘操作，数字溢出不会报错，会有精度的损失。<br>decimal dd=345.545454879…–可以支持28位，对最后一位四舍五入。<br>–：当对decimal类型进行操作时，数值会因溢出而报错。</p></blockquote><h5 id="总结">总结</h5><p>数值存储范围越小的精度越高，存储数值范围越大，精度就越不准确，如果存储正常金额的情况下，使用money，好处在于可以存储不指定的小数点位数的数值，比较真实。如果对于既要求精度，又固定小数点位数的数值存储，采用decimal（numeric），优点在于可以自定义小数点位数，精度高。如特殊情况，如数值范围巨大只能用float（real）类型了，此类型一般不提倡使用</p><p>链接(<a href="https://blog.csdn.net/zhanghao143lina/article/details/53816884" target="_blank" rel="noopener">https://blog.csdn.net/zhanghao143lina/article/details/53816884</a>)<br>mysql数据类型(<a href="https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html" target="_blank" rel="noopener">https://www.cnblogs.com/zbseoag/archive/2013/03/19/2970004.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>盒子模型</title>
      <link href="/2017/09/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2017/09/02/%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>今天来聊聊box-sizing</p><p>盒模型：<br>当你设置了元素的宽度，实际展现的元素超出你的设置：<br>这是因为元素的边框和内边距会撑开元素。看下面的例子，<br>两个相同宽度的元素显示的实际宽度却不一样。</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8001.png" alt="代码"></p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8002.png" alt="我小一些"></p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8003.png" alt="我大一些"></p><p>以前有一个代代相传的解决方案是通过数学计算。CSS开发者需要用比他们实际想要的宽度小一点的宽度，需要减去内边距和边框的宽度。<br>值得庆幸是你不需要再这么做了…</p><p>Box-sizing:</p><p>人们慢慢地意识到传统的盒子模型不直接，所以他们新增了一个叫做box-sizing</p><p>的css属性。当你设置一个元素为box-sizings: border-box;时此元素的内边距和边框不会再增加它的宽度。<br>这里有一个与前一页相同的例子，唯一的区别是两个元素都设置了box-sizing：border-box;</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8004.png" alt="boxSize代码"></p><p>效果：</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8005.png" alt="效果"><br>既然没有比这更好的方法，一些CSS开发者想要页面上的元素都有如此的表现。所以开发者们，都把以下代码放在他们的页面上：</p><p><img src="http://qiniu.xueshiming.cn/%E5%AD%A6%E4%B9%A0CSS%E5%B8%83%E5%B1%8006.png" alt="直观的方式"></p><p>这样可以确保所有的元素都会用这种更直观的方式排版。</p><p>不过box-sizing是个很新的属性，目前你还应该像上面例子中那样使用 -webkit-<br>和-moz- 前缀。  这可以这个启用特定浏览器实验中的特性。同时记住它是支持IE8+的</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>听罗胖聊天</title>
      <link href="/2017/09/02/%E5%90%AC%E7%BD%97%E8%83%96%E8%81%8A%E5%A4%A9/"/>
      <url>/2017/09/02/%E5%90%AC%E7%BD%97%E8%83%96%E8%81%8A%E5%A4%A9/</url>
      <content type="html"><![CDATA[<p>最近才了解到《逻辑思维》这个节目，其实这个节目在某酷上已经播出了好长一段时间了，</p><p>今天有闲心去看了两集《逻辑思维》，两级节目都令自己感触比较深。</p><ol><li>《拒绝逃离北上广》：他的这个观点，其实和自己一直心中有个认知是一样的：<br>见识很重要，在北上广，虽然房价贵，空气不好但是真的是“机会非常多”。<br>“机会”的定义，会随着你慢慢接触的事物变多之后，慢慢的丰富。所以，我想要以后生活在这里！</li><li>《知识焦虑》，今天说来也巧，在《意林》上，和节目中都看到了这个话题，对“知识爆炸”的更进一步了解了。<br>还有就是学习效率的问题，另类二八原则！<br>而且，正准备在地铁上去听书，在节目中就了解了碎片化学习，很巧。</li><li>二八法则频频出现在外来的信息中。</li></ol>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JS(一)</title>
      <link href="/2017/09/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS(%E4%B8%80)/"/>
      <url>/2017/09/02/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS(%E4%B8%80)/</url>
      <content type="html"><![CDATA[<pre><code>javaScript数组的遍历，在项目中遇到的是这个问题：直接上图：</code></pre><h3 id="主要针对数组的遍历有一下方法：">主要针对数组的遍历有一下方法：</h3><p>传统方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>for in方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for each 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.forEach(callback)</span><br><span class="line">forEach()方法是ES2.1标准引入的。</span><br><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">arr.forEach(function(v,i)&#123;//v==value　为arr项，i==index　为arr索引</span><br><span class="line">    console.log(i+&apos;  &apos;v );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在最新的ES6中新增了一个方法<br>for of方法</p><p>遍历Array可以采用下标循环，遍历map和Set就无法使用下标，无法使用索引进行遍历<br>，为了统一集合类型，ES6标准引入了新的iterable类型，<br>Array、Map和Set都属于iterable类型。<br>具有iterable类型的集合可以通过新的for…of循环遍历。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">for(var value of Arr)&#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for … of循环和for … in循环有何区别<br>for … in循环，它遍历的实际上是对象的属性名称。</p><p>一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。</p><p>当我们手动给Array对象添加了额外的属性后，for … in循环将带来意想不到的意外效果：</p><p>for in 遍历数组时会为把数组索引作为键值　如：数组0、1、2、3、4、5、…的键；当我们这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">arr.value=&apos;val&apos;;</span><br><span class="line">//在使用for in 遍历时</span><br><span class="line">for(var i in arr)&#123;</span><br><span class="line">    console.log(i+&apos;   &apos;+arr[i]);//这时的i为键值，不为数组索引</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">0   1</span><br><span class="line">1   2</span><br><span class="line">2   3</span><br><span class="line">3   4</span><br><span class="line">4   5</span><br><span class="line">5   6</span><br><span class="line">value   val</span><br><span class="line">接着执行，这时出现问题：</span><br><span class="line"></span><br><span class="line">arr;//输出[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">//使用 console.log(arr)时，这样</span><br><span class="line">console.log(arr);//输出[1, 2, 3, 4, 5, 6, value: &quot;val&quot;]</span><br><span class="line"></span><br><span class="line">//alert(arr)时</span><br><span class="line">alert(arr);//输出[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure><p>而当我们使用for of 时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5,6];</span><br><span class="line">arr.value=&apos;val&apos;;</span><br><span class="line">//在使用for in 遍历时</span><br><span class="line">for(var v of arr)&#123;</span><br><span class="line">    console.log(v);//v为数组的项</span><br><span class="line">&#125;</span><br><span class="line">//输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>直接遍历出值</p><p>Map 遍历：</p><p>map:和forEach非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项；</p><p>区别：map的回调函数中支持return返回值；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var ary = [12,23,24,42,1];</span><br><span class="line">var res = ary.map(function (item,index,input) &#123;</span><br><span class="line">     return item*10;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res);//--&gt;[120,230,240,420,10];</span><br><span class="line">console.log(ary);//--&gt;[12,23,24,42,1]；</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>不用四则做加法</title>
      <link href="/2017/08/25/%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E5%81%9A%E5%8A%A0%E6%B3%95/"/>
      <url>/2017/08/25/%E4%B8%8D%E7%94%A8%E5%9B%9B%E5%88%99%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
      <content type="html"><![CDATA[<h5 id="不用四则做加法">不用四则做加法</h5><p>直接上代码：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Add &#123;</span><br><span class="line">public static int Add(int num1, int num2) &#123;</span><br><span class="line">while (num2 != 0) &#123;</span><br><span class="line">int temp = num1 ^ num2;</span><br><span class="line">System.out.println(&quot;temp=&quot; + temp);</span><br><span class="line">System.out.println(&quot;num1&amp;num2=&quot; + (num1 &amp; num2));</span><br><span class="line">num2 = (num1 &amp; num2) &lt;&lt; 1;</span><br><span class="line">System.out.println(&quot;(num1 &amp; num2) &lt;&lt; 1 =&quot; + num2);</span><br><span class="line">num1 = temp;</span><br><span class="line">            System.out.print(num1);</span><br><span class="line">&#125;</span><br><span class="line">return num1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Add(3, 6);</span><br><span class="line">//2  :0010</span><br><span class="line">//3  :0011</span><br><span class="line">//2^3=0001  =1    异或运算符，用符号(^)表示，其运算规则是：两个操作数的位中，相同则结果为0，不同则结果为1。</span><br><span class="line">   //2&amp;3=0010  =2    位与运算符，都为1则为1，否则为0。</span><br><span class="line">//2&lt;&lt;2=4                      右移运算符，num &lt;&lt; 1,相当于num乘以2</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="思路解读：">思路解读：</h5><blockquote><p>解析：<br>首先看十进制是如何做的： 5+7=12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。<br>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</p></blockquote><blockquote><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111<br>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。<br>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。<br>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</p></blockquote><h5 id="延伸：">延伸：</h5><ol><li>位异或运算（^）</li></ol><p>运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。<br>比如：8^11.</p><p>8转为二进制是1000，11转为二进制是1011.从高位开始比较得到的是：0011.然后二进制转为十进制，就是Integer.parseInt(“0011”,2)=3;</p><ol start="2"><li>位与运算符（&amp;）</li></ol><p>运算规则：两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。<br>比如：129&amp;128.</p><p>129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000000，即128.</p><ol start="3"><li>位或运算符（|）</li></ol><p>运算规则：两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。</p><p>比如：129|128.</p><p>129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000001，即129.</p><ol start="4"><li>位非运算符（~）</li></ol><p>运算规则：如果位为0，结果是1，如果位为1，结果是0.</p><p>比如：~37</p><p>在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.</p><p>8转为二进制是100101.</p><p>补码后为： 00000000 00000000 00000000 00100101</p><p>取反为：    11111111 11111111 11111111 11011010</p><p>因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。</p><p>因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：</p><p>00000000 00000000 00000000 00100110，此时二进制转原码为38</p><h2 id="所以-37-38">所以~37 = -38.</h2><p>关于java 原码、反码、补码的解释<br>(<a href="https://blog.csdn.net/u010841296/article/details/52850307" target="_blank" rel="noopener">https://blog.csdn.net/u010841296/article/details/52850307</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java中单链表的实现</title>
      <link href="/2017/08/23/Java%E4%B8%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/08/23/Java%E4%B8%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>Java中我们使用的ArrayList，其实现原理是数组。而LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。下面对单向链表做一个介绍。</p><a id="more"></a><p>单向链表是一种线性表，实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。其数据在内存中存储是不连续的，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</p><h5 id="下面是具体的实现">下面是具体的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package mylink;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *</span><br><span class="line"> * Java中链表的创建及相关操作</span><br><span class="line"> *</span><br><span class="line"> * @author fisherman</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class MyLink &#123;</span><br><span class="line">Node head = null;</span><br><span class="line"></span><br><span class="line">   class Node &#123;</span><br><span class="line">private int data;// 定义数据域</span><br><span class="line">private Node next; // 定义指针域</span><br><span class="line"></span><br><span class="line">public Node(int data) &#123;</span><br><span class="line">this.data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> /*  </span><br><span class="line">   class NodeOther&#123;</span><br><span class="line">   private int data;// 定义数据域</span><br><span class="line">private Node next; // 定义指针域</span><br><span class="line">   public NodeOther()&#123;</span><br><span class="line">   this.data= data;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;*/</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 插入数据</span><br><span class="line"> *</span><br><span class="line"> * @param</span><br><span class="line"> */</span><br><span class="line">public void addNode(int data) &#123;</span><br><span class="line">Node node = new Node(data);</span><br><span class="line">if (head == null) &#123;</span><br><span class="line">head = node;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Node tmp = head;</span><br><span class="line">while (tmp.next != null) &#123; // 若下一个节点不为空，指针后移</span><br><span class="line">tmp = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmp.next = node; // 然后把新的节点添加</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计算链表的长度</span><br><span class="line"> *</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int size() &#123;</span><br><span class="line">int size = 0;</span><br><span class="line">Node tmp = head;</span><br><span class="line">while (tmp != null) &#123; // 若头结点不为空</span><br><span class="line">size++; // 长度加一</span><br><span class="line">tmp = tmp.next;// 指针后移一位，指向下一个节点，然后再进行循环，长度再加一</span><br><span class="line">&#125;</span><br><span class="line">return size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 删除序号为index的节点</span><br><span class="line"> *</span><br><span class="line"> * @param index</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean deleteNode(int index) &#123;</span><br><span class="line">if (index &lt; 1 || index &gt; size())</span><br><span class="line">return false; // 若所找节点的序号不存在 ，返回false</span><br><span class="line">if (index == 1) &#123;</span><br><span class="line">head = head.next;</span><br><span class="line">return true; // 若序号为1，说明找的是头结点</span><br><span class="line">&#125;</span><br><span class="line">int i = 2; // 从第二个节点开始</span><br><span class="line">Node preNode = head; // 初始为head 作为前驱节点</span><br><span class="line">Node currNode = preNode.next; // 现在的节点为head的下一个节点</span><br><span class="line">while (currNode != null) &#123;</span><br><span class="line"></span><br><span class="line">if (i == index) &#123;</span><br><span class="line">preNode.next = currNode.next; // 删除 currNode（当前节点）节点</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">preNode = currNode; // preNode节点变为下一个节点</span><br><span class="line">currNode = currNode.next; // currNode节点变为下一个节点</span><br><span class="line">i++; // 继续向后查找</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 在不知道头指针的情况下删除指定节点</span><br><span class="line"> * @param node</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public boolean deleteNodeOther(Node node) &#123;</span><br><span class="line">if (node == null || node.next == null)</span><br><span class="line">return false;</span><br><span class="line">int temp = node.data;</span><br><span class="line">node.data = node.next.data;// 把待删除节点下一节点的数据覆盖待删除节点数据</span><br><span class="line">node.next.data = temp;// 保存了已删除节点的数据</span><br><span class="line">node.next = node.next.next;</span><br><span class="line">return true;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 打印链表</span><br><span class="line"> *</span><br><span class="line"> * @param</span><br><span class="line"> */</span><br><span class="line">public void printList() &#123;</span><br><span class="line">Node tmp = head;</span><br><span class="line">while (tmp != null) &#123;</span><br><span class="line">System.out.println(tmp.data);</span><br><span class="line">tmp = tmp.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">MyLink link = new MyLink();</span><br><span class="line">link.addNode(2);</span><br><span class="line">link.addNode(3);</span><br><span class="line">link.addNode(4);</span><br><span class="line">        link.addNode(5);</span><br><span class="line">System.out.println(&quot;长度为：&quot; + link.size());</span><br><span class="line">link.printList();</span><br><span class="line">System.out.println(&quot;删除第二个元素：&quot; + link.deleteNode(2));</span><br><span class="line">System.out.println(&quot;删除后长度为：&quot; + link.size());</span><br><span class="line">link.printList();</span><br><span class="line">/*  MyLink.NodeOther node=new MyLink().new NodeOther();</span><br><span class="line">System.err.println(&quot;删除第三个节点：&quot;+link.deleteNodeOther(node)); */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>袋鼠过河</title>
      <link href="/2017/08/23/newCoder%E8%A2%8B%E9%BC%A0%E8%BF%87%E6%B2%B3/"/>
      <url>/2017/08/23/newCoder%E8%A2%8B%E9%BC%A0%E8%BF%87%E6%B2%B3/</url>
      <content type="html"><![CDATA[<p>最近忙着复习，博客就更新频率少低了，现在就先把觉得重要的算法题记录一下，在牛客网上做到的最简单的动态规划问题，当然这道题的变形在leetCode上也有（jumpGame）。</p><a id="more"></a><h5 id="题目描述">题目描述</h5><blockquote><p>一只袋鼠要从河这边跳到河对岸，河很宽，但是河中间打了很多桩子，每隔一米就有一个，每个桩子上都有一个弹簧，袋鼠跳到弹簧上就可以跳的更远。每个弹簧力量不同，用一个数字代表它的力量，如果弹簧力量为5，就代表袋鼠下一跳最多能够跳5米，如果为0，就会陷进去无法继续跳跃。河流一共N米宽，袋鼠初始位置就在第一个弹簧上面，要跳到最后一个弹簧之后就算过河了，给定每个弹簧的力量，求袋鼠最少需要多少跳能够到达对岸。如果无法到达输出-1</p></blockquote><h5 id="输入描述">输入描述:</h5><blockquote><p>输入分两行，第一行是数组长度N (1 ≤ N ≤ 10000)，第二行是每一项的值，用空格分隔。</p></blockquote><h5 id="输出描述">输出描述:</h5><blockquote><p>输出最少的跳数，无法到达输出-1</p></blockquote><h5 id="示例1">示例1</h5><blockquote><p>输入<br>5<br>2 0 1 1 1<br>输出<br>4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Jump &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">int N = sc.nextInt();</span><br><span class="line">int[] nums = new int[N + 1];</span><br><span class="line">int[] dp = new int[N + 1];</span><br><span class="line">for (int i = 0; i &lt; N; i++)</span><br><span class="line">nums[i] = sc.nextInt();</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt;=N; i++)</span><br><span class="line">dp[i] = 100000;</span><br><span class="line">nums[N] = 1;</span><br><span class="line">dp[0] = 0;</span><br><span class="line">for (int i = 1; i &lt;= N; i++) &#123;</span><br><span class="line">if (nums[i] == 0)</span><br><span class="line">continue;</span><br><span class="line">for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">if (nums[j] &gt;= i - j)</span><br><span class="line">dp[i] = Math.min(dp[j] + 1, dp[i]);</span><br><span class="line">System.out.println(&quot;i=&quot; + i + &quot;,&quot; + &quot;j=&quot; + j + &quot;  &quot; + &quot;dp[&quot; + i + &quot;]: &quot; + dp[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println((dp[N] == 100000) ? -1 : dp[N]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>内部类</title>
      <link href="/2017/08/23/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2017/08/23/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      <content type="html"><![CDATA[<p>这是我学习Java内部类的笔记<br>1.为什么使用内部类?<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，<br>对于内部类都没有影响</p><a id="more"></a><p>1.1.使用内部类最大的优点就在于它能够非常好的解决多重继承的问题,使用内部类还能够为我们带来如下特性:<br>(1)、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独。<br>(2)、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。<br>(3)、创建内部类对象的时刻并不依赖于外围类对象的创建。<br>(4)、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。<br>(5)、内部类提供了更好的封装，除了该外围类，其他类都不能访问。<br>2.内部类分类:<br>(一).成员内部类:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Outer&#123;</span><br><span class="line">       private int age = 99;</span><br><span class="line">       String name = &quot;Coco&quot;;</span><br><span class="line">       public class Inner&#123;</span><br><span class="line">           String name = &quot;Jayden&quot;;</span><br><span class="line">           public void show()&#123;</span><br><span class="line">               System.out.println(Outer.this.name);</span><br><span class="line">               System.out.println(name);</span><br><span class="line">               System.out.println(age);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public Inner getInnerClass()&#123;</span><br><span class="line">           return new Inner();</span><br><span class="line">       &#125;</span><br><span class="line">       public static void main(String[] args)&#123;</span><br><span class="line">           Outer o = new Outer();</span><br><span class="line">           Inner in = o.new Inner();</span><br><span class="line">           in.show();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1.Inner 类定义在 Outer 类的内部，相当于 Outer 类的一个成员变量的位置，Inner 类可以使用任意访问控制符，<br>如 public 、 protected 、 private 等<br>2.Inner 类中定义的 show() 方法可以直接访问 Outer 类中的数据，而不受访问控制符的影响，<br>如直接访问 Outer 类中的私有属性age<br>3.定义了成员内部类后，必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，<br>即：内部类 对象名 = 外部类对象.new 内部类( );<br>4.编译上面的程序后，会发现产生了两个 .class 文件: Outer.class,Outer$Inner.class{}<br>5.成员内部类中不能存在任何 static 的变量和方法,可以定义常量:<br>(1).因为非静态内部类是要依赖于外部类的实例,而静态变量和方法是不依赖于对象的,仅与类相关,<br>简而言之:在加载静态域时,根本没有外部类,所在在非静态内部类中不能定义静态域或方法,编译不通过;<br>非静态内部类的作用域是实例级别<br>(2).常量是在编译器就确定的,放到所谓的常量池了<br>★★友情提示:<br>1.外部类是不能直接使用内部类的成员和方法的，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;<br>2.如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，<br>可以使用 this 关键字,如:Outer.this.name<br>(二).静态内部类: 是 static 修饰的内部类,<br>1.静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问<br>2.如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；<br>如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员<br>3.创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名 = new 内部类();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Outer&#123;</span><br><span class="line">           private int age = 99;</span><br><span class="line">           static String name = &quot;Coco&quot;;</span><br><span class="line">           public static class Inner&#123;</span><br><span class="line">               String name = &quot;Jayden&quot;;</span><br><span class="line">               public void show()&#123;</span><br><span class="line">                   System.out.println(Outer.name);</span><br><span class="line">                   System.out.println(name);                  </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           public static void main(String[] args)&#123;</span><br><span class="line">               Inner i = new Inner();</span><br><span class="line">               i.show();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>(三).方法内部类:访问仅限于方法内或者该作用域内<br>(1).局部内部类就像是方法里面的一个局部变量一样，是不能有 public、protected、private 以及 static 修饰符的<br>(2).只能访问方法中定义的 final 类型的局部变量,因为:<br>当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在,<br>直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量;<br>==&gt;使用final修饰符不仅会保持对象的引用不会改变,而且编译器还会持续维护这个对象在回调方法中的生命周期.<br>局部内部类并不是直接调用方法传进来的参数，而是内部类将传进来的参数通过自己的构造器备份到了自己的内部，<br>自己内部的方法调用的实际是自己的属性而不是外部类方法的参数;<br>防止被篡改数据,而导致内部类得到的值不一致<br>   使用的形参为何要为 final???<br>在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，<br>也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，<br>毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解<br>和不可接受的，所以为了保持参数的一致性，就规定使用 final 来避免形参的不改变</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">        public class Outer&#123;</span><br><span class="line">            public void Show()&#123;</span><br><span class="line">                final int a = 25;</span><br><span class="line">                int b = 13;</span><br><span class="line">                class Inner&#123;</span><br><span class="line">                    int c = 2;</span><br><span class="line">                    public void print()&#123;</span><br><span class="line">                        System.out.println(&quot;访问外部类:&quot; + a);</span><br><span class="line">                        System.out.println(&quot;访问内部类:&quot; + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Inner i = new Inner();</span><br><span class="line">                i.print();</span><br><span class="line">            &#125;</span><br><span class="line">            public static void main(String[] args)&#123;</span><br><span class="line">                Outer o = new Outer();</span><br><span class="line">                o.show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">  ```  </span><br><span class="line">(四).匿名内部类:</span><br><span class="line">(1).匿名内部类是直接使用 new 来生成一个对象的引用;</span><br><span class="line">(2).对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，</span><br><span class="line">该类的定义会立即消失，所以匿名内部类是不能够被重复使用;</span><br><span class="line">(3).使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口;</span><br><span class="line">(4).匿名内部类中是不能定义构造函数的,匿名内部类中不能存在任何的静态成员变量和静态方法;</span><br><span class="line">(5).匿名内部类中不能存在任何的静态成员变量和静态方法,匿名内部类不能是抽象的,它必须要实现继承的类或者实现的接口的所有抽象方法</span><br><span class="line">(6).匿名内部类初始化:使用构造代码块！利用构造代码块能够达到为匿名内部类创建一个构造器的效果</span><br></pre></td></tr></table></figure><p>public class OuterClass {<br>public InnerClass getInnerClass(final int   num,String str2){<br>return new InnerClass(){<br>int number = num + 3;<br>public int getNumber(){<br>return number;<br>}<br>};        /* 注意：分号不能省 */<br>}<br>public static void main(String[] args) {<br>OuterClass out = new OuterClass();<br>InnerClass inner = out.getInnerClass(2, “chenssy”);<br>System.out.println(inner.getNumber());<br>}<br>}<br>interface InnerClass {<br>int getNumber();<br>}</p><pre><code></code></pre>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android进程优先级悉知</title>
      <link href="/2017/08/01/Android%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%82%89%E7%9F%A5/"/>
      <url>/2017/08/01/Android%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E6%82%89%E7%9F%A5/</url>
      <content type="html"><![CDATA[<h4 id="进程优先级">进程优先级</h4><p>当系统的内存不足的时候，android系统将根据进程优先级选择杀死一些不太重要的进程，进程优先级从高到底分别为：</p><ul><li>前台进程：<ul><li>进程中处于前台的正与用户交互的activity</li><li>进程中包含与前台activity绑定的service</li><li>进程中包含调用了startForeground方法的service</li><li>进程中包含正在执行的onCreate(),onStart()或onDestory()方法的service</li><li>进程中包含正在执行onReceive()方法的BroadcastReceiver<br></li></ul></li></ul><a id="more"></a><p>系统中前台进程的数量很少，前台进程几乎不会被杀死，只有内存低到不能保证所有前台进程同时运行时才会选择杀死某个前台进程</p><ul><li>可视进程<ul><li>进程中包含未处于前台但仍然可见的activity(调用了activity的onPause()方法，但没有调用onStop()方法)<br>，典型的情况是运行activity是弹出对话框，此时的activity虽然不是前台activity，但仍然可见</li><li>进程中包含与可见activity绑定的service<br>可视进程不会被系统杀死，除非为了保证前台进程不得已而为之</li></ul></li><li>服务进程<ul><li>进程中包含已启动的service</li></ul></li><li>后台进程<br>进程中包含不可见的activity(onStop()方法调用后的activity)，后台进程不会直接影响用户体验，为了保证前台进程/可视进程/服务进程的运行，系统随时都可能杀死一个后台进程，一个正确的实现了生命周期方法的activity处于后台时被系统杀死，可以在用户重新启动它时恢复之前的运行状态</li><li>空进程<br>不包含任何处于活动状态的进程是一个空进程，系统进程杀死空进程。这不会造成任何影响，空进程存在的唯一理由是为了缓存一些启动数据，以便下次更快的启动。</li></ul><h3 id="进程优先级的额外说明">进程优先级的额外说明</h3><p>1.系统会赋予进程尽可能高的优先级. 例如一个进程既包含已启动的service, 也包含前台activity, 则这个进程会被视为前台进程。<br></p><p>2.由于组件之间的依赖性, 进程的优先级有可能被提高. 假如进程A服务于进程B, 则进程A的优先级不能低于进程B. 比如, 进程A的ContentProvider组件正在服务于进程B的某个组件, 或者进程A的service组件和进程B的某个组件绑定等, 这些情况下, 进程A的优先级都不会低于进程B(如果按照优先级规则, 进程A的优先级确实低于进程B, 则系统会选择提高进程A的优先级到和进程B相同)。<br></p><p>3.由于服务进程的优先级高于后台进程, 因此如果activity需要执行耗时操作, 最好还是启动一个service来完成. 当然, 在activity中启动子线程完成耗时操作也可以, 但是这样做的缺点在于, 一旦activity不再可见, activity所在的进程成为后台进程, 而内存不足时后台进程随时都有可能被系统杀死(但是启动service完成耗时操作会带来数据交互的问题, 比如耗时操作需要实时更新UI控件的状态的话, service就不是一个好的选择). 基于同样的考虑, 在BroadcastReceiver中也不应该执行耗时操作, 而应该启动service来完成(当然, BroadcastReceiver的生命周期过于短暂, 也决定了不能在其中执行耗时操作).</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>小感悟</title>
      <link href="/2017/07/29/%E5%B0%8F%E6%84%9F%E6%82%9F/"/>
      <url>/2017/07/29/%E5%B0%8F%E6%84%9F%E6%82%9F/</url>
      <content type="html"><![CDATA[<p><img src="http://qiniu.xueshiming.cn/%E5%B0%8F%E6%84%9F%E6%82%9F.jpg" alt="小感悟"></p><p>        今天看了VoidKing的博客，有一些自己的感悟吧，谈不上很深，但绝对是触动了自己。<br><br>看到一些句子：<br><br>        好的爱情，其实最终得到的是心灵的休息，没有紧张、无须讨好、放掉面具，两个人都能踏实做自己，而且从不担心对方不能完全接纳自己真实的样子，在欣欣然的放松和喜滋滋的给予中，获得犹如充电般的爱的能量……那是两颗互相懂得的心彼此找到了真正的归宿。——青音<br></p><a id="more"></a><p>        感悟：其实无论爱情的什么阶段，最终都是心灵的栖息，在爱人面前展现的是最真实的自己，不论是不善言谈，还是谈天说地，都是两个人最本真的表达，其实没有什么会觉得无聊，只是在最亲近的人的面前，所表现出来的自己，才是最为自然，最为真挚的情感与细节，没有紧张，无需讨好，真的是两颗互相懂得的心，彼此找到了真正的归宿。<br><br>        证明相爱的最好办法就是分开，难过了，思念了，那就是真爱，就总会有遇见的那天。<br><br>        感悟：如果会遇见，那就是一辈子了吧。<br><br>“当你不去旅行，不去冒险，不去拼一份奖学金，不过没试过的生活，整天挂着QQ，刷着微博，逛着淘宝，玩着网游。干着我80岁都能做的事，你要青春干嘛？”<br>        感悟:曾经的自己也是这样想的，但随着慢慢接触的更多，心情变得越来越浮躁，这个繁华的世界，把自己搞得一团糟，其实不能说是完全的退步，更因该说自己对于“改变”这个词的认识还不够，改变的应该是面对任何事物的陈旧的观念，要接受新事物有些旧的东西，可以说是虽然旧，但真的是过去的自己引以为傲的的东西，这些东西并不能舍弃，要舍弃的是年少无知而养成的习惯或者是生活方式。要是现在和别人做的一样的事情，那以后用什么资本去和他们拼。可能青春需要疯狂，但青春的疯狂绝对不是，谈一场轰轰烈烈的恋爱，也绝对不是做一件让所有人都叹为观止的轰然举动，而是去过没有试过的生活，这是一种让你变得更加优秀的生活。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思想 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法</title>
      <link href="/2017/07/28/%E7%AE%97%E6%B3%95/"/>
      <url>/2017/07/28/%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h5 id="二分查找法">二分查找法</h5><p>对于一个有序数组，我们通常采用二分查找的方式来定位某一元素，请编写二分查找的算法，在数组中查找指定元素。<br>给定一个整数数组A及它的大小n，同时给定要查找的元素val，请返回它在数组中的位置(从0开始)，若不存在该元素，<br>返回-1。若该元素出现多次，请返回第一次出现的位置</p><a id="more"></a><p>测试样例：</p><blockquote><p>[1,3,5,7,9],5,3</p></blockquote><blockquote><p>返回 ： 1</p></blockquote><p>解答：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class BinarySearch &#123;</span><br><span class="line">    public int getPos(int[] A, int n, int val) &#123;</span><br><span class="line">        // 因为已是有序数组，所以不必排序</span><br><span class="line">        int low=0,high=n-1,mid;</span><br><span class="line">while(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/2;</span><br><span class="line">if(val&lt;A[mid])&#123;</span><br><span class="line">high=mid-1;</span><br><span class="line">&#125;else if(val&gt;A[mid])&#123;</span><br><span class="line">low=mid+1;</span><br><span class="line"></span><br><span class="line">&#125;else &#123;</span><br><span class="line">          //处理两个相邻元素相等情况</span><br><span class="line">                    if(mid&gt;0&amp;&amp;A[mid]==A[mid-1])</span><br><span class="line">                    return mid-1;</span><br><span class="line">                    else return mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">          int[] A=&#123;1,2,4,4,5,5,6&#125;;</span><br><span class="line">          n=a.length;</span><br><span class="line">          val=5;</span><br><span class="line"> int result=getPos(A, n, val);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="世界上有10种人">世界上有10种人</h5><p>世界上有10种人，一种懂二进制，一种不懂。那么你知道两个int32整数m和n的二进制表达，有多少个位(bit)不同么？</p><p>public class Solution {<br>public static int countBitDiff(int m, int n) {<br>int k = m ^ n; //先将二者做异或运算，得到结果；<br>int num = 0;<br>while(k&gt;0)<br>{                  //统计一个整数k含有多少个1；<br>k &amp;= (k-1);<br>num++;<br>}<br>return num;<br>}</p><pre><code>public static void main(String[] args) {    int b=count(1999,2299);System.out.println(&quot;-----&quot;+b);}</code></pre><p>}</p><p>举个例子：假如传入数据count(5,3);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        十进制     二进制</span><br><span class="line">         5        0 1 0 1</span><br><span class="line">      ^                      位异或:对应位相反为一，相同为0    </span><br><span class="line">         3        0 0 1 1</span><br><span class="line">      - - - - - - - - - - - -</span><br><span class="line">         6        0 1 1 0</span><br><span class="line">n=1   &amp;                      与运算：对应位都为1，则结果为1，否则为0</span><br><span class="line">         5        0 1 0 1</span><br><span class="line">      - - - - - - - - - - - -</span><br><span class="line">         4        0 1 0 0</span><br><span class="line">n=2   &amp;                      与运算：对应位都为1，则结果为1，否则为0</span><br><span class="line">         3        0 0 1 1</span><br><span class="line">      - - - - - - - - - - - -</span><br><span class="line">         0        0 0 0 0</span><br><span class="line"></span><br><span class="line">      当然结果为2了。</span><br></pre></td></tr></table></figure><p>#####分析一下代码：</p><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。<br>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><p>ps : 计算机基础，二进制减法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   1 1 0 0 0 0                      1 2 0 0 0</span><br><span class="line">-    1 0 1 1 1            类比        3 9 9 9  </span><br><span class="line">- - - - - - - -         &lt;-----    - - - - - - - -</span><br><span class="line">     1 1 0 0 1                        8 0 0 1</span><br></pre></td></tr></table></figure><h4 id="知识点补充">知识点补充</h4><p>Java 位运算(移位、位与、或、异或、非)</p><h5 id="java提供的位运算符有：左移-右移-无符号右移-位与-位或-位非-位异或-除了位非-是一元操作符外-其它的都是二元操作符">Java提供的位运算符有：左移( &lt;&lt; )、右移( &gt;&gt; ) 、无符号右移( &gt;&gt;&gt; ) 、位与( &amp; ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。</h5><ol><li>左移( &lt;&lt; )</li></ol><p>Test1、将5左移2位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[java]</span><br><span class="line">package com.xcy;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       System.out.println(5&lt;&lt;2);//运行结果是20</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果是20，但是程序是怎样执行的呢？<br>首先会将5转为2进制表示形式(java中，整数默认就是int类型,也就是32位):<br>0000 0000 0000 0000 0000 0000 0000 0101           然后左移2位后，低位补0：<br>0000 0000 0000 0000 0000 0000 0001 0100           换算成10进制为20</p><ol start="2"><li>右移( &gt;&gt; ) ，右移同理，只是方向不一样罢了(感觉和没说一样)<br>[java]<br>System.out.println(5&gt;&gt;2);//运行结果是1<br>还是先将5转为2进制表示形式：<br>0000 0000 0000 0000 0000 0000 0000 0101 然后右移2位，高位补0：<br>0000 0000 0000 0000 0000 0000 0000 0001</li><li>无符号右移( &gt;&gt;&gt; )<br>我们知道在Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高为为1<br>例如  -5换算成二进制后为：<br>1111 1111 1111 1111 1111 1111 1111 1011   (刚开始接触二进制时，不知道最高位是用来表示正负之分的，当时就总想不通。。明明算起来得到的就是一个正数-_-)<br>我们分别对5进行右移3位、 -5进行右移3位和无符号右移3位：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[java]</span><br><span class="line">package com.xcy;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       System.out.println(5&gt;&gt;3);//结果是0</span><br><span class="line">       System.out.println(-5&gt;&gt;3);//结果是-1</span><br><span class="line">       System.out.println(-5&gt;&gt;&gt;3);//结果是536870911</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看它的移位过程(可以通过其结果换算成二进制进行对比)：</p><p>5换算成二进制：</p><p>0000 0000 0000 0000 0000 0000 0000 0101</p><p>5右移3位后结果为0，0的二进制为：</p><p>0000 0000 0000 0000 0000 0000 0000 0000        // (用0进行补位)</p><p>-5换算成二进制：</p><p>1111 1111 1111 1111 1111 1111 1111 1011</p><p>-5右移3位后结果为-1，-1的二进制为：</p><p>1111 1111 1111 1111 1111 1111 1111 1111   // (用1进行补位)</p><p>-5无符号右移3位后的结果 536870911 换算成二进制：<br>0001 1111 1111 1111 1111 1111 1111 1111   // (用0进行补位)</p><p>通过其结果转换成二进制后，我们可以发现，正数右移，高位用0补，负数右移，高位用1补，当负数<br>使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)<br>注意：笔者在这里说的是右移，高位补位的情况。正数或者负数左移，低位都是用0补。(自行测试)</p><h5 id="最后-二进制的运算">最后，二进制的运算</h5><p>参考(<a href="https://www.chinatax.gov.cn/jypx/jsjjczs/multiply.htm" target="_blank" rel="noopener">https://www.chinatax.gov.cn/jypx/jsjjczs/multiply.htm</a>)</p><h5 id="抽象类-与-接口">抽象类 与 接口</h5><ul><li>抽象类：用abstract修饰，抽象类中可以没有抽象方法，但抽象方法肯定在抽象类中，且抽象方法定义时不能有方法体；抽象类不可以实例化只能通过继承在子类中实现其所有的抽象方法；抽象类如果不被继承就没有任何意义；抽象类为子类定义了一个公共类型，封装了子类中的重复内容。</li><li>接口:同Interface关键字定义接口，是特殊的抽象类因为类中只包含抽象方法；接口中不能定义成员变量可以定义常量；接口是其通过其他类使用implements关键字定义实现类，一个类一旦实现接口就必须实现其中的所有抽象方法，一个类可以实现多个接口，接口名之间用逗号隔开即可；一个接口可以通过extends关键字继承另一个接口，与此同时继承了父类中的所有方法。</li></ul>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构</title>
      <link href="/2017/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2017/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<ol><li>排序：</li></ol><p>概念：将一个数据元素(或记录)的任意序列，重新排列成一个按关键字有序的序列。</p><p>分类：</p><ul><li>内部排序和</li><li>外部排序(数据量大时，需要将数据从内存调到外存)</li></ul><a id="more"></a><p>排序的性质：</p><ul><li>稳定排序</li><li>不稳定排序（某个算法规定a&gt;b,在排序过程中始终a&gt;b）</li></ul><p>常用内部排序：</p><ul><li>插入排序：(按查找的方式不同)直接插入排序、折半插入排序、2路插入排序、表插入排序、希尔排序</li><li>交换类排序：冒泡排序、 快速排序</li><li>选择类排序：简单选择排序、堆排序</li><li>归并排序</li><li>分配类排序：多关键字排序、基数排序</li></ul><hr><p>1、  直接插入排序：</p><p>①  思想：将一个元素插入到一个有序表中。下标为 0 的位置作为检测位，从一个元素逐步扩大有序序列</p><p>② 时间复杂度：平均情况:O(n²) 最好情况：O(n) 最坏情况:O(n²)</p><p>③ 空间复杂度：S(n) = O(1)</p><p>④   稳定性：稳定排序。<br>举例：100个数时无序的，先取一个数（习惯取第一个数）拿出来作为有序序列，再将剩下的99个数里取出一个数，插入到有序序列，有序序列在增大，无序序列在减小，排序完成</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for (i = 1; i &lt; a.length; i++) &#123;</span><br><span class="line">if (a[i] &lt; a[i - 1]) &#123;               // 这个加不加都可以</span><br><span class="line">temp = a[i];                       // 把数组0位置的元素看作有序序列，从数组一位置开始，先把temp=a[1],保留a[1]，</span><br><span class="line">for (j = i - 1; j &gt;= 0 &amp;&amp; temp &lt; a[j]; j--) &#123;</span><br><span class="line">                                         // 判断a[i-1]与temp的大小 如果temp&lt;a[i-1]，把a[i-1]（大于temp的数后移一位）</span><br><span class="line">a[j + 1] = a[j];</span><br><span class="line">a[j] = temp;                     // 直到j减为0 把 temp的值赋值给a[0]; 这里相当于每次都将temp与左边比它大的数交换</span><br><span class="line">&#125;</span><br><span class="line">                                   // 这里也可以这样a[j+1]=temp; 与 a[j] = temp; 执行结果类似，它是把temp这个位置的值空开了</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 折半插入排序</p><p>①   思想：因为是已经确定了前部分是有序序列，所以在查找插入位置的时候可以用折半查找的方法进行查找，提高效率。</p><p>②   时间复杂度：比较时的时间减为O(n㏒n)，但是移动元素的时间耗费未变，所以总是得时间复杂度还是O(n²)。</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;a.length;i++)&#123;</span><br><span class="line">if(a[i]&lt;a[i-1])&#123;                         //没有这个判断也可以</span><br><span class="line">temp=a[i];                             //把a[i]的值缓存</span><br><span class="line">            low=0;    high=i-1;              //标明上界和下界            </span><br><span class="line">            while(low&lt;=high)&#123;                //low=high的时候停止</span><br><span class="line">            mid=(low+high)/2;       </span><br><span class="line">            if(temp&gt;a[mid])&#123;      </span><br><span class="line">            low=mid+1;</span><br><span class="line">            &#125;else high=mid-1;            </span><br><span class="line">            &#125;</span><br><span class="line">            for(j=i;j&gt;low;j--)&#123;              //所有大于temp的数都后移一位 (因为j&gt;low所以a[low]取不到)</span><br><span class="line">            a[j]=a[j-1] ;                  //最后一次移位是将a[low+1]=a[low]</span><br><span class="line">            &#125;</span><br><span class="line">            a[low]=temp;                     //然后把temp的值给a[low]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(了解)  2-路插入排序</p><p>① 思想：减少直接插入法的移动元素个数，分成两路子有序序列，需要N个记录的辅助空间</p><p>(了解)  表插入排序</p><p>① 思想：对静态链表做插入排序</p><p>做法：将一个记录插入到已排好序的有序表中，与直接插入不同，已修改2n次指针值代替移动记录</p><p>3、 希尔排序</p><p>①   思想：又称缩小增量排序法。把待排序序列分成若干较小的子序列，然后逐个使用直接插入排序法排序，最后再对一个较为有序的序列进行一次排序，主要是为了减少移动的次数，提高效率。这里是将增量以元素个数的一半开始。</p><blockquote><pre><code>                   38,49,65,97,76,13,27,49</code></pre></blockquote><pre><code>                    |     |     |     |                    0  1  2  3  4  5  6  7</code></pre><p>②   时间复杂度： 平均情况：O(n^1.5) 最好情况：O(n) 最坏情况:O(n²)</p><p>③   空间复杂度：O(1)</p><p>④   稳定性：不稳定排序。{2,4,1,2}，2和1一组4和2一组，进行希尔排序，第一个2和最后一个2会发生位置上的变化。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int Sort(int[] a)&#123;</span><br><span class="line">int i,j,temp;</span><br><span class="line">   int n=a.length;</span><br><span class="line">   int d=n/2;                //以一半分组</span><br><span class="line">while(d&gt;=1)&#123;</span><br><span class="line">                         //直接插入排序       把每组内的元素都看成一个序列，对这个序列进行直接插入排序</span><br><span class="line">for(i=d;i&lt;a.length;i++)&#123; //i++控制 每组要做比较</span><br><span class="line">temp=a[i];</span><br><span class="line">for(j=i-d;j&gt;=0&amp;&amp;temp&lt;a[j];j=j-d)&#123;</span><br><span class="line">a[j+d]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[j+d]=temp;</span><br><span class="line">&#125;</span><br><span class="line">d/=2;</span><br><span class="line">&#125;</span><br><span class="line">for (int k : a) &#123;</span><br><span class="line">System.out.print(&quot; &quot;+k);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、 冒泡排序</p><p>①   思想：反复扫描待排序序列，在扫描的过程中顺次比较相邻的两个元素的大小，若逆序就交换位置。第一趟，从第一个数据开始，比较相邻的两个数据，（以升序为例）如果大就交换，得到一个最大数据在末尾；然后进行第二趟，只扫描前n-1个元素，得到次大的放在倒数第二位。以此类推，最后得到升序序列。如果在扫描过程中，发现没有交换，说明已经排好序列，直接终止扫描。所以最多进行n-1趟扫描。</p><p>②   时间复杂度：平均 \最坏O(n²) 最好 O(n)</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private static void Sort(int[] a)&#123;</span><br><span class="line">for(int i=0;i&lt;a.length-1;i++)&#123; //控制每一趟的比较，因为比较一趟就有一个数不用比较了（i=0  循环完，一个数就不用考虑了，以此类推）需要比较</span><br><span class="line">                                 //比较7次，但是最后一轮，剩下的最后一个数就确定了不用比较了，所以比较6次 即&lt;a.lenth-1 ,注意是&lt;</span><br><span class="line">for(int j=0;j&lt;a.length-1-i;j++)&#123;  // 因为每次比较完都少一个数所以在a.length-1基础上减i</span><br><span class="line">if(a[j+1]&lt;=a[j])&#123;</span><br><span class="line">int temp=a[j+1];</span><br><span class="line">a[j+1]=a[j];       </span><br><span class="line">a[j]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int k : a) &#123;</span><br><span class="line">System.out.println(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、 快速排序</p><p>① 思想：</p><p>E1：对待排序序列进行划分，使前一部分的key值均小于后一部分；为此需要选定枢轴（支点）</p><p>E2：对前半子序列进行快速排序；</p><p>E3：对后半子序列进行快速排序；</p><blockquote><p>思路： low  --------- high</p></blockquote><p>以第一个元素为基准，先从后往前看</p><p>low  左面都比它小，遇到一个比它大的数就换到后面，然后high-1</p><p>high 右面的数都不小于它，遇到一个比它小的数，就换到前面，然后low+1<br>②   时间复杂度：平均T(n) = O(n㏒n)，最坏O(n²)。</p><p>③   空间复杂度：S(n) = O(㏒n)。</p><p>④   稳定性：不稳定排序。{3， 2， 2}</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static void Sort(int a[], int low, int hight) &#123;</span><br><span class="line">        int i, j, index;</span><br><span class="line">        if (low &gt; hight) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        i = low;</span><br><span class="line">        j = hight;</span><br><span class="line">        index = a[i];          // 用子表的第一个记录做基准</span><br><span class="line">        while (i &lt; j) &#123;        // 从表的两端交替向中间扫描</span><br><span class="line">            while (i &lt; j &amp;&amp; a[j] &gt;= index) //控制</span><br><span class="line">                j--;</span><br><span class="line">            if (i &lt; j)</span><br><span class="line">                a[i++] = a[j]; // 用比基准小的记录替换低位记录</span><br><span class="line">            while (i &lt; j &amp;&amp; a[i] &lt; index)</span><br><span class="line">                i++;</span><br><span class="line">            if (i &lt; j)         // 用比基准大的记录替换高位记录</span><br><span class="line">                a[j--] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = index;          // 将基准数值替换回 a[i]</span><br><span class="line">        Sort(a, low, i - 1);   // 对低子表进行递归排序</span><br><span class="line">        Sort(a, i + 1, hight); // 对高子表进行递归排序</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>6、 简单选择排序：<br>①   思想：第一趟时，从第一个记录开始，通过n – 1次关键字的比较，从n个记录中选出关键字最小的记录，并和第一个记录进行交换。第二趟从第二个记录开始，选择最小的和第二个记录交换。以此类推，直至全部排序完毕。  /<em>选择排序与前面的简单(冒泡)排序算法思路一模一样，不同的地方在于，在寻找最小元素的时候，前者是每次都将最小元素存放到目的地，而后者则只是暂时存放一下其地址，到最后的时候才需要交换。因此，后者省略了很多的交换操作，更优。</em>/</p><p>②   时间复杂度：最好、最坏、平均情况都是O(n²)。</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：不稳定排序，{3， 3， 2}。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static void Sort(int[] a)&#123;</span><br><span class="line">int min;</span><br><span class="line">for(int i=0;i&lt;a.length-1;i++)   //假设有n个元素，需要确定的下标有0到n-1。最后一个元素无需比较</span><br><span class="line">&#123;   min=i;</span><br><span class="line">for(int j=i+1;j&lt;a.length;j++)&#123;  </span><br><span class="line">       if(a[j]&lt;a[min])      //使min总是指向最小的元素</span><br><span class="line">       min=j;</span><br><span class="line">&#125;</span><br><span class="line">        if(min!=i)&#123;             //min有移动过</span><br><span class="line">        int temp =a[i];</span><br><span class="line">        a[i]=a[min];</span><br><span class="line">        a[min]=temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、堆排序</p><p>①   思想：把待排序记录的关键字存放在数组r[1…n]中，将r看成是一刻完全二叉树的顺序表示，每个节点表示一个记录，第一个记录r[1]作为二叉树的根，一下个记录r[2…n]依次逐层从左到右顺序排列，任意节点r[i]的左孩子是r[2i]，右孩子是r[2i+1]，双亲是r[i/2向下取整]。然后对这棵完全二叉树进行调整建堆。</p><blockquote><p>设有一个关键字集合，按完全二叉树的顺序存储方式存放在一个一维数组中。若满足<br>Ki &lt;= K2i              Ki &gt;= K2i<br>Ki &lt;= K2i+1    或    Ki &gt;= K2i+1<br>则称该关键字集合构成一个堆；<br>前者成为小顶堆，后者称为大顶堆。其中二叉树的根结点称为堆顶。<br>i 和  （2i和2i+1）比较<br>存储结构:数组<br>对应逻辑结构： 二叉树</p></blockquote><p>②   时间复杂度：T(n) = O(n㏒n)。(平均、最好、最坏情况都是)</p><p>③   空间复杂度：S(n) = O(1)。</p><p>④   稳定性：不稳定排序。{5， 5， 3}</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class HeapSort &#123;</span><br><span class="line"></span><br><span class="line">public static void heapSort(int[] array) &#123;</span><br><span class="line">if (array == null || array.length &lt;= 1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buildMaxHeap(array); // 建立大顶堆</span><br><span class="line"></span><br><span class="line">for (int i = array.length - 1; i &gt;= 1; i--) &#123;</span><br><span class="line">ArrayUtils.exchangeElements(array, 0, i); // 输出堆顶元素和堆底元素交换</span><br><span class="line"></span><br><span class="line">maxHeap(array, i, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void buildMaxHeap(int[] array) &#123;</span><br><span class="line">if (array == null || array.length &lt;= 1) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int half = array.length / 2; // 从i=[n/2]---1反复调整堆</span><br><span class="line">for (int i = half; i &gt;= 0; i--) &#123;</span><br><span class="line">maxHeap(array, array.length, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void maxHeap(int[] array, int heapSize, int index) &#123;</span><br><span class="line">int left = index * 2 + 1; // 调整元素</span><br><span class="line">int right = index * 2 + 2;</span><br><span class="line"></span><br><span class="line">int largest = index;</span><br><span class="line">if (left &lt; heapSize &amp;&amp; array[left] &gt; array[index]) &#123;</span><br><span class="line">largest = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (right &lt; heapSize &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">largest = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (index != largest) &#123;</span><br><span class="line">ArrayUtils.exchangeElements(array, index, largest);</span><br><span class="line"></span><br><span class="line">maxHeap(array, heapSize, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] array = &#123; 60, 45, 30, 14, 2, 85, 42, 30 &#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;Before heap:&quot;);</span><br><span class="line">ArrayUtils.printArray(array);</span><br><span class="line"></span><br><span class="line">heapSort(array);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;After heap sort:&quot;);</span><br><span class="line">ArrayUtils.printArray(array);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、归并排序<br>①   思想：假设初始序列右n个记录，首先将这n个记录看成n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2向上取整 个长度为2（n为奇数时，最后一个序列的长度为1）的有序子序列。在此基础上，在对长度为2的有序子序列进行两两归并，得到若干个长度为4的有序子序列。如此重复，直至得到一个长度为n的有序序列为止。将两个或两个以上的有序表组合成一个新的有序表</p><p>②   时间复杂度：T(n) = O(n㏒n)。(平均、最坏、最好情况都是)</p><p>③   空间复杂度：S(n) = O(n)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class MergeSort &#123;</span><br><span class="line">/**</span><br><span class="line"> * 归并排序</span><br><span class="line"> * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列</span><br><span class="line"> * 时间复杂度为O(nlogn)</span><br><span class="line"> * 稳定排序方式</span><br><span class="line"> * @param nums 待排序数组</span><br><span class="line"> * @return 输出有序数组</span><br><span class="line"> */</span><br><span class="line">public static int[] sort(int[] nums, int low, int high) &#123;</span><br><span class="line">int mid = (low + high) / 2;        //先分一半</span><br><span class="line">if (low &lt; high) &#123;</span><br><span class="line">// 左边</span><br><span class="line">sort(nums, low, mid);</span><br><span class="line">// 右边</span><br><span class="line">sort(nums, mid + 1, high);</span><br><span class="line">// 左右归并</span><br><span class="line">merge(nums, low, mid, high);</span><br><span class="line">&#125;</span><br><span class="line">return nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void merge(int[] nums, int low, int mid, int high) &#123;</span><br><span class="line">int[] temp = new int[high - low + 1];</span><br><span class="line">int i = low;// 左指针</span><br><span class="line">int j = mid + 1;// 右指针</span><br><span class="line">int k = 0;</span><br><span class="line"></span><br><span class="line">// 把较小的数先移到新数组中</span><br><span class="line">while (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">if (nums[i] &lt; nums[j]) &#123;</span><br><span class="line">temp[k++] = nums[i++];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">temp[k++] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把左边剩余的数移入数组</span><br><span class="line">while (i &lt;= mid) &#123;</span><br><span class="line">temp[k++] = nums[i++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把右边边剩余的数移入数组</span><br><span class="line">while (j &lt;= high) &#123;</span><br><span class="line">temp[k++] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把新数组中的数覆盖nums数组</span><br><span class="line">for (int k2 = 0; k2 &lt; temp.length; k2++) &#123;</span><br><span class="line">nums[k2 + low] = temp[k2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 归并排序的实现</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">int[] nums = &#123;5,2,95,48,32,45,11,97,48&#125;;</span><br><span class="line"></span><br><span class="line">MergeSort.sort(nums, 0, nums.length-1);</span><br><span class="line">ArrayUtils.printArray(nums);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、分配类排序</p><p>一、多关键字的排序</p><ul><li>高位优先法</li><li>划分子序列的思想</li><li>低位优先法</li><li>分配再收集的思想</li></ul><p>二、链式基数排序<br>①   思想：先分配，再收集，就是先按照一个次关键字收集一下，然后进行收集（第一个排序），然后再换一个关键字把新序列分配一下，然后再收集起来，又完成一次排序，这样所有关键字分配收集完后，就完成了排序。</p><p>②   时间复杂度：T(n) = O( d ( n + rd ) )。</p><p>③   空间复杂度：S(n) = O(rd)。</p><p>④   稳定性：稳定排序。</p><p>⑤   程序：</p><p>10、 总结：</p><p>（1）简单排序法一般只用于n较小的情况（例如n&lt;30）。当序列的记录“基本有序”时，直接插入排序是最佳的排序方法。如果记录中的数据较多，则应采用移动次数较少的简单选择排序法。</p><p>（2）快速排序、堆排序和归并排序的平均时间复杂度均为O(n㏒n)，但实验结果表明，就平均时间性能而言，快速排序是所有排序方法中最好的。遗憾的是，快速排序在最坏情况下的时间性能为O(n²)。堆排序和归并排序的最坏时间复杂度仍为O(n㏒n)，当n较大时，归并排序的时间性能优于堆排序，但它所需的辅助空间最多。</p><p>（3）可以将简单排序法与性能较好的排序方法结合使用。例如，在快速排序中，当划分子区间的长度小于某值时，可以转而调用直接插入排序法；或者先将待排序序列划分成若干子序列，分别进行直接插入排序，然后再利用归并排序法，将有序子序列合并成一个完整的有序序列。</p><p>（4）基数排序的时间复杂度可以写成O(d·n)。因此，它最适合于n值很大而关键字的位数d较小的序列。当d远小于n时，其时间复杂度接近O(n)。</p><p>（5）从排序的稳定性上来看，在所有简单排序法中，简单选择排序是不稳定的，其他各种简单排序法都是稳定的。然而，在那些时间性能较好的排序方法中，希尔排序、快速排序、堆排序都是不稳定的，只有归并排序、基数排序是稳定的。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的java（三）</title>
      <link href="/2017/07/16/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2017/07/16/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java基础第二天打卡：每天都过一点java基础，这些看似可以忽略的往往最不可以忽略。</p><a id="more"></a><p>在 Java 程序中，通过类的定义只能实现 单 重继承，但通过接口的定义可以实现 多 重继承关系。</p><h5 id="关于继承：">关于继承：</h5><p>在java中，子类构造器会默认调用super()(无论构造器中是否写有super（）),用于初始化父类成员，同时当父类中存在有参构造器时，必须提供无参构造器，子类构造器中并不会自动继承有参构造器，仍然默认调用super()，使用无参构造器。因此，一个类想要被继承必须提供无参构造器。</p><p>通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。</p><p>对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p><hr> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void waitForSignal()</span><br><span class="line">&#123;</span><br><span class="line">    Object obj = new Object();</span><br><span class="line">    synchronized(Thread.currentThread())</span><br><span class="line">    &#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">        obj.notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题有两个错误的地方，第一个错误是 wait() 方法要以 try/catch 包覆，或是掷出 InterruptedException 才行<br>因此答案就是因为缺少例外捕捉的   InterruptedException<br>第二个错误的地方是， synchronized 的目标与 wait() 方法的物件不相同，会有 IllegalMonitorStateException ，不过 InterruptedException 会先出现，所以这不是答案<br>最后正确的程式码应该是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void waitForSignal() &#123;</span><br><span class="line">Object obj = new Object();</span><br><span class="line">         synchronized (obj) &#123;</span><br><span class="line">             try &#123;</span><br><span class="line">obj.wait();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">obj.notify();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="java程序的种类">java程序的种类</h5><p>Java程序的种类有：<br>（a）内嵌于Web文件中，由浏览器来观看的_Applet<br>（b）可独立运行的 Application<br>（c）服务器端的 Servlets</p><p>Serverlets的工作是：<br>读入用户发来的数据（通常在web页的form中）<br>找出隐含在https请求中的其他请求信息（如浏览器功能细节、请求端主机名等。<br>产生结果(调用其他程序、访问数据库、直接计算)<br>格式化结果（网页）<br>设置https response参数(如告诉浏览器返回文档格式)<br>将文档返回给客户端。</p><h5 id="方法通常存储在进程中的代码区">方法通常存储在进程中的代码区</h5><p>参考链接(<a href="https://www.cnblogs.com/liulipeng/archive/2013/09/13/3319675.html" target="_blank" rel="noopener">https://www.cnblogs.com/liulipeng/archive/2013/09/13/3319675.html</a>)</p><h5 id="开发java程序的三个步骤">开发JAVA程序的三个步骤:</h5><ol><li>编写JAVA的源程序</li><li>编译程序生成字节码.class文件(java是高级语言，不会直接生成机器语言)</li><li>通过JVM解释执行（通过jvm解释为特定的操作系统如Windows、Linux等能理解的机器码，最终JAVA程序得以执行）</li></ol><h5 id="jsp内置对象有：">JSP内置对象有：</h5><p>jsp九大内置对象：</p><p>request,response,  session,out,page,application,exception,pagecontext,config</p><h5 id="基本类型四类八种-其余全是引用类型">基本类型四类八种 其余全是引用类型</h5><p>四类八种：<br>整数（byte short int long)<br>浮点数(float double)<br>字符型(char)<br>逻辑性(boolean)<br>注意大小写，大写的是封装基本类型的引用类型。<br>byte - Byte<br>short - Short<br>int - Integer<br>long - Long<br>float - Float<br>double - Double<br>char - Charactor<br>boolean - Boolean</p><h5 id="构造方法">构造方法</h5><ol><li>定义：</li></ol><ul><li>使用关键字new实例化一个新对象的时候默认调用的方法</li><li>构造方法所完成的主要工作是对新创建对象的数据成员赋初值</li></ul><ol start="2"><li>使用时需注意:</li></ol><ul><li>构造方法名称和其所属的类名必须保持一致</li><li>构造方法没有返回值，也不可以使用void</li><li>构造方法也可以像普通方法一样被重载</li><li>构造方法不能被static和final修饰</li><li>构造方法不能被继承，子类使用父类的构造方法需要使用super关键字</li></ul><h5 id="类构造方法中调用父类构造方法用super-调用本类其他的构造方法用this-super和this都只能位于类构造方法的第一行-不能同时存在">类构造方法中调用父类构造方法用super，调用本类其他的构造方法用this。 super和this都只能位于类构造方法的第一行，不能同时存在</h5><h4 id="以下输出结果是">以下输出结果是</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Example &#123;</span><br><span class="line">    String str = new String(&quot;good&quot;);</span><br><span class="line">    char[] ch = &#123; &apos;a&apos;, &apos;b&apos;, &apos;c&apos; &#125;;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        Example ex = new Example();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + &quot; and &quot;);</span><br><span class="line">        System.out.print(ex.ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void change(String str, char ch[])      </span><br><span class="line">   &#123;</span><br><span class="line">        str = &quot;test ok&quot;;</span><br><span class="line">        ch[0] = &apos;g&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>good and gbc</p></blockquote><p>说法一：</p><ol><li>概念：</li></ol><p>java传参只有按值传递（也就是把实参的值拷贝给形参，这个值可以是普通的数值，也可以是地址值），java中的对象只能通过指向它的引用来操作，这个引用本身也是变量，不要与C/C++中的传值与传址混淆了，java中没有显式的指针。</p><p>分析：change函数被调用时，第一个形参str接收了类的成员变量str的值（虽然名称都是str，但是却是两个独立的String类型的引用变量），注意这两个str自身都是变量且都指向了堆内存中的String对象&quot;good&quot;，当我们在change函数内部将str指向了另一个String对象&quot;test ok&quot;后，类的成员变量str仍然保持指向&quot;good&quot;，所以最终打印出来就是&quot;good&quot;；对于第二个形参ch，它也是接收了类的成员变量ch的值拷贝，这一点和str没有差别，即两个ch都指向了字符数组{ ‘a’, ‘b’, ‘c’ }的首地址，但是ch[0]表示的是字符数组中’a’的地址，修改了它也就修改了字符数组的第一个元素，这个改变在change函数返回之后也会存在。所以本题中两个形参传参的本质区别在于，修改str只是将形参指向了新的对象，对外部的实参没有任何影响，而修改ch[0]是实实在在的修改了字符数组的首元素。</p><ol start="2"><li>拓展</li></ol><ul><li>可以试验一下，在Example中再定义一个字符数组char[] ch2={‘d’};然后在change函数中把ch[0] = ‘g’;这句改成ch=ch2;，那么就会和str传参一样的，change函数返回后不会对类的成员ch有任何影响。</li><li>本题和“String类是一个final类，不能被继承”以及“String底层的字符数组被声明为private final char value[];所以其值不能被修改”这些String的特性无关。</li><li>我们平时交换数组中的两个元素时，一般定义swap方法为 void swap(int[] a, int i, int j)，想想看为什么能达到目的？如果不使用数组，能实现交换吗？数组中存放的不是基本类型变量而是引用类型变量呢？</li></ul><p>说法二:</p><p>其实都是引用传递，只是因为String是个特殊的final类，所以每次对String的更改都会重新创建内存地址并存储（也可能是在字符串常量池中创建内存地址并存入对应的字符串内容），但是因为这里String是作为参数传递的，在方法体内会产生新的字符串而不会对方法体外的字符串产生影响。</p><h5 id="关于string">关于String</h5><blockquote><p>String str1 = “hello”;<br>String str2 = “he” + new String(“llo”);<br>System.err.println(str1 == str2);</p></blockquote><p>解释：String str1 = “hello”;这里的str1指的是方法区的字符串常量池中的“hello”，编译时期就知道的； String str2 = “he” + new String(“llo”);这里的str2必须在运行时才知道str2是什么，所以它是指向的是堆里定义的字符串“hello”，所以这两个引用是不一样的。<br>如果用str1.equal(str2)，那么返回的是True；因为两个字符串的内容一样。</p><h5 id="自动拆装箱">自动拆装箱</h5><ol><li>基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；</li><li>两个Integer类型进行“==”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。</li><li>两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true</li><li>基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</li></ol><p>解释：</p><blockquote><p>int a=257;<br>Integer b=257;<br>Integer c=257;<br>Integer b2=57;<br>Integer c2=57;<br>System.out.println(a==b);<br><a href="//System.out.println">//System.out.println</a>(a.equals(b));  编译出错，基本型不能调用equals()<br>System.out.println(b.equals(257.0));<br>System.out.println(b==c);<br>System.out.println(b2==c2);</p></blockquote><p>因此上面的代码的结果因此为 true, false, false, true</p><h5 id="java多线程间的通讯之等待唤醒机制">java多线程间的通讯之等待唤醒机制</h5><h5 id="1-wait-notify-和notifyall-是-object类-中的方法">1. wait()、notify()和notifyAll()是 Object类 中的方法</h5><ol><li>wait()、notify()和notifyAll()是 Object类 中的方法</li><li>调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）</li><li>调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程</li><li>调用notifyAll()方法能够唤醒所有正在等待这个对象的monitor的线程；</li></ol><ul><li>wait()方法被某个对像调用时，相当于让当前线程交出此对象的monitor，然后进入等待状态，<br>等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从<br>而让其他线程有机会继续执行，但它并不释放对象锁）；</li><li>notify()方法能够唤醒一个正在等待该对象的monitor的线程，当有多个线程都在等待该对象<br>的monitor的话，则只能唤醒其中一个线程，具体唤醒哪个线程则不得而知。<br>同样地，调用某个对象的notify()方法，当前线程也必须拥有这个对象的monitor，因此调用<br>notify()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。</li><li>nofityAll()方法能够唤醒所有正在等待该对象的monitor的线程，这一点与notify()方法是不同的。</li></ul><h5 id="condition是在java-1-5中才出现的-它用来替代传统的object的wait-notify-实现线程间的协作-相比使用object的wait-notify-使用condition1的await-signal-这种方式实现线程间协作更加安全和高效-因此通常来说比较推荐使用condition-在阻塞队列那一篇博文中就讲述到了-阻塞队列实际上是使用了condition来模拟线程间协作">Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</h5><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll()</li></ul><h5 id="一个选择题教你学方法重写">一个选择题教你学方法重写</h5><p>如果一个接口Cow有个方法drink()，有个类Calf实现接口Cow，则在类Calf中正确的是？  ©</p><ul><li>A. void drink() { …}</li><li>B. protected void drink() { …}</li><li>C. public void drink() { …}</li><li>D. 以上语句都可以用在类Calf中</li></ul><h5 id="假设-a-类有如下定义-设-a-是-a-类的一个实例-下列语句调用哪个是错误的？">假设 A 类有如下定义，设 a 是 A 类的一个实例，下列语句调用哪个是错误的？（）</h5><blockquote><p>Class A<br>{<br>Int i;<br>Static String s;<br>Void method1(){}<br>Static void method2(){}<br>}</p></blockquote><p>解析：静态成员和静态方法，可以直接通过类名进行调用；其他的成员和方法则需要进行实例化成对象之后，通过对象来调用。<br>所以a.method1();(对)、A.method2();(对)、 A.method1();(错)</p><h5 id="java-多态">java 多态</h5><p>抽象类或者接口根本无法实例化</p><h5 id="哪些情况可以终止当前线程的运行">哪些情况可以终止当前线程的运行?</h5><ul><li>优先级高的并不一定会马上执行。</li><li>sleep方法会阻塞一个线程并不会终止</li><li>创建一个新的线程时也不会终止另一个线程</li><li>当抛出一个异常后程序会结束，所以线程也会被终止</li></ul><h5 id="java不允许单独的方法-过程或函数存在-需要隶属于某一类中-java语言中的方法属于对象的成员-而不是类的成员-不过-其中静态方法属于类的成员">java不允许单独的方法，过程或函数存在,需要隶属于某一类中; java语言中的方法属于对象的成员,而不是类的成员。不过，其中静态方法属于类的成员</h5><h5 id="equals-和-的区别：">equals()和==的区别：</h5><blockquote><p>String s1=“abc”+“def”;//1<br>String s2=new String（s1);//2<br>if(s1.equals(s2))//3<br>System.out.println(&quot;.equals succeeded&quot;);//4<br>if(s1==s2)//5<br>System.out.println(&quot;==succeeded&quot;);//6</p></blockquote><p>equals（）比较的是字符串的内容，==比较的是内存地址值</p><p>s1存放在常量池中 s2存放在堆区中  内存地址值是不一样的</p><h5 id="垃圾回收机制-如题">垃圾回收机制，如题</h5><blockquote><p>static String str0=“0123456789”;<br>static String str1=“0123456789”;<br>String str2=str1.substring(5);<br>String str3=new String(str2);<br>String str4=new String(str3.toCharArray());<br>str0=null;<br>假定str0,…,str4后序代码都是只读引用。<br>Java 7中，以上述代码为基础，在发生过一次FullGC后，上述代码在Heap空间（不包括PermGen）保留的字符数为（）</p></blockquote><p>垃圾回收主要针对的是堆区的回收，因为栈区的内存是随着线程而释放的。<br>堆区分为三个区：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。<br>年轻代：对象被创建时（new）的对象通常被放在Young（除了一些占据内存比较大的对象）,经过一定的Minor GC（针对年轻代的内存回收）还活着的对象会被移动到年老代（一些具体的移动细节省略）。年老代：就是上述年轻代移动过来的和一些比较大的对象。Minor GC(FullGC)是针对年老代的回收<br>永久代：存储的是final常量，static变量，常量池。<br>str3,str4都是直接new的对象，而substring的源代码其实也是new一个string对象返回，如下图：<br>经过fullgc之后，年老区的内存回收，则年轻区的占了15个，不算PermGen。所以答案为15。</p><h5 id="java设计模式之单例模式">java设计模式之单例模式</h5><p>参考博客(<a href="https://blog.csdn.net/jason0539/article/details/23297037/" target="_blank" rel="noopener">https://blog.csdn.net/jason0539/article/details/23297037/</a>)</p><h5 id="java-stack-和heap-的区别">java stack 和heap 的区别</h5><p>参考博客(<a href="https://blog.csdn.net/wl_ldy/article/details/5935528" target="_blank" rel="noopener">https://blog.csdn.net/wl_ldy/article/details/5935528</a>)</p><h5 id="关于iterator-迭代器">关于iterator(迭代器)</h5><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。<br>Java中的Iterator功能比较简单，并且只能单向移动：</p><ol><li>使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</li><li>使用next()获得序列中的下一个元素。</li><li>使用hasNext()检查序列中是否还有元素。</li><li>使用remove()将迭代器新返回的元素删除。</li></ol><p>Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p><p>迭代器应用：</p><blockquote><p>list<string> l = new ArrayList<string>();<br>l.add(“aa”);<br>l.add(“bb”);<br>l.add(“cc”);<br>for (Iterator iter = l.iterator(); iter.hasNext()<img class="emoji" draggable="false" alt="😉" src="https://twemoji.maxcdn.com/2/72x72/1f609.png"> {<br>String str = (String)iter.next();<br>System.out.println(str);<br>}<br>//迭代器用于while循环<br>Iterator<string> iter = l.iterator();<br>while(iter.hasNext()){<br>String str = (String) iter.next();<br>System.out.println(str);<br>if(str.equals(“aa”)){<br>System.out.println(&quot;----------------------&quot;);<br>iter.remove();<br>System.out.println(l.toString);<br>}<br>}<br>输出结果：<br>aa<br>bb<br>cc</string></string></string></p></blockquote><hr><p>[bb, cc]</p><p>下面给出一个例题:</p><blockquote><p>Iterator it = list.iterator();<br>int index = 0;<br>while (it.hasNext())<br>{<br>Object obj = it.next();<br>if (needDelete(obj))  //needDelete返回boolean，决定是否要删除<br>{<br>//如何在这里可以，在Iterator遍历的过程中正确并安全的删除一个list中保存的对象<br>}<br>index ++;<br>}</p></blockquote><p>答案：it.remove();</p><p>解释：<br>如果在循环的过程中调用集合的remove()方法，例如：</p><blockquote><p>for(int i=0;i&lt;list.size();i++){<br>list.remove(…);<br>}</p></blockquote><p>循环过程中list.size()的大小变化了，就会导致导list中的元素删除不完全。<br>所以，如果你想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为它的remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，你不能连续两次调用它的remove()方法，调用之前至少有一次next()方法的调用。</p><h5 id="spring-支持-7-种事务传播行为：">Spring 支持 7 种事务传播行为：</h5><ul><li>PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</li><li>PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li>PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。</li><li>PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li></ul><h5 id="集合小结">集合小结</h5><ol><li>List（有序、可重复）<br>List里存放的对象是有序的，同时也是可以重复的，List关注的是索引，拥有一系列和索引相关的方法，查询速度快。因为往list集合里插入或删除数据时，会伴随着后面数据的移动，所有插入删除数据速度慢。</li><li>Set（无序、不能重复）<br>Set里存放的对象是无序，不能重复的，集合中的对象不按特定的方式排序，只是简单地把对象加入集合中。</li><li>Map（键值对、键唯一、值不唯一）<br>Map集合中存储的是键值对，键不能重复，值可以重复。根据键得到值，对map集合遍历时先得到键的set集合，对set集合进行遍历，得到相应的值。</li></ol><p>集合类汇总(<a href="https://www.cnblogs.com/leeplogs/p/5891861.html" target="_blank" rel="noopener">https://www.cnblogs.com/leeplogs/p/5891861.html</a>)</p><h5 id="replaceall-方法">replaceAll() 方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main (String[] args) &#123;</span><br><span class="line">    String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;;</span><br><span class="line">    System.out.println(classFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果：///////MyClass.class</p></blockquote><p>由于replaceAll方法的第一个参数是一个正则表达式，而&quot;.“在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/&quot;。如果想替换的只是&quot;.&quot;，那么久要写成&quot;\.&quot;.</p><h5 id="对象序列化的描述">对象序列化的描述</h5><p>使用ObjectOutputStream和ObjectInputStream可以将对象进行传输.</p><p>声明为static和transient类型的成员数据不能被串行化。因为static代表类的状态， transient代表对象的临时数据。</p><p>在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。</p><h5 id="jsp中静态include和动态include的区别">jsp中静态include和动态include的区别</h5><ol><li><p>动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=“included.jsp” flush=“true” /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。</p></li><li><p>静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=“included.htm” %&gt; 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相同的变量。</p></li><li><p>两者的区别:</p><p>一: 执行时间上 :</p><p>&lt;%@ include file=“relativeURI”%&gt; 是在翻译阶段执行<br>&lt;jsp:include page=“relativeURI” flush=“true” /&gt; 在请求处理阶段执行 .</p><p>二: 引入内容的不同 :</p><p>&lt;%@ include file=“relativeURI”%&gt;<br>引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起 .<br>&lt;jsp:include page=“relativeURI” flush=“true” /&gt; 引入执行页面或 servlet 所生成的应答文本 .</p></li></ol><h5 id="变量引用">变量引用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Replaces &#123;</span><br><span class="line">       public int x;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">System. out. println(&quot;Value is&quot; + x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改正：实例化Replaces 或 public static int  x;</p><p>原因：非静态成员只能被类的实例化对象引用，因此这里在静态方法中访问x会造成编译出错</p><h5 id="aop和oop">AOP和OOP</h5><p>AOP 和 OOP的区别：</p><ol><li>面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。</li><li>面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。<br>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</li></ol><h5 id="类的初始化顺序">类的初始化顺序</h5><p>静态优先，父类优先</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class HelloA&#123;</span><br><span class="line">public HelloA()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I’m A class &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static</span><br><span class="line">    &#123;</span><br><span class="line">    System.out.println(&quot;static A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class HelloB extends HelloA&#123;</span><br><span class="line">    public HelloB()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;I’m B class&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;static B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main (String[] args)&#123;</span><br><span class="line">        new HelloB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：static A static B I’m A class I’m B class</p></blockquote><h5 id="resultset中记录行的第一列索引为1">ResultSet中记录行的第一列索引为1</h5><h5 id="jsp">JSP</h5><p>A JSP脚本(Scriptlet)，是Java代码块。</p><p>C JSP表达式(expression)，表达式是一个有返回值的式子，它返回的结果将由out.print()进行输出。</p><p>所以jsp表达式写法：<br>&lt;%= expression %&gt;</p><p>c语言&amp;&amp;和||的短路性质分析：<br>(<a href="https://blog.csdn.net/yhj110911119/article/details/52436085" target="_blank" rel="noopener">https://blog.csdn.net/yhj110911119/article/details/52436085</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的Java（二）</title>
      <link href="/2017/07/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/07/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>好几天的java基础知识都写在了前两篇里，感觉有些多和杂，今天再写新的一篇，每天做30道java的题目，感觉自己的基础知识就得好好巩固一下。</p><a id="more"></a><h5 id="java的跨平台特性">java的跨平台特性</h5><p>我们编译好的文件是以.java后缀保存的，编译器会自动帮我们生成一个标准的.class字节码文件，JVM运行该文件。JVM也是一个软件，不同的系统平台JVM不同，但都可以实现标准的.class字节码文件。</p><h5 id="数据库事务的隔离级别">数据库事务的隔离级别</h5><p>4个。由低到高依次为Read uncommitted(未授权读取、读未提交)、Read committed（授权读取、读提交）、Repeatable read（可重复读取）、Serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题</p><pre><code>                     √: 可能出现    ×: 不会出现</code></pre><table><thead><tr><th></th><th style="text-align:center">脏读</th><th style="text-align:right">不可重复读</th><th style="text-align:right">幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td style="text-align:center">√</td><td style="text-align:right">√</td><td style="text-align:right">√</td></tr><tr><td>Read committed</td><td style="text-align:center">×</td><td style="text-align:right">√</td><td style="text-align:right">√</td></tr><tr><td>Repeatable read</td><td style="text-align:center">×</td><td style="text-align:right">×</td><td style="text-align:right">√</td></tr><tr><td>Serializable</td><td style="text-align:center">×</td><td style="text-align:right">×</td><td style="text-align:right">×</td></tr></tbody></table><h5 id="关于instanceof">关于instanceof</h5><p>instanceof 用来在运行时指出对象是否是特定类的一个实例，instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</p><h5 id="异常">异常</h5><p>checked exception：指的是编译时异常，该类异常需要本函数必须处理的，用try和catch处理，或者用throws抛出异常，然后交给调用者去处理异常。</p><p>runtime exception：指的是运行时异常，该类异常不必须本函数必须处理，当然也可以处理。<br>Thread.sleep()抛出的InterruptException属于checked exception；IllegalArgumentException属于Runtime exception;</p><h5 id="java语言的下面几种数组复制方法中-哪个效率最高？">java语言的下面几种数组复制方法中，哪个效率最高？</h5><p>效率：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环<br>A：for循环，效率最低，随便写个程序验证一下，效率慢的不是一点…我测试的时候比clone和System.arraycopy差了100多倍</p><p>B：System.arraycopy：原型是<br>public static native void arraycopy(Object src,  int  srcPos , Object dest, int destPos, int length);</p><p>C：Arrays.copyOf底层调用了上面的System.copyOf效率比上面两个低。</p><p>D：clone()的完整定义：protected native Object clone() throws CloneNotSupportedException;</p><h5 id="java多线程的叙述正确的是">JAVA多线程的叙述正确的是</h5><p>Callable类的call()方法可以返回值和抛出异常</p><p>#####　以下将打印出</p><blockquote><p>public static void main(String args[]) {<br>List  Listlist1 = new ArrayList();<br>Listlist1.add(0);<br>List Listlist2 = Listlist1;<br>System.out.println(Listlist1.get(0) instanceof Integer);<br>System.out.println(Listlist2.get(0) instanceof Integer);<br>}</p></blockquote><blockquote><p>true  true</p></blockquote><p>解析 :<br>collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据，该题中装入了0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。</p><p>将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)</p><h5 id="如果希望监听tcp端口9000-应该怎样创建socket">如果希望监听TCP端口9000，应该怎样创建socket?</h5><blockquote><p>new ServerSocket(9000);</p></blockquote><h5 id="抽象类-abstract-class-和接口-interface-的区别">抽象类(abstract class)和接口(interface)的区别</h5><ol><li>含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</li><li>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br>下面比较一下两者的语法区别：</li></ol><ul><li>抽象类可以有构造方法，接口中不能有构造方法</li><li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li><li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</li><li>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li><li>抽象类中可以包含静态方法，接口中不能包含静态方法</li><li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li><li>一个类可以实现多个接口，但只能继承一个抽象类。</li></ul><p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，</p><p>例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码.</p><h5 id="ant和maven">Ant和Maven</h5><p>Ant和Maven都是基于Java的构建(build)工具。理论上来说，有些类似于（Unix）C中的make ，但没有make的缺陷。Ant是软件构建工具，Maven的定位是软件项目管理和理解工具。</p><ol><li>Ant特点 <br>没有一个约定的目录结构 必须明确让ant做什么，什么时候做，然后编译，打包 没有生命周期，必须定义目标及其实现的任务序列 没有集成依赖管理</li><li>Maven特点<br>拥有约定，知道你的代码在哪里，放到哪里去 拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮你处理其他事情 拥有依赖管理，仓库管理</li></ol><h5 id="强制转换">强制转换</h5><p>byte和short型在计算时会自动转换为int型计算，结果也是int 型<br>低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte=char=short&lt;int&lt;long&lt;float&lt;double<br>byte,short,char是同级别的，不能自动转换</p><h5 id="finally-关键字">finally 关键字</h5><ol><li>选项在 final 定义的方法里，不是必须要用 final 定义变量。</li><li>final 定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化。</li><li>正确，final修饰方法，不能被子类重写，但是可以被重载。</li><li>final 定义变量，可以用 static</li></ol><p>final修饰的类不能被继承， final 修饰的方法不能被重写，final修饰的属性在第一次被赋值后不可再更改值。</p><h5 id="以下程序输出结果">以下程序输出结果</h5><blockquote><p>class HasStatic{<br>private static int x=100;<br>public static void main (String args[]){<br>HasStatic hs1=new HasStatic();<br>hs1.x++;<br>HasStatic hs2=new HasStatic();<br>hs2.x++;<br>hs1=new HasStatic();<br>hs1.x++;<br>HasStatic.x–;<br>System.out.println(“x=” +x);<br>}<br>}</p></blockquote><p>因为x的 修饰符为 static 所以x为类变量，即对于所有的实例来说，他们访问的x为同一个x，类变量存储在方法区，不属于每个实例的私有，</p><p>刚开始x=100</p><p>调用hs1.x++   x为101;</p><p>调用hs2.x++   x为102;</p><p>调用hs1.x++   x为103 (此时hs1指向了一个新的HasStatic实例，但是依然访问的是同一个X)</p><p>调用HasStatic.x--  x为102</p><p>所以结果为D</p><h5 id="java-中的-wait-方法和-sleep-方法的区别">java 中的 wait()方法和 sleep()方法的区别</h5><ol><li>这两个方法来自不同的类分别是Thread和Object</li><li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。</li><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在<br>任何地方使用<br>synchronized(x){<br>x.notify()<br>//或者wait()<br>}</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li></ol><h5 id="java-object类">java Object类</h5><p>一共有11个： equals . getClass . hashCode . toString . notify .notifyAll .<br>wait . finalize . clone</p><h5 id="一个小题">一个小题</h5><blockquote><p>public class TestClass {<br>private static void testMethod(){<br>System.out.println(“testMethod”);<br>}<br>public static void main(String[] args) {<br>((TestClass)null).testMethod();<br>}<br>}</p></blockquote><p>我来总结下大家的分析。<br>1）此处是类对方法的调用，不是对象对方法的调用。<br>2）方法是static静态方法，直接使用&quot;类.方法&quot;即可，因为静态方法使用不依赖对象是否被创建。<br>null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。<br>3）非静态的方法用&quot;对象.方法&quot;的方式，必须依赖对象被创建后才能使用，若将testMethod()方法前的static去掉，则会报 空指针异常 。此处也验证了2）的观点<br>当然，不管是否静态方法，都是已经存在的，只是访问方式不同。</p><h5 id="线程安全的集合类">线程安全的集合类</h5><p>简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration</p><p>java1.8实测，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default</p><h5 id="webservice">webService</h5><p>Webservice是跨平台，跨语言的远程调用技术</p><p>它的通信机制实质就是xml数据交换;</p><p>它采用了soap协议（简单对象协议）进行通信</p><h5 id="super关键字">super关键字</h5><p>super是java提供的一个关键字，super用于限定该对象调用它从父类继承得到的Field或方法。super关键字不能出现在static修饰的方法中，因为static修饰的方法是属于类的。如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的field，而不是该类自己定义的field。需要注意的是，super关键字只能指代直接父类，不能指代父类的父类。（需要好好理解）</p><h5 id="java垃圾回收机制">java垃圾回收机制</h5><p>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。<br>当对象的引用变量被赋值为null，可能被当成垃圾。</p><p>对于“程序可明确地标识某个局部变量的引用不再被使用”说法错误</p><p>因为，局部变量存放在栈上，栈上的垃圾回收，由finalize()来实现。</p><p>参考(<a href="https://www.importnew.com/19085.html" target="_blank" rel="noopener">https://www.importnew.com/19085.html</a>)</p><h5 id="重要的知识-可以自己实测">重要的知识，可以自己实测</h5><p>静态内部类可以访问外围类的静态数据，包括（静态）私有数据，但不能访问非静态数据；<br>非静态内部类可以直接访问外围类的数据，包括私有数据</p><h5 id="final修饰变量">final修饰变量</h5><p>一、final修饰变量</p><ol><li>final可以修饰成员变量，也可以修饰局部变量、形参。final变量一旦获得初始值之后，final的变量就不能被重新赋值。</li></ol><p>成员变量是随类初始化或对象初始化而初始化的，当执行静态初始化块时候可以对类属性进行赋初始值，当执行普通初始化块或者构造器的时候可以对实例属性赋初始值。因此成员变量的初始值可以在定义的时候赋值或者在初始化块、构造器中指定。</p><p>对于final修饰的成员变量而言，一旦有了初始值之后，就不能被重新赋值，因此不可以在普通方法中对成员变量赋值。要么在定义的时候赋值，要么在方法块和构造器中赋值。<br>final成员变量，必须由程序员显示初始化，系统不会对final成员进行隐式初始化。</p><ol start="2"><li>final修饰局部变量时既可以在定义时候指定默认值，也可以不指定，在后面指定，但只能一次。</li><li>final修饰基本类型的时候 变量不能改变</li><li>final修饰引用类型变量，final只保证这个引用的地址不变，即一直引用同一对象。但这个对象可以改变。</li></ol><h5 id="java-构造函数使用方法总结">java 构造函数使用方法总结</h5><p>使用构造器时需要记住：</p><ol><li>构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个、1个或1个以上的参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new操作一起调用</li></ol><p>使用super调用父类构造器的语句必须是子类构造器的第一条语句</p><p>如果子类构造器没有显式地调用父类的构造器，则将自动调用父类的默认（没有参数）的构造器。如果父类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用父类的构造器，则java编译器将报告错误</p><h5 id="jvm中垃圾回收分为scanvenge-gc和full-gc-其中full-gc触发的条件可能有哪些">jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些</h5><ol><li>新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。</li><li>老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。</li><li>持久代：持久代如果满了，将触发Full GC。，System.gc是有可能触发full gc的</li></ol><h5 id="关于string-stringbuilder以及stringbuffer">关于String，StringBuilder以及StringBuffer</h5><p>A. java中的字符串存储在字符串常量区，不会改变，发生改变是会新创建一个对象<br>B. StringBuffer是线程安全的StringBuilder<br>C. StringBuilder跟StringBuffer功能相同，区别是StringBuilder不是线程安全的<br>D. StringBuilder和StringBuffer底层都是以字符数组存放的，可以修改内容</p><h5 id="jdk提供的用于并发编程的同步器有哪些">JDK提供的用于并发编程的同步器有哪些</h5><p>A. Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>B. CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>C. 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p><h5 id="jre-判断程序是否执行结束的标准是">jre 判断程序是否执行结束的标准是（）</h5><p>所有的前台线程执行完毕</p><p>#####　经过强制类型转换以后，变量a, b的值分别为（ ）short a = 128; byte b = (byte) a;<br>128  -128</p><p>解析：byte在内存中占一个字节，范围是 -128到127之间。<br>将128强制类型转换为byte型，就超出了byte型的范围，<br>128的二进制存储是 1000 0000 转换为byte型后，最高位是符号位，值是-128</p><h5 id="java异常类">JAVA异常类</h5><p>参考(<a href="https://www.cnblogs.com/sargeles/p/6691383.html" target="_blank" rel="noopener">https://www.cnblogs.com/sargeles/p/6691383.html</a>)</p><h5 id="有关jvm内存">有关JVM内存</h5><p>运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器<br>虚拟机栈区 ：也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。<br>堆区 ， JAVA 堆，也称 GC 堆，所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。<br>方法区 ：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。<br>程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。</p><h5 id="hashmap跟hashtable的区别">hashMap跟hashTable的区别</h5><p>①继承不同。</p><blockquote><p>public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map</p></blockquote><p>②<br>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br>③<br>Hashtable中，key和value都不允许出现null值。<br>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>④两个遍历方式的内部实现上不同。<br>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>⑤<br>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>⑥<br>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><h5 id="下列说法">下列说法</h5><p>A. ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized;<br>B. HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Cllectio<br>C. Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；<br>D. SimpleDateFormat是线程不安全的</p><h5 id="对于以下程序-输出">对于以下程序 输出</h5><blockquote><p>public class StringDemo{<br>private static final String MESSAGE=“taobao”;<br>public static void main(String [] args) {<br>String a =“tao”+“bao”;<br>String b=“tao”;<br>String c=“bao”;<br>System.out.println(a==MESSAGE);<br>System.out.println((b+c)==MESSAGE);<br>}<br>}<br>true false</p></blockquote><p>要注意两个问题：<br>1，字符串在java中存储在字符串常量区中<br>2，==判断的是对象引用是否是同一个引用，判断字符串相等要用equals方法<br>首先判断a==MESSAGE 同一份字符串常量在内存中只有一份，因此是同一地址，返回true<br>再次比较(b+c)==MESSAGE 这相当于 new String(b+c)==MESSAGE 这里new了一个String对象，所以返回false</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的Java（一）</title>
      <link href="/2017/07/09/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/07/09/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Java%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>关于java基础的一些概念性、理论性的东西，好久没碰了，现在回过头来看看，有助于自己更深层次的提高，所以在此总结一下。</p><a id="more"></a><h5 id="方法的重写">方法的重写</h5><ol><li>概念：子父类出了同名的函数，这个我们就称作为方法的重写。</li><li>方法重写的前提： 必须要存在继承的关系。</li><li>什么是时候要使用方法的重写：父类的功能无法满足子类的需求时。</li><li>方法重写要注意的事项：(“两同两小一大”)</li></ol><ul><li>方法重写时，方法名与形参列表必须一致。(“两同”)</li><li>方法重写时，子类的返回值类型必须要小于或者等于父类的返回值类型(“小”)</li><li>方法重写时，子类抛出的异常类型要小于或者等于父类抛出的异常类型(“小”)</li><li>方法重写时，子类的权限修饰符必须要大于或者等于父类的权限修饰符(“一大”)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception(最坏)</span><br><span class="line">RuntimeException(小坏)</span><br></pre></td></tr></table></figure><h5 id="方法的重载">方法的重载</h5><ol><li>概念：在一个类中 存在两个或者两个 以上的同名函数,称作为方法重载。</li><li>方法重载的要求</li></ol><ul><li>函数名要一致</li><li>形参列表不一致（形参个数或形参的类型不一致）</li><li>与返回值类型无关</li></ul><h5 id="java运算符优先级助记口诀">java运算符优先级助记口诀</h5><p>单目乘除为关系，逻辑三目后赋值。</p><ul><li>单目：单目运算符+ –(负数) ++ – 等</li><li>乘除：算数运算符* / % + -</li><li>为：位移运算符&lt;&lt; &gt;&gt;</li><li>关系：关系运算符&gt; &lt; &gt;= &lt;= == !=</li><li>逻辑：逻辑运算符&amp;&amp; || &amp; | ^</li><li>三目：三目运算符A &gt; B ? X : Y</li><li>后：无意义，仅仅为了凑字数</li><li>赋值：赋值=</li></ul><h5 id="java的四种访问权限">java的四种访问权限</h5><table><thead><tr><th></th><th style="text-align:center">public</th><th style="text-align:right">protected</th><th style="text-align:right">default(包权限)</th><th style="text-align:right">private</th></tr></thead><tbody><tr><td>同一类中的成员</td><td style="text-align:center">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td></tr><tr><td>同一包中的成员</td><td style="text-align:center">是</td><td style="text-align:right">是</td><td style="text-align:right">是</td><td style="text-align:right">否</td></tr><tr><td>不同包的子类</td><td style="text-align:center">是</td><td style="text-align:right">是</td><td style="text-align:right">否</td><td style="text-align:right">否</td></tr><tr><td>不同包的非子类</td><td style="text-align:center">是</td><td style="text-align:right">否</td><td style="text-align:right">否</td><td style="text-align:right">否</td></tr></tbody></table><p>protected可以修饰数据成员，构造方法，方法成员，不能修饰类（此处指外部类，不考虑内部类）。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类(即有继承关系)。<br>表格解释:</p><ol><li>public：任何地方均可访问；</li><li>private：只限类的内部访问；</li><li>protected：受保护的，类的内部可访问；同一个包下的不管是否有继承关系均可访问；不同包下只有有继承关系的才可访问；</li><li>默认（default）：类的内部可访问；同一个包下不管是否有继承关系均可访问；不同包下不管有没有继承关系都不能访问。</li></ol><h5 id="java并发之原子性-可见性与有序性">java并发之原子性、可见性与有序性</h5><ol><li>原子性<br>原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。Java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</li><li>可见性<br>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就这这个操作同样存在线程安全问题。</li><li>有序性<br>volatile。JVM规定，在volatile之前的操作，不能重排序到volatile之后。</li></ol><p>synchronized。同步代码块对于不同线程来说串行进入的。</p><h5 id="线程的创建方式">线程的创建方式</h5><ol><li>继承Thread类，重写run()方法，该run方法的方法体，代表了线程需要完成的任务</li><li>实现Runnable接口，重写该接口的run()方法，run()方法也为线程执行体</li></ol><h5 id="其他小知识">其他小知识</h5><p>在java7中下列说法：<br>(1)Arrays.asList()将一个数组转化为一个List对象，这个方法会返回一个ArrayList类型的对象， 这个ArrayList类并非java.util.ArrayList类，而是Arrays类的静态内部类！用这个对象对列表进行添加删除更新操作，就会报UnsupportedOperationException异常。</p><p>(2) ConcurrentHashMap使用segment来分段和管理锁，segment继承自ReentrantLock，因此ConcurrentHashMap使用ReentrantLock来保证线程安全。</p><p>(3)抽象类和接口都不能实例化；抽象类可以不包含抽象方法，但是包含了抽象方法一定要声明为抽象类；抽象类可以继承抽象类</p><p>(4) Spring Framework是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，Spring中包含的关键特性:<br>1.强大的基于JavaBeans的采用控制翻转（Inversion of Control，IoC）原则的配置管理，使得应用程序的组建更加快捷简易。<br>2.一个可用于从applet到Java EE等不同运行环境的核心Bean工厂。<br>数据库事务的一般化抽象层，允许声明式（Declarative）事务管理器，简化事务的划分使之与底层无关。<br>3.内建的针对JTA和单个JDBC数据源的一般化策略，使Spring的事务支持不要求Java EE环境，这与一般的JTA或者EJB CMT相反。<br>4.JDBC 抽象层提供了有针对性的异常等级（不再从SQL异常中提取原始代码），简化了错误处理，大大减少了程序员的编码量。再次利用JDBC时，你无需再写出另一个’终止’（finally）模块。并且面向JDBC的异常与Spring通用数据访问对象（Data Access Object）异常等级相一致。<br>5.以资源容器，DAO实现和事务策略等形式与Hibernate，JDO和iBATIS SQL Maps集成。利用众多的翻转控制方便特性来全面支持，解决了许多典型的Hibernate集成问题。所有这些全部遵从Spring通用事务处理和通用数据访问对象异常等级规范。<br>6.灵活的基于核心Spring功能的MVC网页应用程序框架。开发者通过策略接口将拥有对该框架的高度控制，因而该框架将适应于多种呈现（View）技术，例如JSP、FreeMarker、Velocity、Tiles、iText以及POI。值得注意的是，Spring中间层可以轻易地结合于任何基于MVC框架的网页层，例如Struts、WebWork或Tapestry。<br>7.提供诸如事务管理等服务的面向方面编程框架。</p><p>另外，Spring并没有提供日志系统，我们需要使用AOP（面向方面编程）的方式，借助Spring与日志系统log4j实现我们自己的日志系统。</p><p>(5)SpringMVC的原理：<br>SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。<br>DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。<br>实现业务操作时在service层</p><p>(6) java8中，忽略内部接口的情况，不能用来修饰interface里的方法的有<br>private  protected</p><p>(7)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer s=new Integer(9);</span><br><span class="line">Integer t=new Integer(9);</span><br><span class="line">Long u=new Long(9);</span><br></pre></td></tr></table></figure><p>(s==t) ， s 是指向一个 9 的引用，而 t 也是一个指向 9 的引用，虽然都是指向 9 ，但却是指向不同的 9 ，即是两个不同的引用。因此 == 比较返回的是假。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(s.equals(t)) ， Integer 的 equals 方法如下：</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (obj instanceof Integer) &#123;</span><br><span class="line">            return value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        return false ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是 Integer 的实例且 value 值也相等的情况下返回真，其他返回假。<br>在这里， s 和 t 都是 Integer 类型且值都为 9 ，因此结果为真。</p><p>(s.equals(9)) , 在进行 equals 比较之前，会对 9 调用 Integer.valueOf 方法，进行自动装箱 , 由于 IntegerCache 中已经存在 9 ，所以，直接返回其引用，引用相同， equals 就自然相同了。所以结果为真</p><p>(s.equals( new Integer(9)) ，直接创建了一个新的 Integer 实例，但且值也为 9 ，所以，满足条件，返回真。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的Android</title>
      <link href="/2017/07/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Android/"/>
      <url>/2017/07/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Android/</url>
      <content type="html"><![CDATA[<h5 id="android的动画分为3种-具体如下所示：">Android的动画分为3种，具体如下所示：</h5><ul><li>帧动画：也就是我们说的 Frame 动画。 Frame 动画是一系列图片按照一定的顺序展示的过程，<br>和放电影的机制相似，它的原理是在一定的时间段内切换多张有细微差异的图片从而达到动画的<br>效果。由于是一帧一帧加载，所以需要较多的图片。从而增大 APK 的大小，不过 Frame 动画<br>可以实现一些比较难的效果，例如：等待的环形进度。所涉及到的Java对象有：AnimationDrawable。<a id="more"></a></li><li>补间动画：也就是 Tween 动画，是操作某一个控件让其展现出旋转、渐变、移动、缩放的一种转换<br>过程。是一种视觉上的变化，不是真正位置上的变化。只能运用在 View 对象上，并且功能相对来说<br>较为局限。例如：旋转动画只能够在 x 、y 轴进行，而不能在z 轴放心进行旋转。因此，补间动画<br>通常用于执行一些比较简单的动画。所涉及到的Java对象有：AlphaAnimation（渐变动画）、<br>ScaleAnimation（缩放动画）、TranslateAnimation（位移动画）、RotateAnimation（旋转动画）。</li><li>属性动画：是 Android 3.0 之后推出的，其机制不再是针对 View 来设计的，也不限于只能实现<br>移动、缩放、旋转和淡入这几种简单的动画操作，同时也不再只是一种视觉上的动画效果。属性动画<br>实际上是一种在一定时间段内不断修改某个对象的某个属性值的机制。所涉及到的Java对象有：<br>ValueAnimator、ObjectAnimator。</li></ul><h5 id="apk程序的两种模式：-调试模式-debug-mode-和发布模式-release-mode">APK程序的两种模式：　调试模式(debug mode)和发布模式(release mode)</h5><ol><li>调试模式(debug mode) ：在调试模式下， ADT会自动的使用debug密钥为应用程序签名，因此我们可以直接运行程序。</li><li>发布模式(release mode)：当要发布程序时，开发者就需要使用自己的数字证书给apk包签名</li></ol><hr><p>ContentResolver和 ContentProvider是一对。一个运行在提供数据端(provider),一个运行在调用端(resolver)。使用的时候利用resolver来调用provider的方法(query,insert,update等)，然后provider再进行数据查询</p><hr><p>在android 中主线程是ui线程一切的界面操作都是在主线中完成的，如果在非主线程中操作ui将会报错。<br>B 同时执行多个AsyncTask默认是串行执行的。<br>C AsyncTask必须在UI线程中创建。<br>D 内部默认的线程是由 SerialExecutor创建 。</p><hr><ol><li>BroadcastReceiver 是对发送出来的广播进行过滤接收并响应的一类组件</li><li>每次广播被接收后会重新创建BroadcastReceiver对象，并在onReceiver方法中执行完时销毁</li><li>定义广播接收器类需要继承BroadcastReceiver基类，并且必须要重写onReceive()方法</li></ol><hr><p>NotificationManager 清除消息的方法是:cancel,cancelAll</p><hr><ol><li>应用运行时，Main线程进行了耗时操作  产生ANR，程序没有响应，有可能程序会再次响应</li><li>应用运行时抛出了OutOfMemoryError  程序抛出异常，会强制退出</li><li>应用运行时抛出了RuntimeException  程序抛出异常，会强制退出</li><li>应用运行时，用户操作过于频繁  产生ANR，程序没有响应，有可能程序会再次响应</li></ol><hr><p>在Android中，如果需要对数据进行存储，则可以使用（ ）方式<br>sharedpreference  \数据库\文件\Content Provider</p><hr><p>A. Message提供了消息池，有静态方法Obtain从消息池中取对象；<br>B. Thread默认不提供资源池，除非使用线程池ThreadPool管理；<br>C. AsynTask是线程池改造的，池里 默认提供（核数+1）个线程进行并发操作，最大支持（核数  * 2 + 1）个线程，超过后会丢弃其他任务；<br>D. Looper，每个Looper创建时创建一个消息队列和线程对象，也不是资源池；</p><hr><p>下面关于Android中定义style和theme的描述正确的是？<br>style可以作用在Activity上<br>官方解释：A style is a collection of properties that specify the look and format for a View or window<br>A theme is a style applied to an entire Activity or application<br>补充一句：style和theme本质上就是同一个东西，xml格式完全相同，只是我用在activity上我就叫他theme，我用在view上我就叫他style。唯一的区别就是style里头控制的各个属性了，某些属性是只有针对Activity才能生效的（你view有标题栏嘛有状态栏有导航栏吗嘛？但是反过来Activity内部却有一个继承自View的Decorview） 。所以style可以作用在activity上，但是theme却不能反过来作用在view上</p><hr><p>在Tween动画下，下面哪个方法可以构建一个渐变尺寸伸缩动画</p><ul><li>AlphaAnimation 透明度渐变</li><li>ScaleAnimation 透明度渐变</li><li>TranslateAnimation 坐标变化</li><li>RotateAnimation 旋转变换</li></ul><hr><p>前台进程是Android系统中最重要的进程，在Andriod系统中包含</p><ul><li>Activity正在与用户进行交互</li><li>进程服务正在执行声明中的回调函数</li><li>进程的BroadCastRecevier在执行onRecevie()函数</li></ul><p>activity被遮挡时属于可见进程，可见进程的优先级在前台进程之下。</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试干货分享</title>
      <link href="/2017/07/06/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2017/07/06/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<ol><li>Switch 能否用String做参数<br>在 Java 7 之前， switch 只能支持 byte 、 short 、 char 、 int 或者其对应的<br>封装类以及 Enum 类型。在 Java 7 中， String 支持被加上了。<br>关于java中的枚举类型（<a href="https://blog.csdn.net/wgw335363240/article/details/6359614%EF%BC%89" target="_blank" rel="noopener">https://blog.csdn.net/wgw335363240/article/details/6359614）</a></li><li>equals与==的区别：<br>“==”是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存<br>空间的值是不是相同</li></ol><a id="more"></a><ol start="3"><li>Object有哪些公用的方法</li></ol><ul><li>方法equals测试的是两个对象是否相等</li><li>方法clone进行对象拷贝</li><li>方法getClass返回和当前对象相关的Class对象</li><li>方法notify,notifyall,wait都是用来对给定对象进行线程同步的</li></ul><ol start="4"><li>实际开发中软引用或者弱引用的使用场景：<br>利用软引用和弱引用解决OOM问题：<br>用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系,在内存不足时,JVM会自动回收这些缓存图片对象所占用的空间,从而有效地避免了OOM的问题通过软可及对象重获方法实现Java对象的高速缓存:比如我们创建了一Employee的类,如果每次需要查询一个雇员的信息。哪怕是几秒中之前刚刚查询过的,都要重新构建一个实例，这是需要消耗很多时间的。我们可以通过软引用和HashMap的结合，先是保存引用方面：以软引用的方式对一个Employee对象的实例进行引用并保存该引用到HashMap 上，key 为此雇员的 id,value为这个对象的软引用,另一方面是取出引用,缓存中是否有该Employee实例的软引用,如果有,从软引用中取得。如果没有软引用,或者从软引用中得到的实例是null,重新构建一个实例,并保存对这个新建实例，并保存对这个新建实例的软引用</li><li>Hashcode的作用，与 equal 有什么区别：<br>同样用于鉴定2个对象是否相等的，java集合中有 list 和 set 两类，其中 set不允许元素重复实现，那个这个不允许重复实现的方法，如果用 equal 去比较的话，如果存在1000个元素，你 new 一个新的元素出来，需要去调用1000次 equal 去逐个和他们比较是否是同一个对象，这样会大大降低效率。hashcode实际上是返回对象的存储地址，如果这个位置上没有元素，就把元素直接存储在上面，如果这个位置上已经存在元素，这个时候才去调用equal方法与新元素进行比较，相同的话就不存了，散列到其他地址上</li><li>String、StringBuffer与StringBuilder的区别<br>String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象 StringBuffer和StringBuilder底层是 char[]数组实现的 StringBuffer是线程安全的，而StringBuilder是线程不安全的</li><li>Override和Overload的含义区别<br>Overload顾名思义是重新加载，它可以表现类的多态性，可以是函数里面可以有相同的函数名但是参数名、返回值、类型不能相同；或者说可以改变参数、类型、返回值但是函数名字依然不变。 Override顾名思义就是ride(重写)的意思，在子类继承父类的时候子类中可以定义某方法与其父类有相同的名称和参数，当子类在调用这一函数时自动调用子类的方法，而父类相当于被覆盖（重写）了。</li><li>抽象类和接口的区别<br>一个类只能继承单个类，但是可以实现多个接口 接口强调特定功能的实现，而抽象类强调所属关系 抽象类中的所有方法并不一定要是抽象的，你可以选择在抽象类中实现一些基本的方法。而接口要求所有的方法都必须是抽象的</li><li>解析XML的几种方式的原理与特点：DOM、SAX、PULL</li></ol><ul><li>DOM：消耗内存：先把xml文档都读到内存中，然后再用DOM API来访问树形结构，并获取数据。这个写起来很简单，但是很消耗内存。要是数据过大，手机不够牛逼，可能手机直接死机</li><li>SAX：解析效率高，占用内存少，基于事件驱动的：更加简单地说就是对文档进行顺序扫描，当扫描到文档(document)开始与结束、元素(element)开始与结束、文档(document)结束等地方时通知事件处理函数，由事件处理函数做相应动作，然后继续同样的扫描，直至文档结束。</li><li>SAX：与 SAX 类似，也是基于事件驱动，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。</li></ul><ol start="10"><li>wait()和sleep()的区别</li></ol><ul><li>sleep来自Thread类，和wait来自Object类</li><li>调用sleep()方法的过程中，线程不会释放对象锁。而 调用 wait 方法线程会释放对象锁</li><li>sleep睡眠后不出让系统资源，wait让出系统资源其他线程可以占用CPU</li><li>sleep(milliseconds)需要指定一个睡眠时间，时间一到会自动唤醒</li></ul><ol start="11"><li>java 多态实现原理</li></ol><p>抽象的来讲，多态的意思就是同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现的原理是动态绑定，程序调用的方法在运行期才动态绑定，追溯源码可以发现，JVM 通过参数的自动转型来找到合适的办法。</p><ol start="12"><li>java 垃圾回收与内存分配策略</li></ol><p>12.1 垃圾回收是什么</p><p>就是释放那些不再持有引用的对象的内存</p><p>12.2 怎么判断一个对象是否需要收集？</p><ul><li>引用计数（最简单古老的方法）：指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程</li><li>对象引用遍历（现在大多数 jvm 使用的方法）：对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集</li><li>引用计数缺陷：引用计数无法解决循环引用问题：假设对象A，B都已经被实例化，让A=B,B=A,除此之外这两个对象再无任何引用，此时计数器的值就永远不可能为0，但是引用计数器无法通知gc回收他们</li></ul><p>12.3 Java的四种引用的区别</p><ul><li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM 也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象</li><li>软引用：在使用软引用时，如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li><li>弱引用：具有弱引用的对象拥有的生命周期更短暂。因为当 JVM 进行垃圾回收，一旦发现弱引用对象，无论当前内存空间是否充足，都会将弱引用回收。不过由于垃圾回收器是一个优先级较低的线程，所以并不一定能迅速发现弱引用对象</li><li>虚引用：顾名思义，就是形同虚设，如果一个对象仅持有虚引用，那么它相当于没有引用，在任何时候都可能被垃圾回收器回收。</li></ul><p>12.4 介绍垃圾回收机制</p><ul><li>标记回收法：遍历对象图并且记录可到达的对象，以便删除不可到达的对象，一般使用单线程工作并且可能产生内存碎片</li><li>标记-压缩回收法：前期与第一种方法相同，只是多了一步，将所有的存活对象压缩到内存的一端，这样内存碎片就可以合成一大块可再利用的内存区域，提高了内存利用率</li><li>复制回收法：把现有内存空间分成两部分，gc运行时，它把可到达对象复制到另一半空间，再清空正在使用的空间的全部对象。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。</li><li>分代回收发：把内存空间分为两个或者多个域，如年轻代和老年代，年轻代的特点是对象会很快被回收，因此在年轻代使用效率比较高的算法。当一个对象经过几次回收后依然存活，对象就会被放入称为老年的内存空间，老年代则采取标记-压缩算法</li></ul><p>12.5 JAVA 中堆和栈的区别</p><ul><li>基本数据类型比变量和对象的引用都是在栈分配的</li><li>堆内存用来存放由new创建的对象和数组</li><li>类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中</li><li>实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的&quot;物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存</li><li>局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放</li></ul><ol start="13"><li>Java 集合系列问题</li></ol><p>13.1 ArrayList、LinkedList、Vector的区别</p><ul><li>ArrayList 和Vector底层是采用数组方式存储数据，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差</li><li>LinkedList使用双向链表实现存储，随机存取比较慢</li><li>HashMap的底层源码实现：当我们往HashMap中put元素的时候，先根据key的hashCode重新计算hash值，根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</li><li>Fail-Fast机制:在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast机制。这一机制在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map</li></ul><p>13.2 HashMap和 HashTable 的区别<br>HashTable比较老，是基于Dictionary 类实现的，HashTable 则是基于 Map接口实现的 HashTable 是线程安全的， HashMap 则是线程不安全的 HashMap可以让你将空值作为一个表的条目的key或value</p><ol start="14"><li>什么是反射，在哪里需要用到</li><li>什么是线程池，线程池的作用是什么</li></ol><p>1.答：线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多(未死亡)的线程，池中线程执行调度由池管理器来处理。当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。就好比原来去食堂打饭是每个人看谁抢的赢，谁先抢到谁先吃，有了线程吃之后，就是排好队形，今天我跟你关系好，你先来吃饭。比如：一个应用要和网络打交道，有很多步骤需要访问网络，为了不阻塞主线程，每个步骤都创建个线程，在线程中和网络交互，用线程池就变的简单，线程池是对线程的一种封装，让线程用起来更加简便，只需要创一个线程池，把这些步骤像任务一样放进线程池，在程序销毁时只要调用线程池的销毁函数即可。</p><p>单个线程的弊端：a. 每次new Thread新建对象性能差b. 线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或者OOM,c. 缺乏更多功能，如定时执行、定期执行、线程中断。</p><p>java提供的四种线程池的好处在于：a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。c. 提供定时执行、定期执行、单线程、并发数控制等功能。</p><p>2.Java线程池</p><p>Java通过Executors提供四种线程池，分别为：<br>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p><p>(1). newCachedThreadPool</p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><p>(2). newFixedThreadPool</p><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>(3) newScheduledThreadPool</p><p>创建一个定长线程池，支持定时及周期性任务执行。ScheduledExecutorService比Timer更安全，功能更强大</p><p>(4) newSingleThreadExecutor</p><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><h4 id="android部分-重点部分">Android部分（重点部分）</h4><h6 id="1-activity系列问题">1. Activity系列问题</h6><p>1.1 Activity生命周期流图</p><p><img src="../images/activity.jpg" alt=" activity"></p><p>1.2 介绍下不同场景下Activity生命周期的变化过程</p><ul><li>启动Activity： onCreate()—&gt;onStart()—&gt;onResume()，Activity进入运行状态。</li><li>Activity退居后台： 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&gt;onStop()，进入停滞状态。</li><li>Activity返回前台： onRestart()—&gt;onStart()—&gt;onResume()，再次回到运行状态。</li><li>Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity，若再次回到这个Activity,则会走onCreate()–&gt;onStart()—&gt;onResume()</li><li>锁定屏与解锁屏幕 只会调用onPause()，而不会调用onStop方法，开屏后则调用onResume()</li></ul><p>1.3 内存不足时系统会杀掉后台的Activity，若需要进行一些临时状态的保存，在哪个方法进行？</p><p>Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。除非该activity是被用户主动销毁的，通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。</p><p>1.4 onSaveInstanceState()被执行的场景有哪些：</p><p>系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统都会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则</p><ul><li><p>当用户按下HOME键时</p></li><li><p>长按HOME键，选择运行其他的程序时</p></li><li><p>锁屏时</p></li><li><p>从activity A中启动一个新的activity时</p></li><li><p>屏幕方向切换时</p></li></ul><p>1.5  介绍Activity的几中启动模式，并简单说说自己的理解或者使用场景</p><h6 id="2-service系列问题">2. Service系列问题</h6><p>2.1 注册Service需要注意什么</p><p>Service还是运行在主线程当中的，所以如果需要执行一些复杂的逻辑操作，最好在服务的内部手动创建子线程进行处理，否则会出现UI线程被阻塞的问题</p><p>2.2 Service与Activity怎么实现通信</p><p>方法一：</p><ul><li>添加一个继承Binder的内部类，并添加相应的逻辑方法</li><li>重写Service的onBind方法，返回我们刚刚定义的那个内部类实例</li><li>Activity中创建一个ServiceConnection的匿名内部类，并且重写里面的onServiceConnected方法和onServiceDisconnected方法，这两个方法分别会在活动与服务成功绑定以及解除绑定的时候调用，在onServiceConnected方法中，我们可以得到一个刚才那个service的binder对象，通过对这个binder对象进行向下转型，得到我们那个自定义的Binder实例，有了这个实例，做可以调用这个实例里面的具体方法进行需要的操作了</li></ul><p>方法二：</p><p>通过BroadCast(广播)的形式 当我们的进度发生变化的时候我们发送一条广播，然后在Activity的注册广播接收器，接收到广播之后更新视图</p><p>2.3 介绍源码中binder机制</p><p>2.4 IntentService与Service的区别</p><p>IntentService是Service的子类，是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</p><ul><li>会创建独立的worker线程来处理所有的Intent请求；</li><li>会创建独立的worker线程来处理onHandleIntent()方法实现的代码，无需处理多线程问题；</li><li>所有请求处理完成后，IntentService会自动停止，无需调用stopSelf()方法停止Service；</li><li>为Service的onBind()提供默认实现，返回null；</li><li>为Service的onStartCommand提供默认实现，将请求Intent添加到队列中；</li><li>IntentService不会阻塞UI线程，而普通Serveice会导致ANR异常</li><li>ntentservice若未执行完成上一次的任务，将不会新开一个线程，是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用stopSelf()</li></ul><h6 id="3-handle系列问题">3. Handle系列问题</h6><p>3.1 介绍Handle的机制</p><ul><li>Handler通过调用sendmessage方法把消息放在消息队列MessageQueue中，Looper负责把消息从消息队列中取出来，重新再交给Handler进行处理，三者形成一个循环</li><li>通过构建一个消息队列，把所有的Message进行统一的管理，当Message不用了，并不作为垃圾回收，而是放入消息队列中，供下次handler创建消息时候使用，提高了消息对象的复用，减少系统垃圾回收的次数</li><li>每一个线程，都会单独对应的一个looper，这个looper通过ThreadLocal来创建，保证每个线程只创建一个looper，looper初始化后就会调用looper.loop创建一个MessageQueue，这个方法在UI线程初始化的时候就会完成，我们不需要手动创建</li></ul><p>3.2 谈谈对HandlerThread的理解</p><h6 id="listview系列问题">ListView系列问题</h6><p>4.1 ListView卡顿的原因与性能优化，越多越好</p><ul><li>重用converView： 通过复用converview来减少不必要的view的创建，另外Infalte操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。</li><li>减少findViewById()操作： 将xml文件中的元素封装成viewholder静态类，通过converview的setTag和getTag方法将view与相应的holder对象绑定在一起，避免不必要的findviewbyid操作</li><li>避免在 getView 方法中做耗时的操作: 例如加载本地 Image 需要载入内存以及解析 Bitmap ，都是比较耗时的操作，如果用户快速滑动listview，会因为getview逻辑过于复杂耗时而造成滑动卡顿现象。用户滑动时候不要加载图片，待滑动完成再加载，可以使用这个第三方库glide</li><li>Item的布局层次结构尽量简单，避免布局太深或者不必要的重绘</li><li>尽量能保证 Adapter 的 hasStableIds() 返回 true 这样在 notifyDataSetChanged() 的时候，如果item内容并没有变化，ListView 将不会重新绘制这个 View，达到优化的目的</li><li>在一些场景中，ScollView内会包含多个ListView，可以把listview的高度写死固定下来。由于ScollView在快速滑动过程中需要大量计算每一个listview的高度，阻塞了UI线程导致卡顿现象出现，如果我们每一个item的高度都是均匀的，可以通过计算把listview的高度确定下来，避免卡顿现象出现</li><li>使用 RecycleView 代替listview：每个item内容的变动，listview都需要去调用notifyDataSetChanged来更新全部的item，太浪费性能了。RecycleView可以实现当个item的局部刷新，并且引入了增加和删除的动态效果，在性能上和定制上都有很大的改善</li><li>ListView 中元素避免半透明： 半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在比较差的机子上会比较卡。 在设计上能不半透明就不不半透明。实在要弄就把在滑动的时候把半透明设置成不透明，滑动完再重新设置成半透明。</li><li>尽量开启硬件加速： 硬件加速提升巨大，避免使用一些不支持的函数导致含泪关闭某个地方的硬件加速。当然这一条不只是对 ListView。</li></ul><p>4.2 怎么实现一个部分更新的 ListView？</p><p>4.3 怎么实现ListView多种布局？</p><p>4.4 ListView与数据库绑定的实现</p><h6 id="5-jni系列问题">5. JNI系列问题</h6><p>5.1 如何使用JNI</p><ol><li><p>JAVA中声明native 方法如private native String printJNI(String inputStr);</p></li><li><p>使用javah工具生成.h头文件这时候头文件中就会自动生成对应的函数JNIEXPORT jstring JNICALL Java_com_wenming_HelloWorld_printJNI</p></li><li><p>实现JNI原生函数源文件，新建HelloWorld.c文件，对刚才自动生成的函数进行具体的逻辑书写，例如返回一个java叫做HelloWorld的字符串等</p></li><li><p>编译生成动态链接so文件**</p></li><li><p>Java中调用Sysytem.load方法把刚才的so库加载进来，就可以调用native方法了</p></li></ol><p>5.2 如何通过JNI传递String对象</p><p>Java的String和C++的string是不能对等起来的，所以当我们拿到.h文件下面的jstring对象，会做一次转换我们把jstring转换为C下面的char*类型， 获取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">constchar* str;</span><br><span class="line">str = env-&gt;GetStringUTFChars(prompt,false);</span><br></pre></td></tr></table></figure><p>赋予值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char* tmpstr =&quot;return string succeeded&quot;;</span><br><span class="line">jstring rtstr = env-&gt;NewStringUTF(tmpstr);</span><br></pre></td></tr></table></figure><h6 id="6-oom系列问题">6.OOM系列问题</h6><p>6.1 什么OOM？</p><p>OOM全称是Out Of Merrory，Android系统的每一个应用程序都设置一个硬性的Dalvik Heap Size最大限制阈值，如果申请的内存资源超过这个限制，系统就会抛出OOM错误</p><p>6.2 内存泄漏有哪些场景以及解决方法</p><ul><li><p>类的静态变量持有大数据对象 静态变量长期维持到大数据对象的引用，阻止垃圾回收。</p></li><li><p>非静态内部类存在静态实例 非静态内部类会维持一个到外部类实例的引用，如果非静态内部类的实例是静态的，就会间接长期维持着外部类的引用，阻止被回收掉。</p></li><li><p>资源对象未关闭 资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。 如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄露。 解决办法： 比如SQLiteCursor（在析构函数finalize（）,如果我们没有关闭它，它自己会调close()关闭）， 如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。 因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null. 在我们的程序退出时一定要确保我们的资源性对象已经关闭。程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险，记得try catch后，在finally方法中关闭连接</p></li><li><p>Handler内存泄漏  Handler作为内部类存在于Activity中，但是Handler生命周期与Activity生命周期往往并不是相同的，比如当Handler对象有Message在排队，则无法释放，进而导致本该释放的Acitivity也没有办法进行回收。 解决办法：</p></li><li><p>声明handler为static类，这样内部类就不再持有外部类的引用了，就不会阻塞Activity的释放</p></li><li><p>如果内部类实在需要用到外部类的对象，可在其内部声明一个弱引用引用外部类。</p></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> public class MainActivity extends Activity &#123;</span><br><span class="line">  private CustomHandler mHandler;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">      super.onCreate(savedInstanceState);</span><br><span class="line">      mHandler = new CustomHandler(this);</span><br><span class="line">  &#125;</span><br><span class="line">  static class CustomHandlerextends Handler &#123;</span><br><span class="line">     // 内部声明一个弱引用，引用外部类</span><br><span class="line">     private WeakReference&lt;MainActivity &gt; activityWeakReference;</span><br><span class="line">     public MyHandler(MyActivity activity) &#123;</span><br><span class="line">         activityWeakReference= new WeakReference&lt;MainActivity &gt;(activity);</span><br><span class="line">     &#125;</span><br><span class="line">             // ... ...   </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">public void onDestroy() &#123;</span><br><span class="line"> //  If null, all callbacks and messages will be removed.</span><br><span class="line"> mHandler.removeCallbacksAndMessages(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一些不良代码习惯 有些代码并不造成内存泄露，但是他们的资源没有得到重用，频繁的申请内存和销毁内存，消耗CPU资源的同时，也引起内存抖动 解决方案 如果需要频繁的申请内存对象和和释放对象，可以考虑使用对象池来增加对象的复用。 例如ListView便是采用这种思想，通过复用converview来避免频繁的GC</li></ul><p>6.2 如何避免 OOM 问题的出现</p><ol><li>使用更加轻量的数据结构 例如，我们可以考虑使用ArrayMap/SparseArray而不是HashMap等传统数据结构。通常的HashMap的实现方式更加消耗内存，因为它需要一个额外的实例对象来记录Mapping操作。另外，SparseArray更加高效，在于他们避免了对key与value的自动装箱（autoboxing），并且避免了装箱后的解箱。</li><li>避免在Android里面使用Enum Android官方培训课程提到过“Enums often require more than twice as muchmemory as static constants. You should strictly avoid using enums on Android.”，具体原理请参考《Android性能优化典范（三）》，所以请避免在Android里面使用到枚举。</li><li>减小Bitmap对象的内存占用 Bitmap是一个极容易消耗内存的大胖子，减小创建出来的Bitmap的内存占用可谓是重中之重，，通常来说有以下2个措施： inSampleSize：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。 decode format：解码格式，选择ARGB_6666/RBG_545/ARGB_4444/ALPHA_6，存在很大差异</li><li>Bitmap对象的复用 缩小Bitmap的同时，也需要提高BitMap对象的复用率，避免频繁创建BitMap对象，复用的方法有以下2个措施 LRUCache :“最近最少使用算法”在Android中有极其普遍的应用。ListView与GridView等显示大量图片的控件里，就是使用LRU的机制来缓存处理好的Bitmap，把近期最少使用的数据从缓存中移除，保留使用最频繁的数据， inBitMap高级特性:利用inBitmap的高级特性提高Android系统在Bitmap分配与释放执行效率。使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小</li><li>使用更小的图片 在涉及给到资源图片时，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用更小的图片。尽量使用更小的图片不仅可以减少内存的使用，还能避免出现大量的InflationException。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图时会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</li><li>StringBuilder 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</li><li>避免在onDraw方法里面执行对象的创建 类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</li><li>避免对象的内存泄露 android中内存泄漏的场景以及解决办法，参考上一问</li></ol><h6 id="7-anr-系列问题">7. ANR 系列问题</h6><p>7.1 什么ANR</p><p>ANR全称Application Not Responding，意思就是程序未响应。如果一个应用无法响应用户的输入，系统就会弹出一个ANR对话框，用户可以自行选择继续等待亦或者是停止当前程序。一旦出现下面两种情况，则弹出ANR对话框</p><ul><li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li><li>BroadcastReceiver未在10秒内完成相关的处理</li></ul><p>7.2 ANR是怎么引起的？</p><ul><li>主线程中存在耗时的计算-\</li><li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li><li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等</li></ul><p>7.3 如何避免ANR问题的出现</p><p>基本思路就是把一些耗时操作放到子线程中处理</p><ul><li>使用AsyncTask处理耗时IO操作。</li><li>降低子线程优先级使用Thread或者HandlerThread时，调用Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同.</li><li>使用Handler处理子线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li><li>Activity的onCreate和onResume回调中尽量避免耗时的代码</li><li>BroadcastReceiver中onReceive代码也要尽量减少耗时操作建议使用IntentService处理。IntentService是一个异步的，会自动停止的服务，很好解决了传统的Service中处理完耗时操作忘记停止并销毁Service的问题</li></ul><h6 id="8-asynctask问题">8. Asynctask问题</h6><p>8.1 AsynTask为什么要设计为只能够一次任务？</p><p>最核心的还是线程安全问题，多个子线程同时运行，会产生状态不一致的问题。所以要务必保证只能够执行一次</p><p>8.2 AsynTask造成的内存泄露的问题怎么解决，》比如非静态内部类AsynTask会隐式地持有外部类的引用，如果其生命周期大于外部activity的生命周期，就会出现内存泄漏</p><ul><li>注意要复写AsynTask的onCancel方法，把里面的socket，file等，该关掉的要及时关掉</li><li>在 Activity 的onDestory()方法中调用Asyntask.cancal方法</li><li>Asyntask内部使用弱引用的方式来持有Activity</li></ul><p>8.3 若Activity已经销毁，此时AsynTask执行完并且返回结果，会报异常吗?</p><p>当一个App旋转时，整个Activity会被销毁和重建。当Activity重启时，AsyncTask中对该Activity的引用是无效的，因此onPostExecute()就不会起作用，若AsynTask正在执行，折会报 view not attached to window manager 异常</p><p>同样也是生命周期的问题，在 Activity 的onDestory()方法中调用Asyntask.cancal方法，让二者的生命周期同步</p><p>8.4 Activity销毁但Task如果没有销毁掉，当Activity重启时这个AsyncTask该如何解决？</p><p>还是屏幕旋转这个例子，在重建Activity的时候，会回掉Activity.onRetainNonConfigurationInstance()重新传递一个新的对象给AsyncTask，完成引用的更新</p><h6 id="9-android触摸分发机制">9. Android触摸分发机制</h6><p>9.1 介绍触摸事件的分发机制</p><p><img src="../images/touch.jpg" alt="touch"></p><p>(1) 事件从Activity.dispatchTouchEvent()开始传递，只要没有被停止或拦截，从最上层的View(ViewGroup)开始一直往下(子View)传递。子View可以通过onTouchEvent()对事件进行处理。</p><p>(2) 事件由父View(ViewGroup)传递给子View，ViewGroup可以通过onInterceptTouchEvent()对事件做拦截，停止其往下传递。</p><p>(3) 如果事件从上往下传递过程中一直没有被停止，且最底层子View没有消费事件，事件会反向往上传递，这时父View(ViewGroup)可以进行消费，如果还是没有被消费的话，最后会到Activity的onTouchEvent()函数。</p><p>(4) 如果View没有对ACTION_DOWN进行消费，之后的其他事件不会传递过来。</p><p>(5) OnTouchListener优先于onTouchEvent()对事件进行消费。</p><p>上面的消费即表示相应函数返回值为true。</p><p>9.2 View中 setOnTouchListener的onTouch，onTouchEvent，onClick的执行顺序</p><p>追溯到View的dispatchTouchEvent源码查看，有这么一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">        if (!onFilterTouchEventForSecurity(event)) &#123;  </span><br><span class="line">            return false;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp;  mOnTouchListener.onTouch(this, event)) &#123;  </span><br><span class="line">            return true;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return onTouchEvent(event);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当以下三个条件任意一个不成立时，</p><ul><li>mOnTouchListener不为null</li><li>view是enable的状态</li><li>mOnTouchListener.onTouch(this, event)返回true，</li></ul><p>函数会执行到onTouchEvent。在这里我们可以看到，首先执行的是mOnTouchListener.onTouch的方法，然后是onTouchEvent方法</p><p>继续追溯源码，到onTouchEvent()观察，发现在处理ACTION_UP事件里有这么一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!post(mPerformClick)) &#123;  </span><br><span class="line">                                    performClick();  </span><br><span class="line">                                &#125;</span><br></pre></td></tr></table></figure><p>此时可知，onClick方法也在最后得到了执行</p><p>所以三者的顺序是：</p><ol><li>setOnTouchListener() 的onTouch</li><li>onTouchEvent()</li><li>onClick()</li></ol><h6 id="10-dalvik虚拟机系列问题">10. Dalvik虚拟机系列问题</h6><p>10.1  什么是Dalvik虚拟机？</p><p>Dalvik虚拟机是Android平台的核心。它可以支持.dex格式的程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，可以减少整体文件尺寸，提高I/O操作的速度，适合内存和处理器速度有限的系统。</p><p>10.2  Dalvik虚拟机的作用是什么？</p><p>Dalvik虚拟机主要是完成对象生命周期管理，内存回收，堆栈管理，线程管理，安全和异常管理等等重要功能。</p><p>10.3 Dalvik虚拟机与JVM有什么区别</p><ul><li>Dalvik 基于寄存器，而 JVM 基于栈。基于寄存器的虚拟机对于更大的程序来说，在它们编译的时候，花费的时间更短。</li><li>Dalvik执行.dex格式的字节码，而JVM执行.class格式的字节码。</li></ul><p>10.4 每个应用程序对应多少个Dalvik虚拟机</p><ul><li>每一个Android应用在底层都会对应一个独立的Dalvik虚拟机实例，其代码在虚拟机的解释下得以执行 ，而所有的Android应用的线程都对应一个Linux线程</li></ul><h6 id="11-注册广播接收器有哪几种方式-有什么区别">11.注册广播接收器有哪几种方式,有什么区别</h6><ul><li>静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理</li><li>动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了</li></ul><h6 id="12-显示intent与隐式intent的区别">12. 显示Intent与隐式Intent的区别</h6><p>对明确指出了目标组件名称的Intent，我们称之为“显式Intent”。 对于没有明确指出目标组件名称的Intent，则称之为“隐式 Intent”。</p><p>对于隐式意图，在定义Activity时，指定一个intent-filter，当一个隐式意图对象被一个意图过滤器进行匹配时，将有三个方面会被参考到：</p><ul><li>动作(Action)</li><li>类别(Category ['kætɪg(ə)rɪ] )</li><li>数据(Data )</li></ul><h6 id="13-android中的动画有哪些-区别是什么">13. Android中的动画有哪些，区别是什么</h6><ul><li>逐帧动画(Drawable Animation)：加载一系列Drawable资源来创建动画，简单来说就是播放一系列的图片来实现动画效果，可以自定义每张图片的持续时间</li><li>补间动画(Tween Animation)：Tween可以对View对象实现一系列简单的动画效果，比如位移，缩放，旋转，透明度等等。但是它并不会改变View属性的值，只是改变了View的绘制的位置，比如，一个按钮在动画过后，不在原来的位置，但是触发点击事件的仍然是原来的坐标。</li><li>属性动画(Property Animation)： 动画的对象除了传统的View对象，还可以是Object对象，动画结束后，Object对象的属性值被实实在在的改变了</li></ul><h6 id="14-不使用动画-怎么实现一个动态的-view？">14. 不使用动画，怎么实现一个动态的 View？</h6><h6 id="15-postvalidata与validata有什么区别？">15. Postvalidata与Validata有什么区别？</h6><h6 id="16-如何自定义viewgroup？">16. 如何自定义ViewGroup？</h6><h6 id="17-view的绘制流程">17. View的绘制流程</h6><p><img src="../images/view.png" alt="view"><br><br>measure()方法，layout()，draw()三个方法主要存放了一些标识符，来判断每个View是否需要再重新测量，布局或者绘制，主要的绘制过程还是在onMeasure，onLayout，onDraw这个三个方法中</p><ol><li>onMesarue() 为整个View树计算实际的大小，即设置实际的高(对应属性:mMeasuredHeight)和宽(对应属性: mMeasureWidth)，每个View的控件的实际宽高都是由父视图和本身视图决定的。</li><li>onLayout() 为将整个根据子视图的大小以及布局参数将View树放到合适的位置上。</li><li>onDraw() 开始绘制图像，绘制的流程如下<ol><li>首先绘制该View的背景</li><li>调用onDraw()方法绘制视图本身 (每个View都需要重载该方法，ViewGroup不需要实现该方法)</li><li>如果该View是ViewGroup，调用dispatchDraw ()方法绘制子视图</li><li>绘制滚动条</li></ol></li></ol><h6 id="18-数据持久化的四种方式有哪些？">18. 数据持久化的四种方式有哪些？</h6><ol><li>文件存储： 通过java.io.FileInputStream和java.io.FileOutputStream这两个类来实现对文件的读写，java.io.File类则用来构造一个具体指向某个文件或者文件夹的对象。</li><li>SharedPreferences： SharedPreferences是一种轻量级的数据存储机制，他将一些简单的数据类型的数据，包括boolean类型，int类型，float类型，long类型以及String类型的数据，以键值对的形式存储在应用程序的私有Preferences目录（/data/data/&lt;包名&gt;/shared_prefs/）中，这种Preferences机制广泛应用于存储应用程序中的配置信息。</li><li>SQLite数据库： 当应用程序需要处理的数据量比较大时，为了更加合理地存储、管理、查询数据，我们往往使用关系数据库来存储数据。Android系统的很多用户数据，如联系人信息，通话记录，短信息等，都是存储在SQLite数据库当中的，所以利用操作SQLite数据库的API可以同样方便的访问和修改这些数据。</li><li>ContentProvider: 主要用于在不同的应用程序之间实现数据共享的功能，不同于sharepreference和文件存储中的两种全局可读写操作模式，内容提供其可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险</li></ol><h6 id="19-fragement里面可以再嵌套fragment？">19. fragement里面可以再嵌套fragment？</h6><h6 id="20-socker编程的步骤">20. Socker编程的步骤</h6><h6 id="21-activity中如何动态的添加fragment">21. Activity中如何动态的添加Fragment</h6><h6 id="22-scrollview怎么判断是否滑倒底部">22. Scrollview怎么判断是否滑倒底部</h6><h6 id="23-什么是-mvc-模式？mvc-模式的好处是什么？">23. 什么是 MVC 模式？MVC 模式的好处是什么？</h6><h6 id="24-应用常驻后台-避免被第三方杀掉的方法-讲讲你用过的奇淫巧技？">24. 应用常驻后台，避免被第三方杀掉的方法，讲讲你用过的奇淫巧技？</h6><ol><li><p>Service设置成START_STICKY kill 后会被重启（等待5秒左右），重传Intent，保持与重启前一样</p></li><li><p>通过 startForeground将进程设置为前台进程， 做前台服务，优先级和前台应用一个级别​，除非在系统内存非常缺，否则此进程不会被 kill</p></li><li><p>双进程Service： 让2个进程互相保护**，其中一个Service被清理后，另外没被清理的进程可以立即重启进程</p></li><li><p>QQ黑科技: 在应用退到后台后，另起一个只有 1 像素的页面停留在桌面上，让自己保持前台状态，保护自己不被后台清理工具杀死</p></li><li><p>在已经root的设备下，修改相应的权限文件,将App伪装成系统级的应用 Android4.0系列的一个漏洞，已经确认可行</p></li><li><p>用C编写守护进程(即子进程) : Android系统中当前进程(Process)fork出来的子进程，被系统认为是两个不同的进程。当父进程被杀死的时候，子进程仍然可以存活，并不受影响。鉴于目前提到的在Android-&gt;- Service层做双守护都会失败，我们可以fork出c进程，多进程守护。死循环在那检查是否还存在，具体的思路如下（Android5.0以上的版本不可行）</p></li><li><p>用C编写守护进程(即子进程)，守护进程做的事情就是循环检查目标进程是否存在，不存在则启动它。</p></li><li><p>在NDK环境中将1中编写的C代码编译打包成可执行文件(BUILD_EXECUTABLE)。主进程启动时将守护进程放入私有目录下，赋予可执行权限，启动它即可。</p></li><li><p>联系厂商，加入白名单</p></li></ol><h6 id="25-context与applicationcontext的区别-分别用在什么情况下">25.Context与ApplicationContext的区别，分别用在什么情况下</h6><p>Application的Context是一个全局静态变量，SDK的说明是只有当你引用这个context的生命周期超过了当前activity的生命周期，而和整个应用的生命周期挂钩时，才去使用这个application的context。</p><p>在android中context可以作很多操作，但是最主要的功能是加载和访问资源。在android中有两种context，一种是 application context，一种是activity context，通常我们在各种类和方法间传递的是activity context。</p><h6 id="26-同一个应用程序的不同activity可以运行在不同的进程中么？如果可以-举例说明；">26. 同一个应用程序的不同Activity可以运行在不同的进程中么？如果可以，举例说明；</h6><h6 id="27-java中的线程同步有哪几种方式-举例说明；">27. Java中的线程同步有哪几种方式，举例说明；</h6><h6 id="28-dp-dip-dpi-px-sp是什么意思以及他们的换算公式？layout-sw400dp-layout-h400dp分别代表什么意思；">28. dp, dip, dpi, px, sp是什么意思以及他们的换算公式？layout-sw400dp, layout-h400dp分别代表什么意思；</h6><h6 id="29-如何让两个textview在一个relativelayout水平居中显示；">29. 如何让两个TextView在一个RelativeLayout水平居中显示；</h6><h6 id="30-如何画出一个印章的图案">30. 如何画出一个印章的图案</h6><h6 id="31-如何实现一个字体的描边与阴影效果">31. 如何实现一个字体的描边与阴影效果</h6><h6 id="32-设计一个从网络请求数据-图片-并加载到列表的系统-画出客户端架构并简单的分析下；">32. 设计一个从网络请求数据，图片，并加载到列表的系统，画出客户端架构并简单的分析下；</h6><h6 id="33-设计一个文件的断点续传系统">33. 设计一个文件的断点续传系统</h6><h6 id="34-设计一个图片缓存加载机制">34. 设计一个图片缓存加载机制</h6><p>数据结构与算法部分：</p><p>作者：闭关写代码<br>链接：<a href="https://www.nowcoder.com/discuss/3244" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/3244</a><br>来源：牛客网</p><ol><li>给最外层的rootview，把这个根视图下的全部button背景设置成红色，手写代码，不许用递归</li><li>给一串字符串比如abbbcccd，输出a1b3c3d1，手写代码（注意有个别字符可能会出现十次以上的情况）</li><li>一个序列，它的形式是12349678，9是最高峰，经历了一个上升又下降的过程，找出里面的最大值的位置，要求效率尽可能高</li><li>二叉查找树的删除操作，手写代码</li><li>反转链表，手写代码</li><li>二分查找，手写代码</li><li>有海量条 url，其中不重复的有300万条，现在希望挑选出重复出现次数最高的 url，要求效率尽可能的高</li><li>一篇英语文章，去掉字符只留下k个，如何去掉才能使这k个字符字典序最小</li><li>弗洛伊德算法和 Dijkstra算法的区别？复杂度是多少？讲讲 Dijkstra算法的具体过程</li><li>反转字符串，要求手写代码，优化速度、优化空间</li><li>给出两个无向图，找出这2个无向图中相同的环路。手写代码</li><li>单例模式，手写代码</li><li>生产者与消费者，手写代码</li><li>二叉树镜像，手写代码</li><li>最长不重复子串（最长重复子串），手写代码</li></ol><p>操作系统部分:</p><ol><li>分别从操作系统的内存角度与进程线程角度解释分析堆，栈二者的区别</li><li>什么是事务？</li><li>OSI七层模型有哪些，各层次的作用</li><li>TCP的三次握手过程，四次挥手过程，为什么需要三次？</li><li>说说操作系统中进程的通信方式</li><li>浏览器输入地址之后，之后的过程</li><li>谈谈 https 中Get 和 Post 方法的区别？</li></ol>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 牛客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring常用注解</title>
      <link href="/2017/07/03/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
      <url>/2017/07/03/Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="常用的是注解有如下几种：">常用的是注解有如下几种：</h3><p>@Controller<br><br>@Service<br><br>@Autowired<br><br>@RequestMapping<br><br>@RequestParam<br><br>@ModelAttribute<br></p><a id="more"></a><p>@Cacheable<br><br>@CacheFlush<br><br>@Resource<br><br>@PostConstruct<br><br>@PreDestroy<br><br>@Repository<br><br>@Component （不推荐使用）<br><br>@Scope<br><br>@SessionAttributes<br><br>@InitBinder<br><br>@Required<br><br>@Qualifier<br></p><h6 id="controller">@Controller</h6><ul><li>例如：@Controller<br><br>public class SoftCreateController extends SimpleBaseController {}</li><li>或者：@Controller<br><br>public class SoftCreateController extends SimpleBaseController {}</li><li>说明： @Controller<br><br>负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写</li></ul><h6 id="service">@Service</h6><p>• 例如：<br>@Service<br><br>public class SoftCreateServiceImpl implements ISoftCreateService {}</p><p>• 或者：<br><br>@Service(“softCreateServiceImpl”)</p><p>• 说明：<br><br>@Service 负责注册一个bean 到spring 上下文中，bean 的ID 默认为类名称开头字母小写</p><h6 id="autowired">@Autowired</h6><p>• 例如：<br>@Autowired<br>private ISoftPMService softPMService;</p><p>• 或者：</p><p>@Autowired(required=false)<br>private ISoftPMService softPMService = new SoftPMServiceImpl();</p><p>• 说明：</p><p>@Autowired 根据bean 类型从spring 上线文中进行查找，注册类型必须唯一，否则报异常。</p><p>与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种<br>方式进行查找@Autowired(required=false) 表示，如果spring 上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();</p><p>与@Resource 的区别在于，@Resource 允许通过bean 名称或bean 类型两种方式进行查找@Autowired(required=false) 表示，如果spring<br>上下文中没有找到该类型的bean 时， 才会使用new SoftPMServiceImpl();</p><p>@Autowired 还有一个作用就是，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、<br>ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。</p><h6 id="requestmapping">@RequestMapping</h6><p>• 类：</p><p>@Controller<br>@RequestMapping(&quot;/bbtForum.do&quot;) IT学习者（<a href="http://www.itxxz.com" target="_blank" rel="noopener">www.itxxz.com</a>）<br>public class BbtForumController {<br>@RequestMapping(params = “method=listBoardTopic”)<br>public String listBoardTopic(int topicId,User user) {}<br>}</p><p>• 方法：</p><p>@RequestMapping(&quot;/softpg/downSoftPg.do&quot;)<br>@RequestMapping(value=&quot;/softpg/ajaxLoadSoftId.do&quot;,method = POST)<br>@RequestMapping(value = “/osu/product/detail.do”, params = { “modify=false” }, method =POST)<br>• 说明：<br>@RequestMapping 可以声明到类或方法上</p><p>• 参数绑定说明<br>如果我们使用以下的 URL 请求：<br><a href="https://localhost/itxxzSpring4?method=listBoardTopic&amp;topicId=1&amp;userId=10&amp;userName=tom" target="_blank" rel="noopener">https://localhost/itxxzSpring4?method=listBoardTopic&amp;topicId=1&amp;userId=10&amp;userName=tom</a><br>topicId URL 参数将绑定到 topicId 入参上，而 userId 和 userName URL 参数将绑定到 user 对象的<br>userId 和 userName 属性中。和 URL 请求中不允许没有 topicId 参数不同，虽然 User 的 userId 属性的类型是基本数据类型，但如果 URL 中不存在 userId 参数，Spring 也不会报错，此时 user.userId 值为 0 。如果 User 对象拥有一个 dept.deptId 的级联属性，那么它将和 dept.deptId URL 参数绑定。</p><h6 id="resource">@Resource</h6><ul><li>例如：<br>@Resource<br>private DataSource dataSource; // inject the bean named ‘dataSource’</li><li>或者：<br>@Resource(name=“dataSource”)<br>@Resource(type=DataSource.class)</li><li>说明：<br>@Resource 默认按bean 的name 进行查找，如果没有找到会按type 进行查找，<br>此时与@Autowired 类 似.<br><br>在没有为 @Resource 注解显式指定 name 属性的前提下，如果将其标注在 BeanFactory 类型、ApplicationContext 类型、ResourceLoader 类型、ApplicationEventPublisher 类型、MessageSource 类型上，那么 Spring 会自动注入这些实现类的实例，不需要额外的操作。此时 name 属性不需要指定 ( 或者指定为&quot;&quot;)，否则注入失败；</li></ul><h6 id="scope">@Scope</h6><ul><li>例如<br>@Scope(“session”)<br>@Repository()<br>public class UserSessionBean implementsSerializable {}</li><li>说明</li></ul><p>在使用XML 定义Bean 时，可以通过bean 的scope 属性来定义一个Bean 的作用范围，<br>同样可以通过@Scope 注解来完成<br></p><p>@Scope中可以指定如下值：<br>singleton:定义bean的范围为每个spring容器一个实例（默认值）<br>prototype:定义bean可以被多次实例化（使用一次就创建一次）<br>request:定义bean的范围是https请求（springMVC中有效）<br>session:定义bean的范围是https会话（springMVC中有效）<br>global-session:定义bean的范围是全局https会话（portlet中有效）<br><br><br>小链接：ssm配置(<a href="https://www.cnblogs.com/youyefly/p/5685509.html" target="_blank" rel="noopener">https://www.cnblogs.com/youyefly/p/5685509.html</a>),<br>(<a href="https://blog.csdn.net/xuejian0616/article/details/52259335" target="_blank" rel="noopener">https://blog.csdn.net/xuejian0616/article/details/52259335</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javaweb </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Dao层、Service层、Controller层、View层</title>
      <link href="/2017/07/03/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E3%80%81Controller%E5%B1%82%E3%80%81View%E5%B1%82/"/>
      <url>/2017/07/03/Dao%E5%B1%82%E3%80%81Service%E5%B1%82%E3%80%81Controller%E5%B1%82%E3%80%81View%E5%B1%82/</url>
      <content type="html"><![CDATA[<ol><li>DAO层：DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</li><li>Service层：Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。</li></ol><a id="more"></a><ol start="3"><li>Controller层:Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。</li><li>View层 此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示</li><li>DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势，Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看作一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。<br></li><li>DAO设计的总体规划需要和设计的表，和实现类之间一一对应。</li><li>DAO层所定义的接口里的方法都大同小异，这是由我们在DAO层对数据库访问的操作来决定的，对数据库的操作，我们基本要用到的就是新增，更新，删除，查询等方法。因而DAO层里面基本上都应该要涵盖这些方法对应的操作。除此之外，可以定义一些自定义的特殊的对数据库访问的方法。</li><li>Service逻辑层设计</li><li>Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</li><li>在DAO层定义的一些方法，在Service层并没有使用，那为什么还要在DAO层进行定义呢？这是由我们定义的需求逻辑所决定的。DAO层的操作 经过抽象后基本上都是通用的，因而我们在定义DAO层的时候可以将相关的方法定义完毕，这样的好处是在对Service进行扩展的时候不需要再对DAO层进行修改，提高了程序的可扩展性。<br><br>小链接：ajax相关 (<a href="https://blog.csdn.net/cwj649956781/article/details/22414533" target="_blank" rel="noopener">https://blog.csdn.net/cwj649956781/article/details/22414533</a>)<br><br><br>(<a href="https://zhidao.baidu.com/question/745652997728018212.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/745652997728018212.html</a>)<br><br><br>(<a href="https://www.cnblogs.com/sdya/p/4624578.html" target="_blank" rel="noopener">https://www.cnblogs.com/sdya/p/4624578.html</a>)</li></ol>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javaweb </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>远方</title>
      <link href="/2017/06/24/%E8%BF%9C%E6%96%B9/"/>
      <url>/2017/06/24/%E8%BF%9C%E6%96%B9/</url>
      <content type="html"><![CDATA[<h3 id="热爱生命">《热爱生命》</h3><img src="http://qiniu.xueshiming.cn/%E8%BF%9C%E6%96%B9.jpg" width="600" hegiht="400" align="center"><p>我不去想是否能够成功<br>既然选择了远方<br>便只顾风雨兼程<br>我不去想能否赢得爱情<br>既然钟情于玫瑰<br>就勇敢地吐露真诚<br>我不去想身后会不会袭来寒风冷雨<br>既然目标是地平线<br>留给世界的只能是背影<br>我不去想未来是平坦还是泥泞<br>只要热爱生命<br>一切<br>都在意料之中</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ajax应用</title>
      <link href="/2017/04/03/Ajax%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/04/03/Ajax%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h6 id="一-ajax是什么-有什么作用？">一. ajax是什么，有什么作用？</h6><p>ajax分为同步请求和异步请求两种。<br>ajax的异步好处：用户在浏览网页同时点击一个ajax异步请求，这个时候用户无需等待、使用javascript脚本实现页面的动态局部刷新。<br>坏处就是post请求不能跨域，比如a.com请求b.com等<br>小链接：(<a href="https://blog.csdn.net/cwj649956781/article/details/22414533" target="_blank" rel="noopener">https://blog.csdn.net/cwj649956781/article/details/22414533</a>)</p><a id="more"></a><h6 id="二-ajax的使用-br">二.ajax的使用<br></h6><p>这里放一个小案例，仅供参考：<br>先导入包：【写到(/boday)的后面或(header)(/header)里都可以】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;jquery/jquery-3.1.1.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>下面的写到(body)与(/body)之间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=&quot;test()&quot;&gt;测试&lt;/button&gt;</span><br><span class="line">&lt;span id=&quot;a&quot;&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>下面这部分写到（/body）的后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function test()&#123;</span><br><span class="line">var count=&apos;&apos;;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">type:&quot;get&quot;, //写请求方式</span><br><span class="line">url: &quot;./findAllTicker&quot;,  //写要跳转页面的Url</span><br><span class="line">dataType:&quot;json&quot;,  //后台返回数据的格式为json</span><br><span class="line">async:true,  //true为异步请求</span><br><span class="line">success: function(map)&#123;  //map 为我自己写的接收后台返回的数据</span><br><span class="line">$(&quot;#a&quot;).html(map.count);  //在页面上输出数据</span><br><span class="line">//$(&quot;#a&quot;)[0].innerHTML=map.count;//在页面上输出数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h6 id="运行截图：">运行截图：</h6><p><img src="../images/ajax1.png" alt="ajax01"><br></p><p><img src="../images/ajax2.png" alt="ajax02"><br><br>小链接：(<a href="https://www.cnblogs.com/sdya/p/4624578.html" target="_blank" rel="noopener">https://www.cnblogs.com/sdya/p/4624578.html</a>)</p>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
