<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Ignite&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      你不知道的Java（三） | Ignite
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Ignite</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>你不知道的Java（三）</h2>
  <p class="post-date">2017-07-14</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>好几天的java基础知识都写在了前两篇里，感觉有些多和杂，今天再写新的一篇，每天做30道java的题目，感觉自己的基础知识就得好好巩固一下。</p>
<a id="more"></a>
<h5 id="java的跨平台特性"><a class="header-anchor" href="#java的跨平台特性">¶</a>java的跨平台特性</h5>
<p>我们编译好的文件是以.java后缀保存的，编译器会自动帮我们生成一个标准的.class字节码文件，JVM运行该文件。JVM也是一个软件，不同的系统平台JVM不同，但都可以实现标准的.class字节码文件。</p>
<h5 id="数据库事务的隔离级别"><a class="header-anchor" href="#数据库事务的隔离级别">¶</a>数据库事务的隔离级别</h5>
<p>4个。由低到高依次为Read uncommitted(未授权读取、读未提交)、Read committed（授权读取、读提交）、Repeatable read（可重复读取）、Serializable（序列化），这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题</p>
<pre><code>                     √: 可能出现    ×: 不会出现
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">脏读</th>
<th style="text-align:right">不可重复读</th>
<th style="text-align:right">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read uncommitted</td>
<td style="text-align:center">√</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>Read committed</td>
<td style="text-align:center">×</td>
<td style="text-align:right">√</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>Repeatable read</td>
<td style="text-align:center">×</td>
<td style="text-align:right">×</td>
<td style="text-align:right">√</td>
</tr>
<tr>
<td>Serializable</td>
<td style="text-align:center">×</td>
<td style="text-align:right">×</td>
<td style="text-align:right">×</td>
</tr>
</tbody>
</table>
<h5 id="关于instanceof"><a class="header-anchor" href="#关于instanceof">¶</a>关于instanceof</h5>
<p>instanceof 用来在运行时指出对象是否是特定类的一个实例，instanceof通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例</p>
<h5 id="异常"><a class="header-anchor" href="#异常">¶</a>异常</h5>
<p>checked exception：指的是编译时异常，该类异常需要本函数必须处理的，用try和catch处理，或者用throws抛出异常，然后交给调用者去处理异常。</p>
<p>runtime exception：指的是运行时异常，该类异常不必须本函数必须处理，当然也可以处理。<br>
Thread.sleep()抛出的InterruptException属于checked exception；IllegalArgumentException属于Runtime exception;</p>
<h5 id="java语言的下面几种数组复制方法中-哪个效率最高？"><a class="header-anchor" href="#java语言的下面几种数组复制方法中-哪个效率最高？">¶</a>java语言的下面几种数组复制方法中，哪个效率最高？</h5>
<p>效率：System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环<br>
A：for循环，效率最低，随便写个程序验证一下，效率慢的不是一点…我测试的时候比clone和System.arraycopy差了100多倍</p>
<p>B：System.arraycopy：原型是<br>
public static native void arraycopy(Object src,  int  srcPos , Object dest, int destPos, int length);</p>
<p>C：Arrays.copyOf底层调用了上面的System.copyOf效率比上面两个低。</p>
<p>D：clone()的完整定义：protected native Object clone() throws CloneNotSupportedException;</p>
<h5 id="java多线程的叙述正确的是"><a class="header-anchor" href="#java多线程的叙述正确的是">¶</a>JAVA多线程的叙述正确的是</h5>
<p>Callable类的call()方法可以返回值和抛出异常</p>
<p>#####　以下将打印出</p>
<blockquote>
<p>public static void main(String args[]) {<br>
List  Listlist1 = new ArrayList();<br>
Listlist1.add(0);<br>
List Listlist2 = Listlist1;<br>
System.out.println(Listlist1.get(0) instanceof Integer);<br>
System.out.println(Listlist2.get(0) instanceof Integer);<br>
}</p>
</blockquote>
<blockquote>
<p>true  true</p>
</blockquote>
<p>解析 :<br>
collection类型的集合（ArrayList,LinkedList）只能装入对象类型的数据，该题中装入了0，是一个基本类型，但是JDK5以后提供了自动装箱与自动拆箱，所以int类型自动装箱变为了Integer类型。编译能够正常通过。</p>
<p>将list1的引用赋值给了list2，那么list1和list2都将指向同一个堆内存空间。instanceof是Java中关键字，用于判断一个对象是否属于某个特定类的实例，并且返回boolean类型的返回值。显然，list1.get(0)和list2.get(0)</p>
<h5 id="如果希望监听tcp端口9000-应该怎样创建socket"><a class="header-anchor" href="#如果希望监听tcp端口9000-应该怎样创建socket">¶</a>如果希望监听TCP端口9000，应该怎样创建socket?</h5>
<blockquote>
<p>new ServerSocket(9000);</p>
</blockquote>
<h5 id="抽象类-abstract-class-和接口-interface-的区别"><a class="header-anchor" href="#抽象类-abstract-class-和接口-interface-的区别">¶</a>抽象类(abstract class)和接口(interface)的区别</h5>
<ol>
<li>含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。</li>
<li>接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。<br>
下面比较一下两者的语法区别：</li>
</ol>
<ul>
<li>抽象类可以有构造方法，接口中不能有构造方法</li>
<li>抽象类中可以有普通成员变量，接口中没有普通成员变量</li>
<li>抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。</li>
<li>抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。</li>
<li>抽象类中可以包含静态方法，接口中不能包含静态方法</li>
<li>抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。</li>
<li>一个类可以实现多个接口，但只能继承一个抽象类。</li>
</ul>
<p>接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，</p>
<p>例如，模板方法设计模式是抽象类的一个典型应用，假设某个项目的所有Servlet类都要用相同的方式进行权限判断、记录访问日志和处理异常，那么就可以定义一个抽象的基类，让所有的Servlet都继承这个抽象基类，在抽象基类的service方法中完成权限判断、记录访问日志和处理异常的代码，在各个子类中只是完成各自的业务逻辑代码.</p>
<h5 id="ant和maven"><a class="header-anchor" href="#ant和maven">¶</a>Ant和Maven</h5>
<p>Ant和Maven都是基于Java的构建(build)工具。理论上来说，有些类似于（Unix）C中的make ，但没有make的缺陷。Ant是软件构建工具，Maven的定位是软件项目管理和理解工具。</p>
<ol>
<li>Ant特点 <br>
没有一个约定的目录结构 必须明确让ant做什么，什么时候做，然后编译，打包 没有生命周期，必须定义目标及其实现的任务序列 没有集成依赖管理</li>
<li>Maven特点<br>
拥有约定，知道你的代码在哪里，放到哪里去 拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮你处理其他事情 拥有依赖管理，仓库管理</li>
</ol>
<h5 id="强制转换"><a class="header-anchor" href="#强制转换">¶</a>强制转换</h5>
<p>byte和short型在计算时会自动转换为int型计算，结果也是int 型<br>
低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte=char=short&lt;int&lt;long&lt;float&lt;double<br>
byte,short,char是同级别的，不能自动转换</p>
<h5 id="finally-关键字"><a class="header-anchor" href="#finally-关键字">¶</a>finally 关键字</h5>
<ol>
<li>选项在 final 定义的方法里，不是必须要用 final 定义变量。</li>
<li>final 定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化。</li>
<li>正确，final修饰方法，不能被子类重写，但是可以被重载。</li>
<li>final 定义变量，可以用 static</li>
</ol>
<p>final修饰的类不能被继承， final 修饰的方法不能被重写，final修饰的属性在第一次被赋值后不可再更改值。</p>
<h5 id="以下程序输出结果"><a class="header-anchor" href="#以下程序输出结果">¶</a>以下程序输出结果</h5>
<blockquote>
<p>class HasStatic{<br>
private static int x=100;<br>
public static void main (String args[]){<br>
HasStatic hs1=new HasStatic();<br>
hs1.x++;<br>
HasStatic hs2=new HasStatic();<br>
hs2.x++;<br>
hs1=new HasStatic();<br>
hs1.x++;<br>
HasStatic.x–;<br>
System.out.println(“x=” +x);<br>
}<br>
}</p>
</blockquote>
<p>因为x的 修饰符为 static 所以x为类变量，即对于所有的实例来说，他们访问的x为同一个x，类变量存储在方法区，不属于每个实例的私有，</p>
<p>刚开始x=100</p>
<p>调用hs1.x++   x为101;</p>
<p>调用hs2.x++   x为102;</p>
<p>调用hs1.x++   x为103 (此时hs1指向了一个新的HasStatic实例，但是依然访问的是同一个X)</p>
<p>调用HasStatic.x--  x为102</p>
<p>所以结果为D</p>
<h5 id="java-中的-wait-方法和-sleep-方法的区别"><a class="header-anchor" href="#java-中的-wait-方法和-sleep-方法的区别">¶</a>java 中的 wait()方法和 sleep()方法的区别</h5>
<ol>
<li>这两个方法来自不同的类分别是Thread和Object</li>
<li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得敏感词线程可以使用同步控制块或者方法。</li>
<li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在<br>
任何地方使用<br>
synchronized(x){<br>
x.notify()<br>
//或者wait()<br>
}</li>
<li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常</li>
</ol>
<h5 id="java-object类"><a class="header-anchor" href="#java-object类">¶</a>java Object类</h5>
<p>一共有11个： equals . getClass . hashCode . toString . notify .notifyAll .<br>
wait . finalize . clone</p>
<h5 id="一个小题"><a class="header-anchor" href="#一个小题">¶</a>一个小题</h5>
<blockquote>
<p>public class TestClass {<br>
private static void testMethod(){<br>
System.out.println(“testMethod”);<br>
}<br>
public static void main(String[] args) {<br>
((TestClass)null).testMethod();<br>
}<br>
}</p>
</blockquote>
<p>我来总结下大家的分析。<br>
1）此处是类对方法的调用，不是对象对方法的调用。<br>
2）方法是static静态方法，直接使用&quot;类.方法&quot;即可，因为静态方法使用不依赖对象是否被创建。<br>
null可以被强制类型转换成任意类型（不是任意类型对象），于是可以通过它来执行静态方法。<br>
3）非静态的方法用&quot;对象.方法&quot;的方式，必须依赖对象被创建后才能使用，若将testMethod()方法前的static去掉，则会报 空指针异常 。此处也验证了2）的观点<br>
当然，不管是否静态方法，都是已经存在的，只是访问方式不同。</p>
<h5 id="线程安全的集合类"><a class="header-anchor" href="#线程安全的集合类">¶</a>线程安全的集合类</h5>
<p>简单记忆线程安全的集合类： 喂！SHE！  喂是指  vector，S是指 stack， H是指    hashtable，E是指：Eenumeration</p>
<p>java1.8实测，抽象类中的抽象方法和非抽象方法在不加修饰符的情况下，都是默认的default</p>
<h5 id="webservice"><a class="header-anchor" href="#webservice">¶</a>webService</h5>
<p>Webservice是跨平台，跨语言的远程调用技术</p>
<p>它的通信机制实质就是xml数据交换;</p>
<p>它采用了soap协议（简单对象协议）进行通信</p>
<h5 id="super关键字"><a class="header-anchor" href="#super关键字">¶</a>super关键字</h5>
<p>super是java提供的一个关键字，super用于限定该对象调用它从父类继承得到的Field或方法。super关键字不能出现在static修饰的方法中，因为static修饰的方法是属于类的。如果在构造器中使用super，则super用于限定该构造器初始化的是该对象从父类继承得到的field，而不是该类自己定义的field。需要注意的是，super关键字只能指代直接父类，不能指代父类的父类。（需要好好理解）</p>
<h5 id="java垃圾回收机制"><a class="header-anchor" href="#java垃圾回收机制">¶</a>java垃圾回收机制</h5>
<p>java提供了一个系统级的线程，即垃圾回收器线程。用来对每一个分配出去的内存空间进行跟踪。当JVM空闲时，自动回收每块可能被回收的内存，GC是完全自动的，不能被强制执行。程序员最多只能用System.gc()来建议执行垃圾回收器回收内存，但是具体的回收时间，是不可知的。<br>
当对象的引用变量被赋值为null，可能被当成垃圾。</p>
<p>对于“程序可明确地标识某个局部变量的引用不再被使用”说法错误</p>
<p>因为，局部变量存放在栈上，栈上的垃圾回收，由finalize()来实现。</p>
<p>参考(<a href="http://www.importnew.com/19085.html" target="_blank" rel="noopener">http://www.importnew.com/19085.html</a>)</p>
<h5 id="重要的知识-可以自己实测"><a class="header-anchor" href="#重要的知识-可以自己实测">¶</a>重要的知识，可以自己实测</h5>
<p>静态内部类可以访问外围类的静态数据，包括（静态）私有数据，但不能访问非静态数据；<br>
非静态内部类可以直接访问外围类的数据，包括私有数据</p>
<h5 id="final修饰变量"><a class="header-anchor" href="#final修饰变量">¶</a>final修饰变量</h5>
<p>一、final修饰变量</p>
<ol>
<li>final可以修饰成员变量，也可以修饰局部变量、形参。final变量一旦获得初始值之后，final的变量就不能被重新赋值。</li>
</ol>
<p>成员变量是随类初始化或对象初始化而初始化的，当执行静态初始化块时候可以对类属性进行赋初始值，当执行普通初始化块或者构造器的时候可以对实例属性赋初始值。因此成员变量的初始值可以在定义的时候赋值或者在初始化块、构造器中指定。</p>
<p>对于final修饰的成员变量而言，一旦有了初始值之后，就不能被重新赋值，因此不可以在普通方法中对成员变量赋值。要么在定义的时候赋值，要么在方法块和构造器中赋值。<br>
final成员变量，必须由程序员显示初始化，系统不会对final成员进行隐式初始化。</p>
<ol start="2">
<li>final修饰局部变量时既可以在定义时候指定默认值，也可以不指定，在后面指定，但只能一次。</li>
<li>final修饰基本类型的时候 变量不能改变</li>
<li>final修饰引用类型变量，final只保证这个引用的地址不变，即一直引用同一对象。但这个对象可以改变。</li>
</ol>
<h5 id="java-构造函数使用方法总结"><a class="header-anchor" href="#java-构造函数使用方法总结">¶</a>java 构造函数使用方法总结</h5>
<p>使用构造器时需要记住：</p>
<ol>
<li>构造器必须与类同名（如果一个源文件中有多个类，那么构造器必须与公共类同名）</li>
<li>每个类可以有一个以上的构造器</li>
<li>构造器可以有0个、1个或1个以上的参数</li>
<li>构造器没有返回值</li>
<li>构造器总是伴随着new操作一起调用</li>
</ol>
<p>使用super调用父类构造器的语句必须是子类构造器的第一条语句</p>
<p>如果子类构造器没有显式地调用父类的构造器，则将自动调用父类的默认（没有参数）的构造器。如果父类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用父类的构造器，则java编译器将报告错误</p>
<h5 id="jvm中垃圾回收分为scanvenge-gc和full-gc-其中full-gc触发的条件可能有哪些"><a class="header-anchor" href="#jvm中垃圾回收分为scanvenge-gc和full-gc-其中full-gc触发的条件可能有哪些">¶</a>jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些</h5>
<ol>
<li>新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。</li>
<li>老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。</li>
<li>持久代：持久代如果满了，将触发Full GC。，System.gc是有可能触发full gc的</li>
</ol>
<h5 id="关于string-stringbuilder以及stringbuffer"><a class="header-anchor" href="#关于string-stringbuilder以及stringbuffer">¶</a>关于String，StringBuilder以及StringBuffer</h5>
<p>A. java中的字符串存储在字符串常量区，不会改变，发生改变是会新创建一个对象<br>
B. StringBuffer是线程安全的StringBuilder<br>
C. StringBuilder跟StringBuffer功能相同，区别是StringBuilder不是线程安全的<br>
D. StringBuilder和StringBuffer底层都是以字符数组存放的，可以修改内容</p>
<h5 id="jdk提供的用于并发编程的同步器有哪些"><a class="header-anchor" href="#jdk提供的用于并发编程的同步器有哪些">¶</a>JDK提供的用于并发编程的同步器有哪些</h5>
<p>A. Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。<br>
B. CyclicBarrier 主要的方法就是一个：await()。await() 方法没被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此 CyclicBarrier 上面阻塞的线程开始运行。<br>
C. 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。</p>
<h5 id="jre-判断程序是否执行结束的标准是"><a class="header-anchor" href="#jre-判断程序是否执行结束的标准是">¶</a>jre 判断程序是否执行结束的标准是（）</h5>
<p>所有的前台线程执行完毕</p>
<p>#####　经过强制类型转换以后，变量a, b的值分别为（ ）short a = 128; byte b = (byte) a;<br>
128  -128</p>
<p>解析：byte在内存中占一个字节，范围是 -128到127之间。<br>
将128强制类型转换为byte型，就超出了byte型的范围，<br>
128的二进制存储是 1000 0000 转换为byte型后，最高位是符号位，值是-128</p>
<h5 id="java异常类"><a class="header-anchor" href="#java异常类">¶</a>JAVA异常类</h5>
<p>参考(<a href="http://www.cnblogs.com/sargeles/p/6691383.html" target="_blank" rel="noopener">http://www.cnblogs.com/sargeles/p/6691383.html</a>)</p>
<h5 id="有关jvm内存"><a class="header-anchor" href="#有关jvm内存">¶</a>有关JVM内存</h5>
<p>运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器<br>
虚拟机栈区 ：也就是我们常说的栈区，线程私有，存放基本类型，对象的引用和 returnAddress ，在编译期间完成分配。<br>
堆区 ， JAVA 堆，也称 GC 堆，所有线程共享，存放对象的实例和数组， JAVA 堆是垃圾收集器管理的主要区域。<br>
方法区 ：所有线程共享，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。<br>
程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。</p>
<h5 id="hashmap跟hashtable的区别"><a class="header-anchor" href="#hashmap跟hashtable的区别">¶</a>hashMap跟hashTable的区别</h5>
<p>①继承不同。</p>
<blockquote>
<p>public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map</p>
</blockquote>
<p>②<br>
Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br>
③<br>
Hashtable中，key和value都不允许出现null值。<br>
在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。<br>
④两个遍历方式的内部实现上不同。<br>
Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br>
⑤<br>
哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br>
⑥<br>
Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<h5 id="下列说法"><a class="header-anchor" href="#下列说法">¶</a>下列说法</h5>
<p>A. ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized;<br>
B. HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Cllectio<br>
C. Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；<br>
D. SimpleDateFormat是线程不安全的</p>
<h5 id="对于以下程序-输出"><a class="header-anchor" href="#对于以下程序-输出">¶</a>对于以下程序 输出</h5>
<blockquote>
<p>public class StringDemo{<br>
private static final String MESSAGE=“taobao”;<br>
public static void main(String [] args) {<br>
String a =“tao”+“bao”;<br>
String b=“tao”;<br>
String c=“bao”;<br>
System.out.println(a==MESSAGE);<br>
System.out.println((b+c)==MESSAGE);<br>
}<br>
}<br>
true false</p>
</blockquote>
<p>要注意两个问题：<br>
1，字符串在java中存储在字符串常量区中<br>
2，==判断的是对象引用是否是同一个引用，判断字符串相等要用equals方法<br>
首先判断a==MESSAGE 同一份字符串常量在内存中只有一份，因此是同一地址，返回true<br>
再次比较(b+c)==MESSAGE 这相当于 new String(b+c)==MESSAGE 这里new了一个String对象，所以返回false</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Java" >
    <span class="tag-code">Java</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/07/09/你不知道的Java（一）/">
        <span class="nav-arrow">← </span>
        
          你不知道的Java（一）
        
      </a>
    
    
      <a class="nav-right" href="/2017/07/16/你不知道的Java（二）/">
        
          你不知道的java（二）
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java的跨平台特性"><span class="toc-nav-text">¶java的跨平台特性</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#数据库事务的隔离级别"><span class="toc-nav-text">¶数据库事务的隔离级别</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#关于instanceof"><span class="toc-nav-text">¶关于instanceof</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#异常"><span class="toc-nav-text">¶异常</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java语言的下面几种数组复制方法中-哪个效率最高？"><span class="toc-nav-text">¶java语言的下面几种数组复制方法中，哪个效率最高？</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java多线程的叙述正确的是"><span class="toc-nav-text">¶JAVA多线程的叙述正确的是</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#如果希望监听tcp端口9000-应该怎样创建socket"><span class="toc-nav-text">¶如果希望监听TCP端口9000，应该怎样创建socket?</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#抽象类-abstract-class-和接口-interface-的区别"><span class="toc-nav-text">¶抽象类(abstract class)和接口(interface)的区别</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#ant和maven"><span class="toc-nav-text">¶Ant和Maven</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#强制转换"><span class="toc-nav-text">¶强制转换</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#finally-关键字"><span class="toc-nav-text">¶finally 关键字</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#以下程序输出结果"><span class="toc-nav-text">¶以下程序输出结果</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java-中的-wait-方法和-sleep-方法的区别"><span class="toc-nav-text">¶java 中的 wait()方法和 sleep()方法的区别</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java-object类"><span class="toc-nav-text">¶java Object类</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#一个小题"><span class="toc-nav-text">¶一个小题</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#线程安全的集合类"><span class="toc-nav-text">¶线程安全的集合类</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#webservice"><span class="toc-nav-text">¶webService</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#super关键字"><span class="toc-nav-text">¶super关键字</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java垃圾回收机制"><span class="toc-nav-text">¶java垃圾回收机制</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#重要的知识-可以自己实测"><span class="toc-nav-text">¶重要的知识，可以自己实测</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#final修饰变量"><span class="toc-nav-text">¶final修饰变量</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java-构造函数使用方法总结"><span class="toc-nav-text">¶java 构造函数使用方法总结</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#jvm中垃圾回收分为scanvenge-gc和full-gc-其中full-gc触发的条件可能有哪些"><span class="toc-nav-text">¶jvm中垃圾回收分为scanvenge gc和full GC，其中full GC触发的条件可能有哪些</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#关于string-stringbuilder以及stringbuffer"><span class="toc-nav-text">¶关于String，StringBuilder以及StringBuffer</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#jdk提供的用于并发编程的同步器有哪些"><span class="toc-nav-text">¶JDK提供的用于并发编程的同步器有哪些</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#jre-判断程序是否执行结束的标准是"><span class="toc-nav-text">¶jre 判断程序是否执行结束的标准是（）</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#java异常类"><span class="toc-nav-text">¶JAVA异常类</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#有关jvm内存"><span class="toc-nav-text">¶有关JVM内存</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#hashmap跟hashtable的区别"><span class="toc-nav-text">¶hashMap跟hashTable的区别</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#下列说法"><span class="toc-nav-text">¶下列说法</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#对于以下程序-输出"><span class="toc-nav-text">¶对于以下程序 输出</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/07/14/你不知道的Java（三）/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "fikyair";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "你不知道的Java（三）",
        owner: "fikyair",
        repo: "fikyair.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = 'null';
  
  var disqus_url = 'http://yoursite.com/2017/07/14/你不知道的Java（三）/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>