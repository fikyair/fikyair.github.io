<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Ignite&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      React 之 Fiber 架构 | Ignite
    
  </title>
  <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/nprogress/0.2.0/nprogress.min.js"></script>
  
    <script src="/js/qrious.js"></script>
  
  
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


  
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Ignite</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>React 之 Fiber 架构</h2>
  <p class="post-date">2021-02-10</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><blockquote>
<p>之前看过一个在 React Summit 上分享的一个视频（原文 <code>7 Lessons to Outlive React</code> ），从宏观上阐释了 React 近年来处于前端框架浪潮之巅的主要原因，其架构和设计理念很可能是今后各种大前端框架的主要参考（如 Flutter），其实 React 之于其他前端框架很像苹果之于诸 OEM 安卓厂商，性能并不是最好的，但生态强大且质量高，旨在依随自己的理念不断的进化自己，而不是与“友商”一味的竞争各种跑分。所以若了解了 React 的架构思想，将对今后的学习和工作有着很大的帮助。</p>
</blockquote>
<a id="more"></a>
<h1>从react代码库的三种模式说起</h1>
<p>目前React代码库(v17.0.2)已经全面使用 Fiber 架构重构，并同时存在三种模式：</p>
<ul>
<li>
<p>Legacy Mode（我们正在用的）, 使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- Blocking Mode, 使用 ```ReactDOM.createBlockingRoot(...).render(...)</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>Concurrent Mode, 使用 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">但是源码编译后只会暴露出Legacy Mode的接口，因为并发模式现在还不是很稳定。</span><br><span class="line"></span><br><span class="line">它们的特点如下：</span><br><span class="line"></span><br><span class="line">- Legacy Mode：同步地进行Reconcile Fiber，Reconcile任务不能被打断，会执行到底</span><br><span class="line">- Blocking Mode：同步地进行Reconcile Fiber，Reconcile任务不能被打断，会执行到底</span><br><span class="line">- Concurrent Mode：“并发地”进行Reconcile Fiber，Reconcile任务可以被打断</span><br><span class="line"></span><br><span class="line">更多细节请看?：[详细区别](https://reactjs.org/docs/concurrent-mode-adoption.html#why-so-many-modes)</span><br><span class="line"></span><br><span class="line">注意，`Concurrent Mode` 所谓的并发，只是一种假象，跟多线程并发完全不一样。多线程并发是多个 Task 跑在多个线程中，这是真正意义上的并发。而 `Concurrent Mode` 的并发是指多个 Tas k跑在同一个主线程（JS主线程）中，只不过每个 Task 都可以不断在“运行”和“暂停”两种状态之间切换，从而给用户造成了一种 Task 并发执行的假象。这其实跟 CPU 的执行原理一样，这就叫 时间分片（Time Slicing）。</span><br><span class="line"></span><br><span class="line">因此，现在我们通过npm i react所安装的包使用ReactDOM.render(...)所创建的React应用的状态是这样的：</span><br><span class="line"></span><br><span class="line">- Fiber：React的Reconcile过程的最小处理单元</span><br><span class="line">- Sync：React的Reconcile过程不能被打断，是同步的</span><br><span class="line">- unbatchedUpdates：在非React的事件中（比如setTimeout），setState无法被批处理</span><br><span class="line">- Suspense：仅能用于加载异步组件</span><br><span class="line"></span><br><span class="line">## React 设计理念</span><br><span class="line"></span><br><span class="line">1. 使用虚拟 Dom 实现跨平台渲染</span><br><span class="line">2. 使用异步可中断和增量更新实现快速响应</span><br><span class="line">   </span><br><span class="line">&gt;同步写法 现在的 cra 官方版本，默认还是同步</span><br><span class="line">`ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;));`</span><br><span class="line">&gt;异步写法，分成若干个时间片执行任务</span><br><span class="line">`ReactDOM.unstable_createRoot(&lt;App /&gt;, document.getElementById(&apos;root&apos;));`</span><br><span class="line">  最小化更新，只在之前的基础上更新</span><br><span class="line"></span><br><span class="line">## 出现性能瓶颈</span><br><span class="line"></span><br><span class="line">- JS任务执行时间过长</span><br><span class="line">- 浏览器刷新频率为60Hz,大概16.6毫秒渲染一次，而JS线程和渲染线程是互斥的，所以如果JS线程执行任务时间超过16.6ms的话，就会导致掉帧，导致卡顿，解决方案就是 React 利用空闲的时间进行更新，不影响渲染进行的渲染</span><br><span class="line">- 把一个耗时任务切分成一个个小任务，分布在每一帧里，这样的方式就叫时间切片</span><br><span class="line"></span><br><span class="line">由于性能瓶颈的出现，出现了 `Fiber`，同时这也是 React 15 的 Stack Reconciler 所面临的问题</span><br><span class="line"></span><br><span class="line">### 屏幕刷新率</span><br><span class="line"></span><br><span class="line">- 目前大多数设备的屏幕刷新率为 `60 次/秒`</span><br><span class="line">- 浏览器渲染动画或页面的每一帧的速率也需要跟设备屏幕的刷新率保持一致</span><br><span class="line">- 页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的,小于这个值时，用户会感觉到卡顿</span><br><span class="line">- 每个帧的预算时间是 `16.66` 毫秒 (1秒/60)</span><br><span class="line">- 1s 60帧，所以每一帧分到的时间是 `1000/60 ≈ 16 ms`,所以我们书写代码时力求不让一帧的工作量超过 `16ms`</span><br><span class="line"></span><br><span class="line">### 帧</span><br><span class="line"></span><br><span class="line">- 每个帧的开头包括样式计算、布局和绘制</span><br><span class="line">- `JavaScript` 执行 `Javascript` 引擎和页面渲染引擎在同一个渲染线程，GUI渲染和 `Javascript` 执行两者是互斥的</span><br><span class="line">- 如果某个任务执行时间过长，浏览器会推迟渲染</span><br><span class="line"></span><br><span class="line">![一帧](http://qiniu.xueshiming.cn/frame.jpeg)</span><br><span class="line"></span><br><span class="line">### requestIdleCallback</span><br><span class="line"></span><br><span class="line">- 我们希望快速响应用户，让用户觉得够快，不能阻塞用户的交互</span><br><span class="line">- `requestIdleCallback` 使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应</span><br><span class="line">- 正常帧任务完成后没超过 `16 ms`,说明时间有富余，此时就会执行 `requestIdleCallback` 里注册的任务</span><br><span class="line"></span><br><span class="line">&gt;因为 requestIdleCallback 目前 safari 和 ie 都不支持，react 为了兼容，使用 messageChannel + requestAnimationFrame 模拟一个 requestIdleCallBack，MessageChannel 将帧长直接固定为5ms。也就是说，MessageChannel实现中，任务每次只会执行5ms，之后便会立即释放主线程，把剩余任务安排到下一次事件循环。</span><br><span class="line"></span><br><span class="line">![requestIdleCallback](http://qiniu.xueshiming.cn/requestIdleCallback.jpeg)</span><br><span class="line"></span><br><span class="line">帧长稳定这样做有如下好处：</span><br><span class="line"></span><br><span class="line">- 帧长稳定，rAF实现基于rAF回调的执行时间来计算帧长，是非常不稳定的，因为浏览器的帧数会因为各种因素产生波动，导致帧长存在很大误差。</span><br><span class="line">- 更好地支持高刷新率设备，因为固定帧长5ms，其实就是假定浏览器帧率为5ms/1帧，也就是1000ms/200帧，也就是最高可以支持每秒200帧的帧率。</span><br><span class="line"></span><br><span class="line">## Fiber是什么</span><br><span class="line"></span><br><span class="line">1. Fiber是一个执行单元,每次执行完一个执行单元, React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去</span><br><span class="line"></span><br><span class="line">![Fiber是一个执行单元](http://qiniu.xueshiming.cn/fiber%E6%98%AF%E4%B8%80%E4%B8%AA%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83.jpeg)</span><br><span class="line"></span><br><span class="line">2. 从编码角度来看，一个 fiber 就是一个 `JavaScript` 对象，是一种数据结构</span><br><span class="line"></span><br><span class="line">- React目前的做法是使用链表, 每个 VirtualDOM 节点内部表示为一个Fiber</span><br><span class="line">- 从顶点开始遍历</span><br><span class="line">- 如果有第一个儿子，先遍历第一个儿子</span><br><span class="line">- 如果没有第一个儿子，标志着此节点遍历完成</span><br><span class="line">- 如果有弟弟遍历弟弟</span><br><span class="line">- 如果有没有下一个弟弟，返回父节点标识完成父节点遍历，如果有叔叔遍历叔叔</span><br><span class="line">- 没有父节点遍历结束</span><br><span class="line"></span><br><span class="line">```md</span><br><span class="line">type Fiber = &#123;</span><br><span class="line">  // 用于标记fiber的WorkTag类型，主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等</span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  // ReactElement里面的key</span><br><span class="line">  key: null | string,</span><br><span class="line">  // ReactElement.type，调用`createElement`的第一个参数</span><br><span class="line">  elementType: any,</span><br><span class="line">  // The resolved function/class/ associated with this fiber.</span><br><span class="line">  // 表示当前代表的节点类型</span><br><span class="line">  type: any,</span><br><span class="line">  // 表示当前FiberNode对应的element组件实例</span><br><span class="line">  stateNode: any,</span><br><span class="line"></span><br><span class="line">  // 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span><br><span class="line">  return: Fiber | null,</span><br><span class="line">  // 指向自己的第一个子节点</span><br><span class="line">  child: Fiber | null,</span><br><span class="line">  // 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span><br><span class="line">  sibling: Fiber | null,</span><br><span class="line">  index: number,</span><br><span class="line"></span><br><span class="line">  ref: null | (((handle: mixed) =&gt; void) &amp; &#123; _stringRef: ?string &#125;) | RefObject,</span><br><span class="line"></span><br><span class="line">  // 当前处理过程中的组件props对象</span><br><span class="line">  pendingProps: any,</span><br><span class="line">  // 上一次渲染完成之后的props</span><br><span class="line">  memoizedProps: any,</span><br><span class="line"></span><br><span class="line">  // 该Fiber对应的组件产生的Update会存放在这个队列里面</span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | null,</span><br><span class="line"></span><br><span class="line">  // 上一次渲染的时候的state</span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line">  // 一个列表，存放这个Fiber依赖的context</span><br><span class="line">  firstContextDependency: ContextDependency&lt;mixed&gt; | null,</span><br><span class="line"></span><br><span class="line">  mode: TypeOfMode,</span><br><span class="line"></span><br><span class="line">  // Effect</span><br><span class="line">  // 用来记录Side Effect</span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line"></span><br><span class="line">  // 单链表用来快速查找下一个side effect</span><br><span class="line">  nextEffect: Fiber | null,</span><br><span class="line"></span><br><span class="line">  // 子树中第一个side effect</span><br><span class="line">  firstEffect: Fiber | null,</span><br><span class="line">  // 子树中最后一个side effect</span><br><span class="line">  lastEffect: Fiber | null,</span><br><span class="line"></span><br><span class="line">  // 代表任务在未来的哪个时间点应该被完成，之后版本改名为 lanes</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  // 快速确定子树中是否有不在等待的变化</span><br><span class="line">  childExpirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  // fiber的版本池，即记录fiber更新过程，便于恢复</span><br><span class="line">  alternate: Fiber | null,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</li>
</ul>
<h2 id="fiber-如何解决问题的">Fiber 如何解决问题的</h2>
<p>Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个&quot;执行单元&quot;，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。</p>
<p>即是实现了&quot;增量渲染&quot;，实现了可中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber 节点。</p>
<ul>
<li>我们可以通过某些调度策略合理分配 CPU 资源，从而提高用户的响应速度</li>
<li>通过Fiber架构，让自己的调和过程变成可被中断。适时地让出CPU执行权，除了可以让浏览器及时地响应用户的交互</li>
</ul>
<p>tips:</p>
<blockquote>
<p>如何确定以一个任务的时长，一帧是 16.6 ms，你的任务肯定不能超过 16.6 ms，浏览器自己的工作时间需要大概 10 ms，所以 react 申请的时间片大概也只有 5ms。</p>
</blockquote>
<h2 id="fiber-实现原理">Fiber 实现原理</h2>
<p>实现的方式是requestIdleCallback这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。</p>
<blockquote>
<p>window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p>
</blockquote>
<p>requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。</p>
<p>即requestIdleCallback的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p>
<p>简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p>
<p>React 16 的Reconciler基于 Fiber 节点实现，被称为 Fiber Reconciler。</p>
<p>作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p>
<p>作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。</p>
<p>每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向父级Fiber节点</span></span><br><span class="line"><span class="keyword">this</span>.return = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 指向子Fiber节点</span></span><br><span class="line"><span class="keyword">this</span>.child = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 指向右边第一个兄弟Fiber节点</span></span><br><span class="line"><span class="keyword">this</span>.sibling = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<h2 id="渲染流程即fiber架构核心">渲染流程即Fiber架构核心</h2>
<ul>
<li><code>Scheduler</code> 调度任务的优先级，高优任务优先进入 Reconciler</li>
<li><code>Reconciler</code> 负责找出变化的组件</li>
<li><code>Renderer</code> 把变更的内容渲染到页面上</li>
</ul>
<p>在新的架构模式下，工作流如下：</p>
<ul>
<li>每个更新任务都会被赋予一个优先级。</li>
<li>当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；<br>
-此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。</li>
<li>当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，即“可恢复”。</li>
</ul>
<h3 id="scheduler-调度器"><code>Scheduler 调度器</code></h3>
<p>这个需要上面提到的 requestIdleCallback，React 团队实现了功能更完备的 requestIdleCallback polyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。</p>
<h3 id="reconciler-协调器"><code>Reconciler 协调器</code></h3>
<p>在 React 15 中是递归处理虚拟 DOM 的，React 16 则是变成了可以中断的循环过程，每次循环都会调用shouldYield判断当前是否有剩余时间。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    <span class="comment">// workInProgress表示当前工作进度的树。</span></span><br><span class="line">    workInProgress = performUnitOfWork(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p>
<p>在 React 16 中，Reconciler 与 Renderer 不再是交替工作。当 Scheduler 将任务交给 Reconciler 后，Reconciler 会为变化的虚拟 DOM 打上的标记。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Placement = <span class="comment">/*             */</span> <span class="number">0b0000000000010</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Update = <span class="comment">/*                */</span> <span class="number">0b0000000000100</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PlacementAndUpdate = <span class="comment">/*    */</span> <span class="number">0b0000000000110</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Deletion = <span class="comment">/*              */</span> <span class="number">0b0000000001000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Placement 表示插入操作</li>
<li>PlacementAndUpdate 表示替换操作</li>
<li>Update 表示更新操作</li>
<li>Deletion 表示删除操作<br>
整个 Scheduler 与 Reconciler 的工作都在内存中进行，所以即使反复中断，用户也不会看见更新不完全的 DOM。只有当所有组件都完成Reconciler 的工作，才会统一交给 Renderer。</li>
</ul>
<h3 id="renderer-渲染器">Renderer 渲染器</h3>
<p>Renderer根据Reconciler为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。</p>
<h2 id="fiber-更新过程">Fiber 更新过程</h2>
<p>React 把组件更新分为两个阶段：</p>
<ul>
<li>render/reconciliation 协调阶段(可中断/异步)：通过 Diff 算法找出所有节点变更，例如节点新增、删除、属性变更等等, 获得需要更新的节点信息，对应早期版本的 Diff 过程。</li>
<li>commit 提交阶段(不可中断/同步)：将需要更新的节点一次过批量更新，对应早期版本的 patch 过程。</li>
</ul>
<h3 id="reconciliation-阶段">reconciliation 阶段</h3>
<ol>
<li>从 <code>workLoop</code> 开始生成 Fiber 树，每生成一个 Fiber 节点，都会把控制钱交给主线程，看看有没有优先级更高的任务，有的话先执行高优任务。   在 workLoop 中的 <code>performUnitOfWork</code> 展示一个工作单元的具体操作。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环执行工作 nextUnitWork</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> shouldYield = <span class="literal">false</span>;<span class="comment">//是否要让出时间片或者说控制权</span></span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);<span class="comment">//执行完一个任务后</span></span><br><span class="line">        shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span>;<span class="comment">//没有时间的话就要让出控制权</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; workInProgressRoot) &#123;<span class="comment">//如果时间片到期后还有任务没有完成，就需要请求浏览器再次调度</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'render阶段结束'</span>);</span><br><span class="line">        commitRoot();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不管有没有任务，都请求再次调度 每一帧都要执行一次workLoop</span></span><br><span class="line">    requestIdleCallback(workLoop, &#123; <span class="attr">timeout</span>: <span class="number">500</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><code>beginWork</code> : 根据传入的 Fiber 节点，创建新的 Fiber 节点，</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">currentFiber</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// beginWork会沿着子树一直更新，每次都会返回当前节点的child。</span></span><br><span class="line">    <span class="comment">// 就算有多个child也只会返回第一个。那么沿着树的结构到达叶子节点的时候，</span></span><br><span class="line">    <span class="comment">// 已经没有child了，所以beginWork返回null。如果返回null的话，就会调用 completeUnitOfWork (这段是在另一篇博客中看到)</span></span><br><span class="line">    beginWork(currentFiber);<span class="comment">//开    // 调用beginWork()更新当前任务节点  ②</span></span><br><span class="line">    <span class="keyword">if</span> (currentFiber.child) &#123;</span><br><span class="line">        <span class="keyword">return</span> currentFiber.child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentFiber) &#123;</span><br><span class="line">        completeUnitOfWork(currentFiber);<span class="comment">//没有儿子让自己完成</span></span><br><span class="line">        <span class="keyword">if</span> (currentFiber.sibling) &#123;<span class="comment">//看有没有弟弟</span></span><br><span class="line">            <span class="keyword">return</span> currentFiber.sibling;<span class="comment">//有弟弟返回弟弟</span></span><br><span class="line">        &#125;</span><br><span class="line">        currentFiber = currentFiber.return;<span class="comment">//找父亲然后让父亲完成</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>根据当前的父Fiber 和虚拟 DOM 通过深度优先遍历（先序遍历）构建 Fiber树</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">workInProgress</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beginWork'</span>,workInProgress.key);</span><br><span class="line">    <span class="keyword">let</span> nextChildren = workInProgress.props.children;</span><br><span class="line">    <span class="keyword">return</span> reconcileChildren(workInProgress,nextChildren);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://qiniu.xueshiming.cn/0AF207B7-9EE2-46D2-A00B-9E384CE525D5.jpeg" alt="reconcileChildren"></p>
<ol start="4">
<li>如果当前fiber树已经更新到叶子节点了，则调用 <code>completeUnitOfWork</code> 更新</li>
</ol>
<p>一个 Fiber 节点在结束的时候要创建真实的 dom 元素，挂载到 stateNode 上面。</p>
<p>然后根据 workInProgress.tag，在完成工作的单元的时候要判断当前的fiber节点有没有对应的DOM操作，收集有副作用的 fiber，然后组成 <code>effect list</code>。每个有副作用的 fiber 有两个属性 <code>firstEffect</code> 指向第一个有副作用的子 <code>fiber lastEffect</code> 指最后一个有副作用子Fiber</p>
<p><code>effect list</code> 用来标识哪个节点需要 添加，修改，或删除操作。</p>
<p><img src="http://qiniu.xueshiming.cn/ACC8891A-BA21-421C-86DA-DBDB00B0615B.jpeg" alt="EffectList"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">workInProgress</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'completeUnitOfWork'</span>,workInProgress.key);</span><br><span class="line">  <span class="keyword">let</span> stateNode;<span class="comment">// 真实DOM</span></span><br><span class="line">  <span class="keyword">switch</span>(workInProgress.tag)&#123;</span><br><span class="line">      <span class="keyword">case</span> TAG_HOST:</span><br><span class="line">          stateNode = createStateNode(workInProgress);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  makeEffectList(workInProgress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="commit-阶段">commit 阶段</h3>
<p>commit 阶段的主要工作（即 Renderer 的工作流程）分为三部分：</p>
<ul>
<li>before mutation 阶段，这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 getSnapshotBeforeUpdate，也会处理 useEffect 钩子相关的调度逻辑。</li>
<li>mutation 阶段，这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据 flags（effectTag）的不同，执行不同的 DOM 操作。</li>
<li>layout 阶段，这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 componentDidMount/componentDidUpdate，调用 useLayoutEffect 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</li>
</ul>
<h2 id="双缓冲">双缓冲</h2>
<h2 id="需补充图片">需补充图片</h2>
<h2 id="参考">参考</h2>
<p><a href="https://segmentfault.com/a/1190000023573713" target="_blank" rel="noopener">React Fiber 源码解析</a></p>
<p><a href="https://segmentfault.com/a/1190000039189408" target="_blank" rel="noopener">浅谈对 React Fiber 的理解</a></p>
<p><a href="http://kmanong.top/kmn/qxw/form/article?id=72482&amp;cate=85" target="_blank" rel="noopener">React Fiber架构</a></p>
<!--
题外
setState
开发版还未发布
1、异步模式，或者说并发模式，不管在哪里更新都会合并。

现在的稳定版
2、同步模式，用了 batchUpdate 就会批量更新，不用就是同步更新。
为什么在事件处理函数中和生命周期函数中是批量的呢，因为调用了 batchUpdate
-->
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#React" >
    <span class="tag-code">React</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2021/01/20/浅析Redux中间件/">
        <span class="nav-arrow">← </span>
        
          浅析 Redux 中间件
        
      </a>
    
    
      <a class="nav-right" href="/2021/02/10/SetState/">
        
          React 中的 SetState
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Disqus START -->
      <div id="disqus_thread"></div>
      <!-- Disqus END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#undefined"><span class="toc-nav-text">从react代码库的三种模式说起</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#fiber-如何解决问题的"><span class="toc-nav-text">Fiber 如何解决问题的</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#fiber-实现原理"><span class="toc-nav-text">Fiber 实现原理</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#渲染流程即fiber架构核心"><span class="toc-nav-text">渲染流程即Fiber架构核心</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#scheduler-调度器"><span class="toc-nav-text">Scheduler 调度器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#reconciler-协调器"><span class="toc-nav-text">Reconciler 协调器</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#renderer-渲染器"><span class="toc-nav-text">Renderer 渲染器</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#fiber-更新过程"><span class="toc-nav-text">Fiber 更新过程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#reconciliation-阶段"><span class="toc-nav-text">reconciliation 阶段</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#commit-阶段"><span class="toc-nav-text">commit 阶段</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#双缓冲"><span class="toc-nav-text">双缓冲</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#需补充图片"><span class="toc-nav-text">需补充图片</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#参考"><span class="toc-nav-text">参考</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://xueshiming.cn/2021/02/10/React 之 Fiber 架构/';
    var banner = 'undefined'
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>


  <script>
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });
  </script>





  <script>
    var disqus_shortname = 'https-xueshiming-cn';
    
    var disqus_url = 'http://xueshiming.cn/2021/02/10/React 之 Fiber 架构/';
    
    (function(){
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//go.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>


    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2021 | <a href="http://beian.miit.gov.cn" target="_blank">津ICP备17005329号</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>